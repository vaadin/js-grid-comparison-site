<html><head></head><body><div hidden="" by-polymer-bundler=""><script>var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function () {
  function resolve() {
    document.body.removeAttribute('unresolved');
  }
  if (window.WebComponents) {
    addEventListener('WebComponentsReady', resolve);
  } else {
    if (document.readyState === 'interactive' || document.readyState === 'complete') {
      resolve();
    } else {
      addEventListener('DOMContentLoaded', resolve);
    }
  }
})();window.Polymer = {
  Settings: function () {
    var settings = window.Polymer || {};
    if (!settings.noUrlSettings) {
      var parts = location.search.slice(1).split('&');
      for (var i = 0, o; i < parts.length && (o = parts[i]); i++) {
        o = o.split('=');
        o[0] && (settings[o[0]] = o[1] || true);
      }
    }
    settings.wantShadow = settings.dom === 'shadow';
    settings.hasShadow = Boolean(Element.prototype.createShadowRoot);
    settings.nativeShadow = settings.hasShadow && !window.ShadowDOMPolyfill;
    settings.useShadow = settings.wantShadow && settings.hasShadow;
    settings.hasNativeImports = Boolean('import' in document.createElement('link'));
    settings.useNativeImports = settings.hasNativeImports;
    settings.useNativeCustomElements = !window.CustomElements || window.CustomElements.useNative;
    settings.useNativeShadow = settings.useShadow && settings.nativeShadow;
    settings.usePolyfillProto = !settings.useNativeCustomElements && !Object.__proto__;
    settings.hasNativeCSSProperties = !navigator.userAgent.match('AppleWebKit/601') && window.CSS && CSS.supports && CSS.supports('box-shadow', '0 0 0 var(--foo)');
    settings.useNativeCSSProperties = settings.hasNativeCSSProperties && settings.lazyRegister && settings.useNativeCSSProperties;
    settings.isIE = navigator.userAgent.match('Trident');
    return settings;
  }()
};(function () {
  var userPolymer = window.Polymer;
  window.Polymer = function (prototype) {
    if (typeof prototype === 'function') {
      prototype = prototype.prototype;
    }
    if (!prototype) {
      prototype = {};
    }
    prototype = desugar(prototype);
    var customCtor = prototype === prototype.constructor.prototype ? prototype.constructor : null;
    var options = { prototype: prototype };
    if (prototype.extends) {
      options.extends = prototype.extends;
    }
    Polymer.telemetry._registrate(prototype);
    var ctor = document.registerElement(prototype.is, options);
    return customCtor || ctor;
  };
  var desugar = function desugar(prototype) {
    var base = Polymer.Base;
    if (prototype.extends) {
      base = Polymer.Base._getExtendedPrototype(prototype.extends);
    }
    prototype = Polymer.Base.chainObject(prototype, base);
    prototype.registerCallback();
    return prototype;
  };
  if (userPolymer) {
    for (var i in userPolymer) {
      Polymer[i] = userPolymer[i];
    }
  }
  Polymer.Class = function (prototype) {
    if (!prototype.factoryImpl) {
      prototype.factoryImpl = function () {};
    }
    return desugar(prototype).constructor;
  };
})();
Polymer.telemetry = {
  registrations: [],
  _regLog: function _regLog(prototype) {
    console.log('[' + prototype.is + ']: registered');
  },
  _registrate: function _registrate(prototype) {
    this.registrations.push(prototype);
    Polymer.log && this._regLog(prototype);
  },
  dumpRegistrations: function dumpRegistrations() {
    this.registrations.forEach(this._regLog);
  }
};Object.defineProperty(window, 'currentImport', {
  enumerable: true,
  configurable: true,
  get: function get() {
    return (document._currentScript || document.currentScript || {}).ownerDocument;
  }
});Polymer.RenderStatus = {
  _ready: false,
  _callbacks: [],
  whenReady: function whenReady(cb) {
    if (this._ready) {
      cb();
    } else {
      this._callbacks.push(cb);
    }
  },
  _makeReady: function _makeReady() {
    this._ready = true;
    for (var i = 0; i < this._callbacks.length; i++) {
      this._callbacks[i]();
    }
    this._callbacks = [];
  },
  _catchFirstRender: function _catchFirstRender() {
    requestAnimationFrame(function () {
      Polymer.RenderStatus._makeReady();
    });
  },
  _afterNextRenderQueue: [],
  _waitingNextRender: false,
  afterNextRender: function afterNextRender(element, fn, args) {
    this._watchNextRender();
    this._afterNextRenderQueue.push([element, fn, args]);
  },
  hasRendered: function hasRendered() {
    return this._ready;
  },
  _watchNextRender: function _watchNextRender() {
    if (!this._waitingNextRender) {
      this._waitingNextRender = true;
      var fn = function fn() {
        Polymer.RenderStatus._flushNextRender();
      };
      if (!this._ready) {
        this.whenReady(fn);
      } else {
        requestAnimationFrame(fn);
      }
    }
  },
  _flushNextRender: function _flushNextRender() {
    var self = this;
    setTimeout(function () {
      self._flushRenderCallbacks(self._afterNextRenderQueue);
      self._afterNextRenderQueue = [];
      self._waitingNextRender = false;
    });
  },
  _flushRenderCallbacks: function _flushRenderCallbacks(callbacks) {
    for (var i = 0, h; i < callbacks.length; i++) {
      h = callbacks[i];
      h[1].apply(h[0], h[2] || Polymer.nar);
    }
  }
};
if (window.HTMLImports) {
  HTMLImports.whenReady(function () {
    Polymer.RenderStatus._catchFirstRender();
  });
} else {
  Polymer.RenderStatus._catchFirstRender();
}
Polymer.ImportStatus = Polymer.RenderStatus;
Polymer.ImportStatus.whenLoaded = Polymer.ImportStatus.whenReady;(function () {
  'use strict';

  var settings = Polymer.Settings;
  Polymer.Base = {
    __isPolymerInstance__: true,
    _addFeature: function _addFeature(feature) {
      this.mixin(this, feature);
    },
    registerCallback: function registerCallback() {
      if (settings.lazyRegister === 'max') {
        if (this.beforeRegister) {
          this.beforeRegister();
        }
      } else {
        this._desugarBehaviors();
        for (var i = 0, b; i < this.behaviors.length; i++) {
          b = this.behaviors[i];
          if (b.beforeRegister) {
            b.beforeRegister.call(this);
          }
        }
        if (this.beforeRegister) {
          this.beforeRegister();
        }
      }
      this._registerFeatures();
      if (!settings.lazyRegister) {
        this.ensureRegisterFinished();
      }
    },
    createdCallback: function createdCallback() {
      if (settings.disableUpgradeEnabled) {
        if (this.hasAttribute('disable-upgrade')) {
          this._propertySetter = disableUpgradePropertySetter;
          this._configValue = null;
          this.__data__ = {};
          return;
        } else {
          this.__hasInitialized = true;
        }
      }
      this.__initialize();
    },
    __initialize: function __initialize() {
      if (!this.__hasRegisterFinished) {
        this._ensureRegisterFinished(this.__proto__);
      }
      Polymer.telemetry.instanceCount++;
      this.root = this;
      for (var i = 0, b; i < this.behaviors.length; i++) {
        b = this.behaviors[i];
        if (b.created) {
          b.created.call(this);
        }
      }
      if (this.created) {
        this.created();
      }
      this._initFeatures();
    },
    ensureRegisterFinished: function ensureRegisterFinished() {
      this._ensureRegisterFinished(this);
    },
    _ensureRegisterFinished: function _ensureRegisterFinished(proto) {
      if (proto.__hasRegisterFinished !== proto.is || !proto.is) {
        if (settings.lazyRegister === 'max') {
          proto._desugarBehaviors();
          for (var i = 0, b; i < proto.behaviors.length; i++) {
            b = proto.behaviors[i];
            if (b.beforeRegister) {
              b.beforeRegister.call(proto);
            }
          }
        }
        proto.__hasRegisterFinished = proto.is;
        if (proto._finishRegisterFeatures) {
          proto._finishRegisterFeatures();
        }
        for (var j = 0, pb; j < proto.behaviors.length; j++) {
          pb = proto.behaviors[j];
          if (pb.registered) {
            pb.registered.call(proto);
          }
        }
        if (proto.registered) {
          proto.registered();
        }
        if (settings.usePolyfillProto && proto !== this) {
          proto.extend(this, proto);
        }
      }
    },
    attachedCallback: function attachedCallback() {
      var self = this;
      Polymer.RenderStatus.whenReady(function () {
        self.isAttached = true;
        for (var i = 0, b; i < self.behaviors.length; i++) {
          b = self.behaviors[i];
          if (b.attached) {
            b.attached.call(self);
          }
        }
        if (self.attached) {
          self.attached();
        }
      });
    },
    detachedCallback: function detachedCallback() {
      var self = this;
      Polymer.RenderStatus.whenReady(function () {
        self.isAttached = false;
        for (var i = 0, b; i < self.behaviors.length; i++) {
          b = self.behaviors[i];
          if (b.detached) {
            b.detached.call(self);
          }
        }
        if (self.detached) {
          self.detached();
        }
      });
    },
    attributeChangedCallback: function attributeChangedCallback(name, oldValue, newValue) {
      this._attributeChangedImpl(name);
      for (var i = 0, b; i < this.behaviors.length; i++) {
        b = this.behaviors[i];
        if (b.attributeChanged) {
          b.attributeChanged.call(this, name, oldValue, newValue);
        }
      }
      if (this.attributeChanged) {
        this.attributeChanged(name, oldValue, newValue);
      }
    },
    _attributeChangedImpl: function _attributeChangedImpl(name) {
      this._setAttributeToProperty(this, name);
    },
    extend: function extend(target, source) {
      if (target && source) {
        var n$ = Object.getOwnPropertyNames(source);
        for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
          this.copyOwnProperty(n, source, target);
        }
      }
      return target || source;
    },
    mixin: function mixin(target, source) {
      for (var i in source) {
        target[i] = source[i];
      }
      return target;
    },
    copyOwnProperty: function copyOwnProperty(name, source, target) {
      var pd = Object.getOwnPropertyDescriptor(source, name);
      if (pd) {
        Object.defineProperty(target, name, pd);
      }
    },
    _logger: function _logger(level, args) {
      if (args.length === 1 && Array.isArray(args[0])) {
        args = args[0];
      }
      switch (level) {
        case 'log':
        case 'warn':
        case 'error':
          console[level].apply(console, args);
          break;
      }
    },
    _log: function _log() {
      var args = Array.prototype.slice.call(arguments, 0);
      this._logger('log', args);
    },
    _warn: function _warn() {
      var args = Array.prototype.slice.call(arguments, 0);
      this._logger('warn', args);
    },
    _error: function _error() {
      var args = Array.prototype.slice.call(arguments, 0);
      this._logger('error', args);
    },
    _logf: function _logf() {
      return this._logPrefix.concat(this.is).concat(Array.prototype.slice.call(arguments, 0));
    }
  };
  Polymer.Base._logPrefix = function () {
    var color = window.chrome && !/edge/i.test(navigator.userAgent) || /firefox/i.test(navigator.userAgent);
    return color ? ['%c[%s::%s]:', 'font-weight: bold; background-color:#EEEE00;'] : ['[%s::%s]:'];
  }();
  Polymer.Base.chainObject = function (object, inherited) {
    if (object && inherited && object !== inherited) {
      if (!Object.__proto__) {
        object = Polymer.Base.extend(Object.create(inherited), object);
      }
      object.__proto__ = inherited;
    }
    return object;
  };
  Polymer.Base = Polymer.Base.chainObject(Polymer.Base, HTMLElement.prototype);
  Polymer.BaseDescriptors = {};
  var disableUpgradePropertySetter;
  if (settings.disableUpgradeEnabled) {
    disableUpgradePropertySetter = function disableUpgradePropertySetter(property, value) {
      this.__data__[property] = value;
    };
    var origAttributeChangedCallback = Polymer.Base.attributeChangedCallback;
    Polymer.Base.attributeChangedCallback = function (name, oldValue, newValue) {
      if (!this.__hasInitialized && name === 'disable-upgrade') {
        this.__hasInitialized = true;
        this._propertySetter = Polymer.Bind._modelApi._propertySetter;
        this._configValue = Polymer.Base._configValue;
        this.__initialize();
      }
      origAttributeChangedCallback.call(this, name, oldValue, newValue);
    };
  }
  if (window.CustomElements) {
    Polymer.instanceof = CustomElements.instanceof;
  } else {
    Polymer.instanceof = function (obj, ctor) {
      return obj instanceof ctor;
    };
  }
  Polymer.isInstance = function (obj) {
    return Boolean(obj && obj.__isPolymerInstance__);
  };
  Polymer.telemetry.instanceCount = 0;
})();(function () {
  var modules = {};
  var lcModules = {};
  var findModule = function findModule(id) {
    return modules[id] || lcModules[id.toLowerCase()];
  };
  var DomModule = function DomModule() {
    return document.createElement('dom-module');
  };
  DomModule.prototype = Object.create(HTMLElement.prototype);
  Polymer.Base.mixin(DomModule.prototype, {
    createdCallback: function createdCallback() {
      this.register();
    },
    register: function register(id) {
      id = id || this.id || this.getAttribute('name') || this.getAttribute('is');
      if (id) {
        this.id = id;
        modules[id] = this;
        lcModules[id.toLowerCase()] = this;
      }
    },
    import: function _import(id, selector) {
      if (id) {
        var m = findModule(id);
        if (!m) {
          forceDomModulesUpgrade();
          m = findModule(id);
        }
        if (m && selector) {
          m = m.querySelector(selector);
        }
        return m;
      }
    }
  });
  Object.defineProperty(DomModule.prototype, 'constructor', {
    value: DomModule,
    configurable: true,
    writable: true
  });
  var cePolyfill = window.CustomElements && !CustomElements.useNative;
  document.registerElement('dom-module', DomModule);
  function forceDomModulesUpgrade() {
    if (cePolyfill) {
      var script = document._currentScript || document.currentScript;
      var doc = script && script.ownerDocument || document;
      var modules = doc.querySelectorAll('dom-module');
      for (var i = modules.length - 1, m; i >= 0 && (m = modules[i]); i--) {
        if (m.__upgraded__) {
          return;
        } else {
          CustomElements.upgrade(m);
        }
      }
    }
  }
})();Polymer.Base._addFeature({
  _prepIs: function _prepIs() {
    if (!this.is) {
      var module = (document._currentScript || document.currentScript).parentNode;
      if (module.localName === 'dom-module') {
        var id = module.id || module.getAttribute('name') || module.getAttribute('is');
        this.is = id;
      }
    }
    if (this.is) {
      this.is = this.is.toLowerCase();
    }
  }
});Polymer.Base._addFeature({
  behaviors: [],
  _desugarBehaviors: function _desugarBehaviors() {
    if (this.behaviors.length) {
      this.behaviors = this._desugarSomeBehaviors(this.behaviors);
    }
  },
  _desugarSomeBehaviors: function _desugarSomeBehaviors(behaviors) {
    var behaviorSet = [];
    behaviors = this._flattenBehaviorsList(behaviors);
    for (var i = behaviors.length - 1; i >= 0; i--) {
      var b = behaviors[i];
      if (behaviorSet.indexOf(b) === -1) {
        this._mixinBehavior(b);
        behaviorSet.unshift(b);
      }
    }
    return behaviorSet;
  },
  _flattenBehaviorsList: function _flattenBehaviorsList(behaviors) {
    var flat = [];
    for (var i = 0; i < behaviors.length; i++) {
      var b = behaviors[i];
      if (b instanceof Array) {
        flat = flat.concat(this._flattenBehaviorsList(b));
      } else if (b) {
        flat.push(b);
      } else {
        this._warn(this._logf('_flattenBehaviorsList', 'behavior is null, check for missing or 404 import'));
      }
    }
    return flat;
  },
  _mixinBehavior: function _mixinBehavior(b) {
    var n$ = Object.getOwnPropertyNames(b);
    var useAssignment = b._noAccessors;
    for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
      if (!Polymer.Base._behaviorProperties[n] && !this.hasOwnProperty(n)) {
        if (useAssignment) {
          this[n] = b[n];
        } else {
          this.copyOwnProperty(n, b, this);
        }
      }
    }
  },
  _prepBehaviors: function _prepBehaviors() {
    this._prepFlattenedBehaviors(this.behaviors);
  },
  _prepFlattenedBehaviors: function _prepFlattenedBehaviors(behaviors) {
    for (var i = 0, l = behaviors.length; i < l; i++) {
      this._prepBehavior(behaviors[i]);
    }
    this._prepBehavior(this);
  },
  _marshalBehaviors: function _marshalBehaviors() {
    for (var i = 0; i < this.behaviors.length; i++) {
      this._marshalBehavior(this.behaviors[i]);
    }
    this._marshalBehavior(this);
  }
});
Polymer.Base._behaviorProperties = {
  hostAttributes: true,
  beforeRegister: true,
  registered: true,
  properties: true,
  observers: true,
  listeners: true,
  created: true,
  attached: true,
  detached: true,
  attributeChanged: true,
  ready: true,
  _noAccessors: true
};Polymer.Base._addFeature({
  _getExtendedPrototype: function _getExtendedPrototype(tag) {
    return this._getExtendedNativePrototype(tag);
  },
  _nativePrototypes: {},
  _getExtendedNativePrototype: function _getExtendedNativePrototype(tag) {
    var p = this._nativePrototypes[tag];
    if (!p) {
      p = Object.create(this.getNativePrototype(tag));
      var p$ = Object.getOwnPropertyNames(Polymer.Base);
      for (var i = 0, n; i < p$.length && (n = p$[i]); i++) {
        if (!Polymer.BaseDescriptors[n]) {
          p[n] = Polymer.Base[n];
        }
      }
      Object.defineProperties(p, Polymer.BaseDescriptors);
      this._nativePrototypes[tag] = p;
    }
    return p;
  },
  getNativePrototype: function getNativePrototype(tag) {
    return Object.getPrototypeOf(document.createElement(tag));
  }
});Polymer.Base._addFeature({
  _prepConstructor: function _prepConstructor() {
    this._factoryArgs = this.extends ? [this.extends, this.is] : [this.is];
    var ctor = function ctor() {
      return this._factory(arguments);
    };
    if (this.hasOwnProperty('extends')) {
      ctor.extends = this.extends;
    }
    Object.defineProperty(this, 'constructor', {
      value: ctor,
      writable: true,
      configurable: true
    });
    ctor.prototype = this;
  },
  _factory: function _factory(args) {
    var elt = document.createElement.apply(document, this._factoryArgs);
    if (this.factoryImpl) {
      this.factoryImpl.apply(elt, args);
    }
    return elt;
  }
});Polymer.nob = Object.create(null);
Polymer.Base._addFeature({
  getPropertyInfo: function getPropertyInfo(property) {
    var info = this._getPropertyInfo(property, this.properties);
    if (!info) {
      for (var i = 0; i < this.behaviors.length; i++) {
        info = this._getPropertyInfo(property, this.behaviors[i].properties);
        if (info) {
          return info;
        }
      }
    }
    return info || Polymer.nob;
  },
  _getPropertyInfo: function _getPropertyInfo(property, properties) {
    var p = properties && properties[property];
    if (typeof p === 'function') {
      p = properties[property] = { type: p };
    }
    if (p) {
      p.defined = true;
    }
    return p;
  },
  _prepPropertyInfo: function _prepPropertyInfo() {
    this._propertyInfo = {};
    for (var i = 0; i < this.behaviors.length; i++) {
      this._addPropertyInfo(this._propertyInfo, this.behaviors[i].properties);
    }
    this._addPropertyInfo(this._propertyInfo, this.properties);
    this._addPropertyInfo(this._propertyInfo, this._propertyEffects);
  },
  _addPropertyInfo: function _addPropertyInfo(target, source) {
    if (source) {
      var t, s;
      for (var i in source) {
        t = target[i];
        s = source[i];
        if (i[0] === '_' && !s.readOnly) {
          continue;
        }
        if (!target[i]) {
          target[i] = {
            type: typeof s === 'function' ? s : s.type,
            readOnly: s.readOnly,
            attribute: Polymer.CaseMap.camelToDashCase(i)
          };
        } else {
          if (!t.type) {
            t.type = s.type;
          }
          if (!t.readOnly) {
            t.readOnly = s.readOnly;
          }
        }
      }
    }
  }
});
(function () {
  var propertiesDesc = {
    configurable: true,
    writable: true,
    enumerable: true,
    value: {}
  };
  Polymer.BaseDescriptors.properties = propertiesDesc;
  Object.defineProperty(Polymer.Base, 'properties', propertiesDesc);
})();Polymer.CaseMap = {
  _caseMap: {},
  _rx: {
    dashToCamel: /-[a-z]/g,
    camelToDash: /([A-Z])/g
  },
  dashToCamelCase: function dashToCamelCase(dash) {
    return this._caseMap[dash] || (this._caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(this._rx.dashToCamel, function (m) {
      return m[1].toUpperCase();
    }));
  },
  camelToDashCase: function camelToDashCase(camel) {
    return this._caseMap[camel] || (this._caseMap[camel] = camel.replace(this._rx.camelToDash, '-$1').toLowerCase());
  }
};Polymer.Base._addFeature({
  _addHostAttributes: function _addHostAttributes(attributes) {
    if (!this._aggregatedAttributes) {
      this._aggregatedAttributes = {};
    }
    if (attributes) {
      this.mixin(this._aggregatedAttributes, attributes);
    }
  },
  _marshalHostAttributes: function _marshalHostAttributes() {
    if (this._aggregatedAttributes) {
      this._applyAttributes(this, this._aggregatedAttributes);
    }
  },
  _applyAttributes: function _applyAttributes(node, attr$) {
    for (var n in attr$) {
      if (!this.hasAttribute(n) && n !== 'class') {
        var v = attr$[n];
        this.serializeValueToAttribute(v, n, this);
      }
    }
  },
  _marshalAttributes: function _marshalAttributes() {
    this._takeAttributesToModel(this);
  },
  _takeAttributesToModel: function _takeAttributesToModel(model) {
    if (this.hasAttributes()) {
      for (var i in this._propertyInfo) {
        var info = this._propertyInfo[i];
        if (this.hasAttribute(info.attribute)) {
          this._setAttributeToProperty(model, info.attribute, i, info);
        }
      }
    }
  },
  _setAttributeToProperty: function _setAttributeToProperty(model, attribute, property, info) {
    if (!this._serializing) {
      property = property || Polymer.CaseMap.dashToCamelCase(attribute);
      info = info || this._propertyInfo && this._propertyInfo[property];
      if (info && !info.readOnly) {
        var v = this.getAttribute(attribute);
        model[property] = this.deserialize(v, info.type);
      }
    }
  },
  _serializing: false,
  reflectPropertyToAttribute: function reflectPropertyToAttribute(property, attribute, value) {
    this._serializing = true;
    value = value === undefined ? this[property] : value;
    this.serializeValueToAttribute(value, attribute || Polymer.CaseMap.camelToDashCase(property));
    this._serializing = false;
  },
  serializeValueToAttribute: function serializeValueToAttribute(value, attribute, node) {
    var str = this.serialize(value);
    node = node || this;
    if (str === undefined) {
      node.removeAttribute(attribute);
    } else {
      node.setAttribute(attribute, str);
    }
  },
  deserialize: function deserialize(value, type) {
    switch (type) {
      case Number:
        value = Number(value);
        break;
      case Boolean:
        value = value != null;
        break;
      case Object:
        try {
          value = JSON.parse(value);
        } catch (x) {}
        break;
      case Array:
        try {
          value = JSON.parse(value);
        } catch (x) {
          value = null;
          console.warn('Polymer::Attributes: couldn`t decode Array as JSON');
        }
        break;
      case Date:
        value = new Date(value);
        break;
      case String:
      default:
        break;
    }
    return value;
  },
  serialize: function serialize(value) {
    switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {
      case 'boolean':
        return value ? '' : undefined;
      case 'object':
        if (value instanceof Date) {
          return value.toString();
        } else if (value) {
          try {
            return JSON.stringify(value);
          } catch (x) {
            return '';
          }
        }
      default:
        return value != null ? value : undefined;
    }
  }
});Polymer.version = "1.9.1";Polymer.Base._addFeature({
  _registerFeatures: function _registerFeatures() {
    this._prepIs();
    this._prepBehaviors();
    this._prepConstructor();
    this._prepPropertyInfo();
  },
  _prepBehavior: function _prepBehavior(b) {
    this._addHostAttributes(b.hostAttributes);
  },
  _marshalBehavior: function _marshalBehavior(b) {},
  _initFeatures: function _initFeatures() {
    this._marshalHostAttributes();
    this._marshalBehaviors();
  }
});</script><script>(function () {
  function resolveCss(cssText, ownerDocument) {
    return cssText.replace(CSS_URL_RX, function (m, pre, url, post) {
      return pre + '\'' + resolve(url.replace(/["']/g, ''), ownerDocument) + '\'' + post;
    });
  }
  function resolveAttrs(element, ownerDocument) {
    for (var name in URL_ATTRS) {
      var a$ = URL_ATTRS[name];
      for (var i = 0, l = a$.length, a, at, v; i < l && (a = a$[i]); i++) {
        if (name === '*' || element.localName === name) {
          at = element.attributes[a];
          v = at && at.value;
          if (v && v.search(BINDING_RX) < 0) {
            at.value = a === 'style' ? resolveCss(v, ownerDocument) : resolve(v, ownerDocument);
          }
        }
      }
    }
  }
  function resolve(url, ownerDocument) {
    if (url && ABS_URL.test(url)) {
      return url;
    }
    var resolver = getUrlResolver(ownerDocument);
    resolver.href = url;
    return resolver.href || url;
  }
  var tempDoc;
  var tempDocBase;
  function resolveUrl(url, baseUri) {
    if (!tempDoc) {
      tempDoc = document.implementation.createHTMLDocument('temp');
      tempDocBase = tempDoc.createElement('base');
      tempDoc.head.appendChild(tempDocBase);
    }
    tempDocBase.href = baseUri;
    return resolve(url, tempDoc);
  }
  function getUrlResolver(ownerDocument) {
    return ownerDocument.body.__urlResolver || (ownerDocument.body.__urlResolver = ownerDocument.createElement('a'));
  }
  function pathFromUrl(url) {
    return url.substring(0, url.lastIndexOf('/') + 1);
  }
  var CSS_URL_RX = /(url\()([^)]*)(\))/g;
  var URL_ATTRS = {
    '*': ['href', 'src', 'style', 'url'],
    form: ['action']
  };
  var ABS_URL = /(^\/)|(^#)|(^[\w-\d]*:)/;
  var BINDING_RX = /\{\{|\[\[/;
  Polymer.ResolveUrl = {
    resolveCss: resolveCss,
    resolveAttrs: resolveAttrs,
    resolveUrl: resolveUrl,
    pathFromUrl: pathFromUrl
  };
  Polymer.rootPath = Polymer.Settings.rootPath || pathFromUrl(document.baseURI || window.location.href);
})();Polymer.Base._addFeature({
  _prepTemplate: function _prepTemplate() {
    var module;
    if (this._template === undefined) {
      module = Polymer.DomModule.import(this.is);
      this._template = module && module.querySelector('template');
    }
    if (module) {
      var assetPath = module.getAttribute('assetpath') || '';
      var importURL = Polymer.ResolveUrl.resolveUrl(assetPath, module.ownerDocument.baseURI);
      this._importPath = Polymer.ResolveUrl.pathFromUrl(importURL);
    } else {
      this._importPath = '';
    }
    if (this._template && this._template.hasAttribute('is')) {
      this._warn(this._logf('_prepTemplate', 'top-level Polymer template ' + 'must not be a type-extension, found', this._template, 'Move inside simple <template>.'));
    }
    if (this._template && !this._template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
      HTMLTemplateElement.decorate(this._template);
    }
  },
  _stampTemplate: function _stampTemplate() {
    if (this._template) {
      this.root = this.instanceTemplate(this._template);
    }
  },
  instanceTemplate: function instanceTemplate(template) {
    var dom = document.importNode(template._content || template.content, true);
    return dom;
  }
});(function () {
  var baseAttachedCallback = Polymer.Base.attachedCallback;
  Polymer.Base._addFeature({
    _hostStack: [],
    ready: function ready() {},
    _registerHost: function _registerHost(host) {
      this.dataHost = host = host || Polymer.Base._hostStack[Polymer.Base._hostStack.length - 1];
      if (host && host._clients) {
        host._clients.push(this);
      }
      this._clients = null;
      this._clientsReadied = false;
    },
    _beginHosting: function _beginHosting() {
      Polymer.Base._hostStack.push(this);
      if (!this._clients) {
        this._clients = [];
      }
    },
    _endHosting: function _endHosting() {
      Polymer.Base._hostStack.pop();
    },
    _tryReady: function _tryReady() {
      this._readied = false;
      if (this._canReady()) {
        this._ready();
      }
    },
    _canReady: function _canReady() {
      return !this.dataHost || this.dataHost._clientsReadied;
    },
    _ready: function _ready() {
      this._beforeClientsReady();
      if (this._template) {
        this._setupRoot();
        this._readyClients();
      }
      this._clientsReadied = true;
      this._clients = null;
      this._afterClientsReady();
      this._readySelf();
    },
    _readyClients: function _readyClients() {
      this._beginDistribute();
      var c$ = this._clients;
      if (c$) {
        for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
          c._ready();
        }
      }
      this._finishDistribute();
    },
    _readySelf: function _readySelf() {
      for (var i = 0, b; i < this.behaviors.length; i++) {
        b = this.behaviors[i];
        if (b.ready) {
          b.ready.call(this);
        }
      }
      if (this.ready) {
        this.ready();
      }
      this._readied = true;
      if (this._attachedPending) {
        this._attachedPending = false;
        this.attachedCallback();
      }
    },
    _beforeClientsReady: function _beforeClientsReady() {},
    _afterClientsReady: function _afterClientsReady() {},
    _beforeAttached: function _beforeAttached() {},
    attachedCallback: function attachedCallback() {
      if (this._readied) {
        this._beforeAttached();
        baseAttachedCallback.call(this);
      } else {
        this._attachedPending = true;
      }
    }
  });
})();Polymer.ArraySplice = function () {
  function newSplice(index, removed, addedCount) {
    return {
      index: index,
      removed: removed,
      addedCount: addedCount
    };
  }
  var EDIT_LEAVE = 0;
  var EDIT_UPDATE = 1;
  var EDIT_ADD = 2;
  var EDIT_DELETE = 3;
  function ArraySplice() {}
  ArraySplice.prototype = {
    calcEditDistances: function calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {
      var rowCount = oldEnd - oldStart + 1;
      var columnCount = currentEnd - currentStart + 1;
      var distances = new Array(rowCount);
      for (var i = 0; i < rowCount; i++) {
        distances[i] = new Array(columnCount);
        distances[i][0] = i;
      }
      for (var j = 0; j < columnCount; j++) {
        distances[0][j] = j;
      }for (i = 1; i < rowCount; i++) {
        for (j = 1; j < columnCount; j++) {
          if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1])) distances[i][j] = distances[i - 1][j - 1];else {
            var north = distances[i - 1][j] + 1;
            var west = distances[i][j - 1] + 1;
            distances[i][j] = north < west ? north : west;
          }
        }
      }
      return distances;
    },
    spliceOperationsFromEditDistances: function spliceOperationsFromEditDistances(distances) {
      var i = distances.length - 1;
      var j = distances[0].length - 1;
      var current = distances[i][j];
      var edits = [];
      while (i > 0 || j > 0) {
        if (i == 0) {
          edits.push(EDIT_ADD);
          j--;
          continue;
        }
        if (j == 0) {
          edits.push(EDIT_DELETE);
          i--;
          continue;
        }
        var northWest = distances[i - 1][j - 1];
        var west = distances[i - 1][j];
        var north = distances[i][j - 1];
        var min;
        if (west < north) min = west < northWest ? west : northWest;else min = north < northWest ? north : northWest;
        if (min == northWest) {
          if (northWest == current) {
            edits.push(EDIT_LEAVE);
          } else {
            edits.push(EDIT_UPDATE);
            current = northWest;
          }
          i--;
          j--;
        } else if (min == west) {
          edits.push(EDIT_DELETE);
          i--;
          current = west;
        } else {
          edits.push(EDIT_ADD);
          j--;
          current = north;
        }
      }
      edits.reverse();
      return edits;
    },
    calcSplices: function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {
      var prefixCount = 0;
      var suffixCount = 0;
      var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
      if (currentStart == 0 && oldStart == 0) prefixCount = this.sharedPrefix(current, old, minLength);
      if (currentEnd == current.length && oldEnd == old.length) suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);
      currentStart += prefixCount;
      oldStart += prefixCount;
      currentEnd -= suffixCount;
      oldEnd -= suffixCount;
      if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0) return [];
      if (currentStart == currentEnd) {
        var splice = newSplice(currentStart, [], 0);
        while (oldStart < oldEnd) {
          splice.removed.push(old[oldStart++]);
        }return [splice];
      } else if (oldStart == oldEnd) return [newSplice(currentStart, [], currentEnd - currentStart)];
      var ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));
      splice = undefined;
      var splices = [];
      var index = currentStart;
      var oldIndex = oldStart;
      for (var i = 0; i < ops.length; i++) {
        switch (ops[i]) {
          case EDIT_LEAVE:
            if (splice) {
              splices.push(splice);
              splice = undefined;
            }
            index++;
            oldIndex++;
            break;
          case EDIT_UPDATE:
            if (!splice) splice = newSplice(index, [], 0);
            splice.addedCount++;
            index++;
            splice.removed.push(old[oldIndex]);
            oldIndex++;
            break;
          case EDIT_ADD:
            if (!splice) splice = newSplice(index, [], 0);
            splice.addedCount++;
            index++;
            break;
          case EDIT_DELETE:
            if (!splice) splice = newSplice(index, [], 0);
            splice.removed.push(old[oldIndex]);
            oldIndex++;
            break;
        }
      }
      if (splice) {
        splices.push(splice);
      }
      return splices;
    },
    sharedPrefix: function sharedPrefix(current, old, searchLength) {
      for (var i = 0; i < searchLength; i++) {
        if (!this.equals(current[i], old[i])) return i;
      }return searchLength;
    },
    sharedSuffix: function sharedSuffix(current, old, searchLength) {
      var index1 = current.length;
      var index2 = old.length;
      var count = 0;
      while (count < searchLength && this.equals(current[--index1], old[--index2])) {
        count++;
      }return count;
    },
    calculateSplices: function calculateSplices(current, previous) {
      return this.calcSplices(current, 0, current.length, previous, 0, previous.length);
    },
    equals: function equals(currentValue, previousValue) {
      return currentValue === previousValue;
    }
  };
  return new ArraySplice();
}();Polymer.domInnerHTML = function () {
  var escapeAttrRegExp = /[&\u00A0"]/g;
  var escapeDataRegExp = /[&\u00A0<>]/g;
  function escapeReplace(c) {
    switch (c) {
      case '&':
        return '&amp;';
      case '<':
        return '&lt;';
      case '>':
        return '&gt;';
      case '"':
        return '&quot;';
      case '\xA0':
        return '&nbsp;';
    }
  }
  function escapeAttr(s) {
    return s.replace(escapeAttrRegExp, escapeReplace);
  }
  function escapeData(s) {
    return s.replace(escapeDataRegExp, escapeReplace);
  }
  function makeSet(arr) {
    var set = {};
    for (var i = 0; i < arr.length; i++) {
      set[arr[i]] = true;
    }
    return set;
  }
  var voidElements = makeSet(['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr']);
  var plaintextParents = makeSet(['style', 'script', 'xmp', 'iframe', 'noembed', 'noframes', 'plaintext', 'noscript']);
  function getOuterHTML(node, parentNode, composed) {
    switch (node.nodeType) {
      case Node.ELEMENT_NODE:
        var tagName = node.localName;
        var s = '<' + tagName;
        var attrs = node.attributes;
        for (var i = 0, attr; attr = attrs[i]; i++) {
          s += ' ' + attr.name + '="' + escapeAttr(attr.value) + '"';
        }
        s += '>';
        if (voidElements[tagName]) {
          return s;
        }
        return s + getInnerHTML(node, composed) + '</' + tagName + '>';
      case Node.TEXT_NODE:
        var data = node.data;
        if (parentNode && plaintextParents[parentNode.localName]) {
          return data;
        }
        return escapeData(data);
      case Node.COMMENT_NODE:
        return '<!--' + node.data + '-->';
      default:
        console.error(node);
        throw new Error('not implemented');
    }
  }
  function getInnerHTML(node, composed) {
    if (node instanceof HTMLTemplateElement) node = node.content;
    var s = '';
    var c$ = Polymer.dom(node).childNodes;
    for (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {
      s += getOuterHTML(child, node, composed);
    }
    return s;
  }
  return { getInnerHTML: getInnerHTML };
}();(function () {
  'use strict';

  var nativeInsertBefore = Element.prototype.insertBefore;
  var nativeAppendChild = Element.prototype.appendChild;
  var nativeRemoveChild = Element.prototype.removeChild;
  Polymer.TreeApi = {
    arrayCopyChildNodes: function arrayCopyChildNodes(parent) {
      var copy = [],
          i = 0;
      for (var n = parent.firstChild; n; n = n.nextSibling) {
        copy[i++] = n;
      }
      return copy;
    },
    arrayCopyChildren: function arrayCopyChildren(parent) {
      var copy = [],
          i = 0;
      for (var n = parent.firstElementChild; n; n = n.nextElementSibling) {
        copy[i++] = n;
      }
      return copy;
    },
    arrayCopy: function arrayCopy(a$) {
      var l = a$.length;
      var copy = new Array(l);
      for (var i = 0; i < l; i++) {
        copy[i] = a$[i];
      }
      return copy;
    }
  };
  Polymer.TreeApi.Logical = {
    hasParentNode: function hasParentNode(node) {
      return Boolean(node.__dom && node.__dom.parentNode);
    },
    hasChildNodes: function hasChildNodes(node) {
      return Boolean(node.__dom && node.__dom.childNodes !== undefined);
    },
    getChildNodes: function getChildNodes(node) {
      return this.hasChildNodes(node) ? this._getChildNodes(node) : node.childNodes;
    },
    _getChildNodes: function _getChildNodes(node) {
      if (!node.__dom.childNodes) {
        node.__dom.childNodes = [];
        for (var n = node.__dom.firstChild; n; n = n.__dom.nextSibling) {
          node.__dom.childNodes.push(n);
        }
      }
      return node.__dom.childNodes;
    },
    getParentNode: function getParentNode(node) {
      return node.__dom && node.__dom.parentNode !== undefined ? node.__dom.parentNode : node.parentNode;
    },
    getFirstChild: function getFirstChild(node) {
      return node.__dom && node.__dom.firstChild !== undefined ? node.__dom.firstChild : node.firstChild;
    },
    getLastChild: function getLastChild(node) {
      return node.__dom && node.__dom.lastChild !== undefined ? node.__dom.lastChild : node.lastChild;
    },
    getNextSibling: function getNextSibling(node) {
      return node.__dom && node.__dom.nextSibling !== undefined ? node.__dom.nextSibling : node.nextSibling;
    },
    getPreviousSibling: function getPreviousSibling(node) {
      return node.__dom && node.__dom.previousSibling !== undefined ? node.__dom.previousSibling : node.previousSibling;
    },
    getFirstElementChild: function getFirstElementChild(node) {
      return node.__dom && node.__dom.firstChild !== undefined ? this._getFirstElementChild(node) : node.firstElementChild;
    },
    _getFirstElementChild: function _getFirstElementChild(node) {
      var n = node.__dom.firstChild;
      while (n && n.nodeType !== Node.ELEMENT_NODE) {
        n = n.__dom.nextSibling;
      }
      return n;
    },
    getLastElementChild: function getLastElementChild(node) {
      return node.__dom && node.__dom.lastChild !== undefined ? this._getLastElementChild(node) : node.lastElementChild;
    },
    _getLastElementChild: function _getLastElementChild(node) {
      var n = node.__dom.lastChild;
      while (n && n.nodeType !== Node.ELEMENT_NODE) {
        n = n.__dom.previousSibling;
      }
      return n;
    },
    getNextElementSibling: function getNextElementSibling(node) {
      return node.__dom && node.__dom.nextSibling !== undefined ? this._getNextElementSibling(node) : node.nextElementSibling;
    },
    _getNextElementSibling: function _getNextElementSibling(node) {
      var n = node.__dom.nextSibling;
      while (n && n.nodeType !== Node.ELEMENT_NODE) {
        n = n.__dom.nextSibling;
      }
      return n;
    },
    getPreviousElementSibling: function getPreviousElementSibling(node) {
      return node.__dom && node.__dom.previousSibling !== undefined ? this._getPreviousElementSibling(node) : node.previousElementSibling;
    },
    _getPreviousElementSibling: function _getPreviousElementSibling(node) {
      var n = node.__dom.previousSibling;
      while (n && n.nodeType !== Node.ELEMENT_NODE) {
        n = n.__dom.previousSibling;
      }
      return n;
    },
    saveChildNodes: function saveChildNodes(node) {
      if (!this.hasChildNodes(node)) {
        node.__dom = node.__dom || {};
        node.__dom.firstChild = node.firstChild;
        node.__dom.lastChild = node.lastChild;
        node.__dom.childNodes = [];
        for (var n = node.firstChild; n; n = n.nextSibling) {
          n.__dom = n.__dom || {};
          n.__dom.parentNode = node;
          node.__dom.childNodes.push(n);
          n.__dom.nextSibling = n.nextSibling;
          n.__dom.previousSibling = n.previousSibling;
        }
      }
    },
    recordInsertBefore: function recordInsertBefore(node, container, ref_node) {
      container.__dom.childNodes = null;
      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        for (var n = node.firstChild; n; n = n.nextSibling) {
          this._linkNode(n, container, ref_node);
        }
      } else {
        this._linkNode(node, container, ref_node);
      }
    },
    _linkNode: function _linkNode(node, container, ref_node) {
      node.__dom = node.__dom || {};
      container.__dom = container.__dom || {};
      if (ref_node) {
        ref_node.__dom = ref_node.__dom || {};
      }
      node.__dom.previousSibling = ref_node ? ref_node.__dom.previousSibling : container.__dom.lastChild;
      if (node.__dom.previousSibling) {
        node.__dom.previousSibling.__dom.nextSibling = node;
      }
      node.__dom.nextSibling = ref_node || null;
      if (node.__dom.nextSibling) {
        node.__dom.nextSibling.__dom.previousSibling = node;
      }
      node.__dom.parentNode = container;
      if (ref_node) {
        if (ref_node === container.__dom.firstChild) {
          container.__dom.firstChild = node;
        }
      } else {
        container.__dom.lastChild = node;
        if (!container.__dom.firstChild) {
          container.__dom.firstChild = node;
        }
      }
      container.__dom.childNodes = null;
    },
    recordRemoveChild: function recordRemoveChild(node, container) {
      node.__dom = node.__dom || {};
      container.__dom = container.__dom || {};
      if (node === container.__dom.firstChild) {
        container.__dom.firstChild = node.__dom.nextSibling;
      }
      if (node === container.__dom.lastChild) {
        container.__dom.lastChild = node.__dom.previousSibling;
      }
      var p = node.__dom.previousSibling;
      var n = node.__dom.nextSibling;
      if (p) {
        p.__dom.nextSibling = n;
      }
      if (n) {
        n.__dom.previousSibling = p;
      }
      node.__dom.parentNode = node.__dom.previousSibling = node.__dom.nextSibling = undefined;
      container.__dom.childNodes = null;
    }
  };
  Polymer.TreeApi.Composed = {
    getChildNodes: function getChildNodes(node) {
      return Polymer.TreeApi.arrayCopyChildNodes(node);
    },
    getParentNode: function getParentNode(node) {
      return node.parentNode;
    },
    clearChildNodes: function clearChildNodes(node) {
      node.textContent = '';
    },
    insertBefore: function insertBefore(parentNode, newChild, refChild) {
      return nativeInsertBefore.call(parentNode, newChild, refChild || null);
    },
    appendChild: function appendChild(parentNode, newChild) {
      return nativeAppendChild.call(parentNode, newChild);
    },
    removeChild: function removeChild(parentNode, node) {
      return nativeRemoveChild.call(parentNode, node);
    }
  };
})();Polymer.DomApi = function () {
  'use strict';

  var Settings = Polymer.Settings;
  var TreeApi = Polymer.TreeApi;
  var DomApi = function DomApi(node) {
    this.node = needsToWrap ? DomApi.wrap(node) : node;
  };
  var needsToWrap = Settings.hasShadow && !Settings.nativeShadow;
  DomApi.wrap = window.wrap ? window.wrap : function (node) {
    return node;
  };
  DomApi.prototype = {
    flush: function flush() {
      Polymer.dom.flush();
    },
    deepContains: function deepContains(node) {
      if (this.node.contains(node)) {
        return true;
      }
      var n = node;
      var doc = node.ownerDocument;
      while (n && n !== doc && n !== this.node) {
        n = Polymer.dom(n).parentNode || n.host;
      }
      return n === this.node;
    },
    queryDistributedElements: function queryDistributedElements(selector) {
      var c$ = this.getEffectiveChildNodes();
      var list = [];
      for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
        if (c.nodeType === Node.ELEMENT_NODE && DomApi.matchesSelector.call(c, selector)) {
          list.push(c);
        }
      }
      return list;
    },
    getEffectiveChildNodes: function getEffectiveChildNodes() {
      var list = [];
      var c$ = this.childNodes;
      for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
        if (c.localName === CONTENT) {
          var d$ = dom(c).getDistributedNodes();
          for (var j = 0; j < d$.length; j++) {
            list.push(d$[j]);
          }
        } else {
          list.push(c);
        }
      }
      return list;
    },
    observeNodes: function observeNodes(callback) {
      if (callback) {
        if (!this.observer) {
          this.observer = this.node.localName === CONTENT ? new DomApi.DistributedNodesObserver(this) : new DomApi.EffectiveNodesObserver(this);
        }
        return this.observer.addListener(callback);
      }
    },
    unobserveNodes: function unobserveNodes(handle) {
      if (this.observer) {
        this.observer.removeListener(handle);
      }
    },
    notifyObserver: function notifyObserver() {
      if (this.observer) {
        this.observer.notify();
      }
    },
    _query: function _query(matcher, node, halter) {
      node = node || this.node;
      var list = [];
      this._queryElements(TreeApi.Logical.getChildNodes(node), matcher, halter, list);
      return list;
    },
    _queryElements: function _queryElements(elements, matcher, halter, list) {
      for (var i = 0, l = elements.length, c; i < l && (c = elements[i]); i++) {
        if (c.nodeType === Node.ELEMENT_NODE) {
          if (this._queryElement(c, matcher, halter, list)) {
            return true;
          }
        }
      }
    },
    _queryElement: function _queryElement(node, matcher, halter, list) {
      var result = matcher(node);
      if (result) {
        list.push(node);
      }
      if (halter && halter(result)) {
        return result;
      }
      this._queryElements(TreeApi.Logical.getChildNodes(node), matcher, halter, list);
    }
  };
  var CONTENT = DomApi.CONTENT = 'content';
  var dom = DomApi.factory = function (node) {
    node = node || document;
    if (!node.__domApi) {
      node.__domApi = new DomApi.ctor(node);
    }
    return node.__domApi;
  };
  DomApi.hasApi = function (node) {
    return Boolean(node.__domApi);
  };
  DomApi.ctor = DomApi;
  Polymer.dom = function (obj, patch) {
    if (obj instanceof Event) {
      return Polymer.EventApi.factory(obj);
    } else {
      return DomApi.factory(obj, patch);
    }
  };
  var p = Element.prototype;
  DomApi.matchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;
  return DomApi;
}();(function () {
  'use strict';

  var Settings = Polymer.Settings;
  var DomApi = Polymer.DomApi;
  var dom = DomApi.factory;
  var TreeApi = Polymer.TreeApi;
  var getInnerHTML = Polymer.domInnerHTML.getInnerHTML;
  var CONTENT = DomApi.CONTENT;
  if (Settings.useShadow) {
    return;
  }
  var nativeCloneNode = Element.prototype.cloneNode;
  var nativeImportNode = Document.prototype.importNode;
  Polymer.Base.mixin(DomApi.prototype, {
    _lazyDistribute: function _lazyDistribute(host) {
      if (host.shadyRoot && host.shadyRoot._distributionClean) {
        host.shadyRoot._distributionClean = false;
        Polymer.dom.addDebouncer(host.debounce('_distribute', host._distributeContent));
      }
    },
    appendChild: function appendChild(node) {
      return this.insertBefore(node);
    },
    insertBefore: function insertBefore(node, ref_node) {
      if (ref_node && TreeApi.Logical.getParentNode(ref_node) !== this.node) {
        throw Error('The ref_node to be inserted before is not a child ' + 'of this node');
      }
      if (node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
        var parent = TreeApi.Logical.getParentNode(node);
        if (parent) {
          if (DomApi.hasApi(parent)) {
            dom(parent).notifyObserver();
          }
          this._removeNode(node);
        } else {
          this._removeOwnerShadyRoot(node);
        }
      }
      if (!this._addNode(node, ref_node)) {
        if (ref_node) {
          ref_node = ref_node.localName === CONTENT ? this._firstComposedNode(ref_node) : ref_node;
        }
        var container = this.node._isShadyRoot ? this.node.host : this.node;
        if (ref_node) {
          TreeApi.Composed.insertBefore(container, node, ref_node);
        } else {
          TreeApi.Composed.appendChild(container, node);
        }
      }
      this.notifyObserver();
      return node;
    },
    _addNode: function _addNode(node, ref_node) {
      var root = this.getOwnerRoot();
      if (root) {
        var ipAdded = this._maybeAddInsertionPoint(node, this.node);
        if (!root._invalidInsertionPoints) {
          root._invalidInsertionPoints = ipAdded;
        }
        this._addNodeToHost(root.host, node);
      }
      if (TreeApi.Logical.hasChildNodes(this.node)) {
        TreeApi.Logical.recordInsertBefore(node, this.node, ref_node);
      }
      var handled = this._maybeDistribute(node) || this.node.shadyRoot;
      if (handled) {
        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          while (node.firstChild) {
            TreeApi.Composed.removeChild(node, node.firstChild);
          }
        } else {
          var parent = TreeApi.Composed.getParentNode(node);
          if (parent) {
            TreeApi.Composed.removeChild(parent, node);
          }
        }
      }
      return handled;
    },
    removeChild: function removeChild(node) {
      if (TreeApi.Logical.getParentNode(node) !== this.node) {
        throw Error('The node to be removed is not a child of this node: ' + node);
      }
      if (!this._removeNode(node)) {
        var container = this.node._isShadyRoot ? this.node.host : this.node;
        var parent = TreeApi.Composed.getParentNode(node);
        if (container === parent) {
          TreeApi.Composed.removeChild(container, node);
        }
      }
      this.notifyObserver();
      return node;
    },
    _removeNode: function _removeNode(node) {
      var logicalParent = TreeApi.Logical.hasParentNode(node) && TreeApi.Logical.getParentNode(node);
      var distributed;
      var root = this._ownerShadyRootForNode(node);
      if (logicalParent) {
        distributed = dom(node)._maybeDistributeParent();
        TreeApi.Logical.recordRemoveChild(node, logicalParent);
        if (root && this._removeDistributedChildren(root, node)) {
          root._invalidInsertionPoints = true;
          this._lazyDistribute(root.host);
        }
      }
      this._removeOwnerShadyRoot(node);
      if (root) {
        this._removeNodeFromHost(root.host, node);
      }
      return distributed;
    },
    replaceChild: function replaceChild(node, ref_node) {
      this.insertBefore(node, ref_node);
      this.removeChild(ref_node);
      return node;
    },
    _hasCachedOwnerRoot: function _hasCachedOwnerRoot(node) {
      return Boolean(node._ownerShadyRoot !== undefined);
    },
    getOwnerRoot: function getOwnerRoot() {
      return this._ownerShadyRootForNode(this.node);
    },
    _ownerShadyRootForNode: function _ownerShadyRootForNode(node) {
      if (!node) {
        return;
      }
      var root = node._ownerShadyRoot;
      if (root === undefined) {
        if (node._isShadyRoot) {
          root = node;
        } else {
          var parent = TreeApi.Logical.getParentNode(node);
          if (parent) {
            root = parent._isShadyRoot ? parent : this._ownerShadyRootForNode(parent);
          } else {
            root = null;
          }
        }
        if (root || document.documentElement.contains(node)) {
          node._ownerShadyRoot = root;
        }
      }
      return root;
    },
    _maybeDistribute: function _maybeDistribute(node) {
      var fragContent = node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent && dom(node).querySelector(CONTENT);
      var wrappedContent = fragContent && TreeApi.Logical.getParentNode(fragContent).nodeType !== Node.DOCUMENT_FRAGMENT_NODE;
      var hasContent = fragContent || node.localName === CONTENT;
      if (hasContent) {
        var root = this.getOwnerRoot();
        if (root) {
          this._lazyDistribute(root.host);
        }
      }
      var needsDist = this._nodeNeedsDistribution(this.node);
      if (needsDist) {
        this._lazyDistribute(this.node);
      }
      return needsDist || hasContent && !wrappedContent;
    },
    _maybeAddInsertionPoint: function _maybeAddInsertionPoint(node, parent) {
      var added;
      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent) {
        var c$ = dom(node).querySelectorAll(CONTENT);
        for (var i = 0, n, np, na; i < c$.length && (n = c$[i]); i++) {
          np = TreeApi.Logical.getParentNode(n);
          if (np === node) {
            np = parent;
          }
          na = this._maybeAddInsertionPoint(n, np);
          added = added || na;
        }
      } else if (node.localName === CONTENT) {
        TreeApi.Logical.saveChildNodes(parent);
        TreeApi.Logical.saveChildNodes(node);
        added = true;
      }
      return added;
    },
    _updateInsertionPoints: function _updateInsertionPoints(host) {
      var i$ = host.shadyRoot._insertionPoints = dom(host.shadyRoot).querySelectorAll(CONTENT);
      for (var i = 0, c; i < i$.length; i++) {
        c = i$[i];
        TreeApi.Logical.saveChildNodes(c);
        TreeApi.Logical.saveChildNodes(TreeApi.Logical.getParentNode(c));
      }
    },
    _nodeNeedsDistribution: function _nodeNeedsDistribution(node) {
      return node && node.shadyRoot && DomApi.hasInsertionPoint(node.shadyRoot);
    },
    _addNodeToHost: function _addNodeToHost(host, node) {
      if (host._elementAdd) {
        host._elementAdd(node);
      }
    },
    _removeNodeFromHost: function _removeNodeFromHost(host, node) {
      if (host._elementRemove) {
        host._elementRemove(node);
      }
    },
    _removeDistributedChildren: function _removeDistributedChildren(root, container) {
      var hostNeedsDist;
      var ip$ = root._insertionPoints;
      for (var i = 0; i < ip$.length; i++) {
        var content = ip$[i];
        if (this._contains(container, content)) {
          var dc$ = dom(content).getDistributedNodes();
          for (var j = 0; j < dc$.length; j++) {
            hostNeedsDist = true;
            var node = dc$[j];
            var parent = TreeApi.Composed.getParentNode(node);
            if (parent) {
              TreeApi.Composed.removeChild(parent, node);
            }
          }
        }
      }
      return hostNeedsDist;
    },
    _contains: function _contains(container, node) {
      while (node) {
        if (node == container) {
          return true;
        }
        node = TreeApi.Logical.getParentNode(node);
      }
    },
    _removeOwnerShadyRoot: function _removeOwnerShadyRoot(node) {
      if (this._hasCachedOwnerRoot(node)) {
        var c$ = TreeApi.Logical.getChildNodes(node);
        for (var i = 0, l = c$.length, n; i < l && (n = c$[i]); i++) {
          this._removeOwnerShadyRoot(n);
        }
      }
      node._ownerShadyRoot = undefined;
    },
    _firstComposedNode: function _firstComposedNode(content) {
      var n$ = dom(content).getDistributedNodes();
      for (var i = 0, l = n$.length, n, p$; i < l && (n = n$[i]); i++) {
        p$ = dom(n).getDestinationInsertionPoints();
        if (p$[p$.length - 1] === content) {
          return n;
        }
      }
    },
    querySelector: function querySelector(selector) {
      var result = this._query(function (n) {
        return DomApi.matchesSelector.call(n, selector);
      }, this.node, function (n) {
        return Boolean(n);
      })[0];
      return result || null;
    },
    querySelectorAll: function querySelectorAll(selector) {
      return this._query(function (n) {
        return DomApi.matchesSelector.call(n, selector);
      }, this.node);
    },
    getDestinationInsertionPoints: function getDestinationInsertionPoints() {
      return this.node._destinationInsertionPoints || [];
    },
    getDistributedNodes: function getDistributedNodes() {
      return this.node._distributedNodes || [];
    },
    _clear: function _clear() {
      while (this.childNodes.length) {
        this.removeChild(this.childNodes[0]);
      }
    },
    setAttribute: function setAttribute(name, value) {
      this.node.setAttribute(name, value);
      this._maybeDistributeParent();
    },
    removeAttribute: function removeAttribute(name) {
      this.node.removeAttribute(name);
      this._maybeDistributeParent();
    },
    _maybeDistributeParent: function _maybeDistributeParent() {
      if (this._nodeNeedsDistribution(this.parentNode)) {
        this._lazyDistribute(this.parentNode);
        return true;
      }
    },
    cloneNode: function cloneNode(deep) {
      var n = nativeCloneNode.call(this.node, false);
      if (deep) {
        var c$ = this.childNodes;
        var d = dom(n);
        for (var i = 0, nc; i < c$.length; i++) {
          nc = dom(c$[i]).cloneNode(true);
          d.appendChild(nc);
        }
      }
      return n;
    },
    importNode: function importNode(externalNode, deep) {
      var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
      var n = nativeImportNode.call(doc, externalNode, false);
      if (deep) {
        var c$ = TreeApi.Logical.getChildNodes(externalNode);
        var d = dom(n);
        for (var i = 0, nc; i < c$.length; i++) {
          nc = dom(doc).importNode(c$[i], true);
          d.appendChild(nc);
        }
      }
      return n;
    },
    _getComposedInnerHTML: function _getComposedInnerHTML() {
      return getInnerHTML(this.node, true);
    }
  });
  Object.defineProperties(DomApi.prototype, {
    activeElement: {
      get: function get() {
        var active = document.activeElement;
        if (!active) {
          return null;
        }
        var isShadyRoot = !!this.node._isShadyRoot;
        if (this.node !== document) {
          if (!isShadyRoot) {
            return null;
          }
          if (this.node.host === active || !this.node.host.contains(active)) {
            return null;
          }
        }
        var activeRoot = dom(active).getOwnerRoot();
        while (activeRoot && activeRoot !== this.node) {
          active = activeRoot.host;
          activeRoot = dom(active).getOwnerRoot();
        }
        if (this.node === document) {
          return activeRoot ? null : active;
        } else {
          return activeRoot === this.node ? active : null;
        }
      },
      configurable: true
    },
    childNodes: {
      get: function get() {
        var c$ = TreeApi.Logical.getChildNodes(this.node);
        return Array.isArray(c$) ? c$ : TreeApi.arrayCopyChildNodes(this.node);
      },
      configurable: true
    },
    children: {
      get: function get() {
        if (TreeApi.Logical.hasChildNodes(this.node)) {
          return Array.prototype.filter.call(this.childNodes, function (n) {
            return n.nodeType === Node.ELEMENT_NODE;
          });
        } else {
          return TreeApi.arrayCopyChildren(this.node);
        }
      },
      configurable: true
    },
    parentNode: {
      get: function get() {
        return TreeApi.Logical.getParentNode(this.node);
      },
      configurable: true
    },
    firstChild: {
      get: function get() {
        return TreeApi.Logical.getFirstChild(this.node);
      },
      configurable: true
    },
    lastChild: {
      get: function get() {
        return TreeApi.Logical.getLastChild(this.node);
      },
      configurable: true
    },
    nextSibling: {
      get: function get() {
        return TreeApi.Logical.getNextSibling(this.node);
      },
      configurable: true
    },
    previousSibling: {
      get: function get() {
        return TreeApi.Logical.getPreviousSibling(this.node);
      },
      configurable: true
    },
    firstElementChild: {
      get: function get() {
        return TreeApi.Logical.getFirstElementChild(this.node);
      },
      configurable: true
    },
    lastElementChild: {
      get: function get() {
        return TreeApi.Logical.getLastElementChild(this.node);
      },
      configurable: true
    },
    nextElementSibling: {
      get: function get() {
        return TreeApi.Logical.getNextElementSibling(this.node);
      },
      configurable: true
    },
    previousElementSibling: {
      get: function get() {
        return TreeApi.Logical.getPreviousElementSibling(this.node);
      },
      configurable: true
    },
    textContent: {
      get: function get() {
        var nt = this.node.nodeType;
        if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
          return this.node.textContent;
        } else {
          var tc = [];
          for (var i = 0, cn = this.childNodes, c; c = cn[i]; i++) {
            if (c.nodeType !== Node.COMMENT_NODE) {
              tc.push(c.textContent);
            }
          }
          return tc.join('');
        }
      },
      set: function set(text) {
        var nt = this.node.nodeType;
        if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
          this.node.textContent = text;
        } else {
          this._clear();
          if (text) {
            this.appendChild(document.createTextNode(text));
          }
        }
      },
      configurable: true
    },
    innerHTML: {
      get: function get() {
        var nt = this.node.nodeType;
        if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
          return null;
        } else {
          return getInnerHTML(this.node);
        }
      },
      set: function set(text) {
        var nt = this.node.nodeType;
        if (nt !== Node.TEXT_NODE || nt !== Node.COMMENT_NODE) {
          this._clear();
          var d = document.createElement('div');
          d.innerHTML = text;
          var c$ = TreeApi.arrayCopyChildNodes(d);
          for (var i = 0; i < c$.length; i++) {
            this.appendChild(c$[i]);
          }
        }
      },
      configurable: true
    }
  });
  DomApi.hasInsertionPoint = function (root) {
    return Boolean(root && root._insertionPoints.length);
  };
})();(function () {
  'use strict';

  var Settings = Polymer.Settings;
  var TreeApi = Polymer.TreeApi;
  var DomApi = Polymer.DomApi;
  if (!Settings.useShadow) {
    return;
  }
  Polymer.Base.mixin(DomApi.prototype, {
    querySelectorAll: function querySelectorAll(selector) {
      return TreeApi.arrayCopy(this.node.querySelectorAll(selector));
    },
    getOwnerRoot: function getOwnerRoot() {
      var n = this.node;
      while (n) {
        if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE && n.host) {
          return n;
        }
        n = n.parentNode;
      }
    },
    importNode: function importNode(externalNode, deep) {
      var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
      return doc.importNode(externalNode, deep);
    },
    getDestinationInsertionPoints: function getDestinationInsertionPoints() {
      var n$ = this.node.getDestinationInsertionPoints && this.node.getDestinationInsertionPoints();
      return n$ ? TreeApi.arrayCopy(n$) : [];
    },
    getDistributedNodes: function getDistributedNodes() {
      var n$ = this.node.getDistributedNodes && this.node.getDistributedNodes();
      return n$ ? TreeApi.arrayCopy(n$) : [];
    }
  });
  Object.defineProperties(DomApi.prototype, {
    activeElement: {
      get: function get() {
        var node = DomApi.wrap(this.node);
        var activeElement = node.activeElement;
        return node.contains(activeElement) ? activeElement : null;
      },
      configurable: true
    },
    childNodes: {
      get: function get() {
        return TreeApi.arrayCopyChildNodes(this.node);
      },
      configurable: true
    },
    children: {
      get: function get() {
        return TreeApi.arrayCopyChildren(this.node);
      },
      configurable: true
    },
    textContent: {
      get: function get() {
        return this.node.textContent;
      },
      set: function set(value) {
        return this.node.textContent = value;
      },
      configurable: true
    },
    innerHTML: {
      get: function get() {
        return this.node.innerHTML;
      },
      set: function set(value) {
        return this.node.innerHTML = value;
      },
      configurable: true
    }
  });
  var forwardMethods = function forwardMethods(m$) {
    for (var i = 0; i < m$.length; i++) {
      forwardMethod(m$[i]);
    }
  };
  var forwardMethod = function forwardMethod(method) {
    DomApi.prototype[method] = function () {
      return this.node[method].apply(this.node, arguments);
    };
  };
  forwardMethods(['cloneNode', 'appendChild', 'insertBefore', 'removeChild', 'replaceChild', 'setAttribute', 'removeAttribute', 'querySelector']);
  var forwardProperties = function forwardProperties(f$) {
    for (var i = 0; i < f$.length; i++) {
      forwardProperty(f$[i]);
    }
  };
  var forwardProperty = function forwardProperty(name) {
    Object.defineProperty(DomApi.prototype, name, {
      get: function get() {
        return this.node[name];
      },
      configurable: true
    });
  };
  forwardProperties(['parentNode', 'firstChild', 'lastChild', 'nextSibling', 'previousSibling', 'firstElementChild', 'lastElementChild', 'nextElementSibling', 'previousElementSibling']);
})();Polymer.Base.mixin(Polymer.dom, {
  _flushGuard: 0,
  _FLUSH_MAX: 100,
  _needsTakeRecords: !Polymer.Settings.useNativeCustomElements,
  _debouncers: [],
  _staticFlushList: [],
  _finishDebouncer: null,
  flush: function flush() {
    this._flushGuard = 0;
    this._prepareFlush();
    while (this._debouncers.length && this._flushGuard < this._FLUSH_MAX) {
      while (this._debouncers.length) {
        this._debouncers.shift().complete();
      }
      if (this._finishDebouncer) {
        this._finishDebouncer.complete();
      }
      this._prepareFlush();
      this._flushGuard++;
    }
    if (this._flushGuard >= this._FLUSH_MAX) {
      console.warn('Polymer.dom.flush aborted. Flush may not be complete.');
    }
  },
  _prepareFlush: function _prepareFlush() {
    if (this._needsTakeRecords) {
      CustomElements.takeRecords();
    }
    for (var i = 0; i < this._staticFlushList.length; i++) {
      this._staticFlushList[i]();
    }
  },
  addStaticFlush: function addStaticFlush(fn) {
    this._staticFlushList.push(fn);
  },
  removeStaticFlush: function removeStaticFlush(fn) {
    var i = this._staticFlushList.indexOf(fn);
    if (i >= 0) {
      this._staticFlushList.splice(i, 1);
    }
  },
  addDebouncer: function addDebouncer(debouncer) {
    this._debouncers.push(debouncer);
    this._finishDebouncer = Polymer.Debounce(this._finishDebouncer, this._finishFlush);
  },
  _finishFlush: function _finishFlush() {
    Polymer.dom._debouncers = [];
  }
});Polymer.EventApi = function () {
  'use strict';

  var DomApi = Polymer.DomApi.ctor;
  var Settings = Polymer.Settings;
  DomApi.Event = function (event) {
    this.event = event;
  };
  if (Settings.useShadow) {
    DomApi.Event.prototype = {
      get rootTarget() {
        return this.event.path[0];
      },
      get localTarget() {
        return this.event.target;
      },
      get path() {
        var path = this.event.path;
        if (!Array.isArray(path)) {
          path = Array.prototype.slice.call(path);
        }
        return path;
      }
    };
  } else {
    DomApi.Event.prototype = {
      get rootTarget() {
        return this.event.target;
      },
      get localTarget() {
        var current = this.event.currentTarget;
        var currentRoot = current && Polymer.dom(current).getOwnerRoot();
        var p$ = this.path;
        for (var i = 0; i < p$.length; i++) {
          if (Polymer.dom(p$[i]).getOwnerRoot() === currentRoot) {
            return p$[i];
          }
        }
      },
      get path() {
        if (!this.event._path) {
          var path = [];
          var current = this.rootTarget;
          while (current) {
            path.push(current);
            var insertionPoints = Polymer.dom(current).getDestinationInsertionPoints();
            if (insertionPoints.length) {
              for (var i = 0; i < insertionPoints.length - 1; i++) {
                path.push(insertionPoints[i]);
              }
              current = insertionPoints[insertionPoints.length - 1];
            } else {
              current = Polymer.dom(current).parentNode || current.host;
            }
          }
          path.push(window);
          this.event._path = path;
        }
        return this.event._path;
      }
    };
  }
  var factory = function factory(event) {
    if (!event.__eventApi) {
      event.__eventApi = new DomApi.Event(event);
    }
    return event.__eventApi;
  };
  return { factory: factory };
}();(function () {
  'use strict';

  var DomApi = Polymer.DomApi.ctor;
  var useShadow = Polymer.Settings.useShadow;
  Object.defineProperty(DomApi.prototype, 'classList', {
    get: function get() {
      if (!this._classList) {
        this._classList = new DomApi.ClassList(this);
      }
      return this._classList;
    },
    configurable: true
  });
  DomApi.ClassList = function (host) {
    this.domApi = host;
    this.node = host.node;
  };
  DomApi.ClassList.prototype = {
    add: function add() {
      this.node.classList.add.apply(this.node.classList, arguments);
      this._distributeParent();
    },
    remove: function remove() {
      this.node.classList.remove.apply(this.node.classList, arguments);
      this._distributeParent();
    },
    toggle: function toggle() {
      this.node.classList.toggle.apply(this.node.classList, arguments);
      this._distributeParent();
    },
    _distributeParent: function _distributeParent() {
      if (!useShadow) {
        this.domApi._maybeDistributeParent();
      }
    },
    contains: function contains() {
      return this.node.classList.contains.apply(this.node.classList, arguments);
    }
  };
})();(function () {
  'use strict';

  var DomApi = Polymer.DomApi.ctor;
  var Settings = Polymer.Settings;
  DomApi.EffectiveNodesObserver = function (domApi) {
    this.domApi = domApi;
    this.node = this.domApi.node;
    this._listeners = [];
  };
  DomApi.EffectiveNodesObserver.prototype = {
    addListener: function addListener(callback) {
      if (!this._isSetup) {
        this._setup();
        this._isSetup = true;
      }
      var listener = {
        fn: callback,
        _nodes: []
      };
      this._listeners.push(listener);
      this._scheduleNotify();
      return listener;
    },
    removeListener: function removeListener(handle) {
      var i = this._listeners.indexOf(handle);
      if (i >= 0) {
        this._listeners.splice(i, 1);
        handle._nodes = [];
      }
      if (!this._hasListeners()) {
        this._cleanup();
        this._isSetup = false;
      }
    },
    _setup: function _setup() {
      this._observeContentElements(this.domApi.childNodes);
    },
    _cleanup: function _cleanup() {
      this._unobserveContentElements(this.domApi.childNodes);
    },
    _hasListeners: function _hasListeners() {
      return Boolean(this._listeners.length);
    },
    _scheduleNotify: function _scheduleNotify() {
      if (this._debouncer) {
        this._debouncer.stop();
      }
      this._debouncer = Polymer.Debounce(this._debouncer, this._notify);
      this._debouncer.context = this;
      Polymer.dom.addDebouncer(this._debouncer);
    },
    notify: function notify() {
      if (this._hasListeners()) {
        this._scheduleNotify();
      }
    },
    _notify: function _notify() {
      this._beforeCallListeners();
      this._callListeners();
    },
    _beforeCallListeners: function _beforeCallListeners() {
      this._updateContentElements();
    },
    _updateContentElements: function _updateContentElements() {
      this._observeContentElements(this.domApi.childNodes);
    },
    _observeContentElements: function _observeContentElements(elements) {
      for (var i = 0, n; i < elements.length && (n = elements[i]); i++) {
        if (this._isContent(n)) {
          n.__observeNodesMap = n.__observeNodesMap || new WeakMap();
          if (!n.__observeNodesMap.has(this)) {
            n.__observeNodesMap.set(this, this._observeContent(n));
          }
        }
      }
    },
    _observeContent: function _observeContent(content) {
      var self = this;
      var h = Polymer.dom(content).observeNodes(function () {
        self._scheduleNotify();
      });
      h._avoidChangeCalculation = true;
      return h;
    },
    _unobserveContentElements: function _unobserveContentElements(elements) {
      for (var i = 0, n, h; i < elements.length && (n = elements[i]); i++) {
        if (this._isContent(n)) {
          h = n.__observeNodesMap.get(this);
          if (h) {
            Polymer.dom(n).unobserveNodes(h);
            n.__observeNodesMap.delete(this);
          }
        }
      }
    },
    _isContent: function _isContent(node) {
      return node.localName === 'content';
    },
    _callListeners: function _callListeners() {
      var o$ = this._listeners;
      var nodes = this._getEffectiveNodes();
      for (var i = 0, o; i < o$.length && (o = o$[i]); i++) {
        var info = this._generateListenerInfo(o, nodes);
        if (info || o._alwaysNotify) {
          this._callListener(o, info);
        }
      }
    },
    _getEffectiveNodes: function _getEffectiveNodes() {
      return this.domApi.getEffectiveChildNodes();
    },
    _generateListenerInfo: function _generateListenerInfo(listener, newNodes) {
      if (listener._avoidChangeCalculation) {
        return true;
      }
      var oldNodes = listener._nodes;
      var info = {
        target: this.node,
        addedNodes: [],
        removedNodes: []
      };
      var splices = Polymer.ArraySplice.calculateSplices(newNodes, oldNodes);
      for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
        for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
          info.removedNodes.push(n);
        }
      }
      for (i = 0, s; i < splices.length && (s = splices[i]); i++) {
        for (j = s.index; j < s.index + s.addedCount; j++) {
          info.addedNodes.push(newNodes[j]);
        }
      }
      listener._nodes = newNodes;
      if (info.addedNodes.length || info.removedNodes.length) {
        return info;
      }
    },
    _callListener: function _callListener(listener, info) {
      return listener.fn.call(this.node, info);
    },
    enableShadowAttributeTracking: function enableShadowAttributeTracking() {}
  };
  if (Settings.useShadow) {
    var baseSetup = DomApi.EffectiveNodesObserver.prototype._setup;
    var baseCleanup = DomApi.EffectiveNodesObserver.prototype._cleanup;
    Polymer.Base.mixin(DomApi.EffectiveNodesObserver.prototype, {
      _setup: function _setup() {
        if (!this._observer) {
          var self = this;
          this._mutationHandler = function (mxns) {
            if (mxns && mxns.length) {
              self._scheduleNotify();
            }
          };
          this._observer = new MutationObserver(this._mutationHandler);
          this._boundFlush = function () {
            self._flush();
          };
          Polymer.dom.addStaticFlush(this._boundFlush);
          this._observer.observe(this.node, { childList: true });
        }
        baseSetup.call(this);
      },
      _cleanup: function _cleanup() {
        this._observer.disconnect();
        this._observer = null;
        this._mutationHandler = null;
        Polymer.dom.removeStaticFlush(this._boundFlush);
        baseCleanup.call(this);
      },
      _flush: function _flush() {
        if (this._observer) {
          this._mutationHandler(this._observer.takeRecords());
        }
      },
      enableShadowAttributeTracking: function enableShadowAttributeTracking() {
        if (this._observer) {
          this._makeContentListenersAlwaysNotify();
          this._observer.disconnect();
          this._observer.observe(this.node, {
            childList: true,
            attributes: true,
            subtree: true
          });
          var root = this.domApi.getOwnerRoot();
          var host = root && root.host;
          if (host && Polymer.dom(host).observer) {
            Polymer.dom(host).observer.enableShadowAttributeTracking();
          }
        }
      },
      _makeContentListenersAlwaysNotify: function _makeContentListenersAlwaysNotify() {
        for (var i = 0, h; i < this._listeners.length; i++) {
          h = this._listeners[i];
          h._alwaysNotify = h._isContentListener;
        }
      }
    });
  }
})();(function () {
  'use strict';

  var DomApi = Polymer.DomApi.ctor;
  var Settings = Polymer.Settings;
  DomApi.DistributedNodesObserver = function (domApi) {
    DomApi.EffectiveNodesObserver.call(this, domApi);
  };
  DomApi.DistributedNodesObserver.prototype = Object.create(DomApi.EffectiveNodesObserver.prototype);
  Polymer.Base.mixin(DomApi.DistributedNodesObserver.prototype, {
    _setup: function _setup() {},
    _cleanup: function _cleanup() {},
    _beforeCallListeners: function _beforeCallListeners() {},
    _getEffectiveNodes: function _getEffectiveNodes() {
      return this.domApi.getDistributedNodes();
    }
  });
  if (Settings.useShadow) {
    Polymer.Base.mixin(DomApi.DistributedNodesObserver.prototype, {
      _setup: function _setup() {
        if (!this._observer) {
          var root = this.domApi.getOwnerRoot();
          var host = root && root.host;
          if (host) {
            var self = this;
            this._observer = Polymer.dom(host).observeNodes(function () {
              self._scheduleNotify();
            });
            this._observer._isContentListener = true;
            if (this._hasAttrSelect()) {
              Polymer.dom(host).observer.enableShadowAttributeTracking();
            }
          }
        }
      },
      _hasAttrSelect: function _hasAttrSelect() {
        var select = this.node.getAttribute('select');
        return select && select.match(/[[.]+/);
      },
      _cleanup: function _cleanup() {
        var root = this.domApi.getOwnerRoot();
        var host = root && root.host;
        if (host) {
          Polymer.dom(host).unobserveNodes(this._observer);
        }
        this._observer = null;
      }
    });
  }
})();(function () {
  var DomApi = Polymer.DomApi;
  var TreeApi = Polymer.TreeApi;
  Polymer.Base._addFeature({
    _prepShady: function _prepShady() {
      this._useContent = this._useContent || Boolean(this._template);
    },
    _setupShady: function _setupShady() {
      this.shadyRoot = null;
      if (!this.__domApi) {
        this.__domApi = null;
      }
      if (!this.__dom) {
        this.__dom = null;
      }
      if (!this._ownerShadyRoot) {
        this._ownerShadyRoot = undefined;
      }
    },
    _poolContent: function _poolContent() {
      if (this._useContent) {
        TreeApi.Logical.saveChildNodes(this);
      }
    },
    _setupRoot: function _setupRoot() {
      if (this._useContent) {
        this._createLocalRoot();
        if (!this.dataHost) {
          upgradeLogicalChildren(TreeApi.Logical.getChildNodes(this));
        }
      }
    },
    _createLocalRoot: function _createLocalRoot() {
      this.shadyRoot = this.root;
      this.shadyRoot._distributionClean = false;
      this.shadyRoot._hasDistributed = false;
      this.shadyRoot._isShadyRoot = true;
      this.shadyRoot._dirtyRoots = [];
      var i$ = this.shadyRoot._insertionPoints = !this._notes || this._notes._hasContent ? this.shadyRoot.querySelectorAll('content') : [];
      TreeApi.Logical.saveChildNodes(this.shadyRoot);
      for (var i = 0, c; i < i$.length; i++) {
        c = i$[i];
        TreeApi.Logical.saveChildNodes(c);
        TreeApi.Logical.saveChildNodes(c.parentNode);
      }
      this.shadyRoot.host = this;
    },
    distributeContent: function distributeContent(updateInsertionPoints) {
      if (this.shadyRoot) {
        this.shadyRoot._invalidInsertionPoints = this.shadyRoot._invalidInsertionPoints || updateInsertionPoints;
        var host = getTopDistributingHost(this);
        Polymer.dom(this)._lazyDistribute(host);
      }
    },
    _distributeContent: function _distributeContent() {
      if (this._useContent && !this.shadyRoot._distributionClean) {
        if (this.shadyRoot._invalidInsertionPoints) {
          Polymer.dom(this)._updateInsertionPoints(this);
          this.shadyRoot._invalidInsertionPoints = false;
        }
        this._beginDistribute();
        this._distributeDirtyRoots();
        this._finishDistribute();
      }
    },
    _beginDistribute: function _beginDistribute() {
      if (this._useContent && DomApi.hasInsertionPoint(this.shadyRoot)) {
        this._resetDistribution();
        this._distributePool(this.shadyRoot, this._collectPool());
      }
    },
    _distributeDirtyRoots: function _distributeDirtyRoots() {
      var c$ = this.shadyRoot._dirtyRoots;
      for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
        c._distributeContent();
      }
      this.shadyRoot._dirtyRoots = [];
    },
    _finishDistribute: function _finishDistribute() {
      if (this._useContent) {
        this.shadyRoot._distributionClean = true;
        if (DomApi.hasInsertionPoint(this.shadyRoot)) {
          this._composeTree();
          notifyContentObservers(this.shadyRoot);
        } else {
          if (!this.shadyRoot._hasDistributed) {
            TreeApi.Composed.clearChildNodes(this);
            this.appendChild(this.shadyRoot);
          } else {
            var children = this._composeNode(this);
            this._updateChildNodes(this, children);
          }
        }
        if (!this.shadyRoot._hasDistributed) {
          notifyInitialDistribution(this);
        }
        this.shadyRoot._hasDistributed = true;
      }
    },
    elementMatches: function elementMatches(selector, node) {
      node = node || this;
      return DomApi.matchesSelector.call(node, selector);
    },
    _resetDistribution: function _resetDistribution() {
      var children = TreeApi.Logical.getChildNodes(this);
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        if (child._destinationInsertionPoints) {
          child._destinationInsertionPoints = undefined;
        }
        if (isInsertionPoint(child)) {
          clearDistributedDestinationInsertionPoints(child);
        }
      }
      var root = this.shadyRoot;
      var p$ = root._insertionPoints;
      for (var j = 0; j < p$.length; j++) {
        p$[j]._distributedNodes = [];
      }
    },
    _collectPool: function _collectPool() {
      var pool = [];
      var children = TreeApi.Logical.getChildNodes(this);
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        if (isInsertionPoint(child)) {
          pool.push.apply(pool, child._distributedNodes);
        } else {
          pool.push(child);
        }
      }
      return pool;
    },
    _distributePool: function _distributePool(node, pool) {
      var p$ = node._insertionPoints;
      for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
        this._distributeInsertionPoint(p, pool);
        maybeRedistributeParent(p, this);
      }
    },
    _distributeInsertionPoint: function _distributeInsertionPoint(content, pool) {
      var anyDistributed = false;
      for (var i = 0, l = pool.length, node; i < l; i++) {
        node = pool[i];
        if (!node) {
          continue;
        }
        if (this._matchesContentSelect(node, content)) {
          distributeNodeInto(node, content);
          pool[i] = undefined;
          anyDistributed = true;
        }
      }
      if (!anyDistributed) {
        var children = TreeApi.Logical.getChildNodes(content);
        for (var j = 0; j < children.length; j++) {
          distributeNodeInto(children[j], content);
        }
      }
    },
    _composeTree: function _composeTree() {
      this._updateChildNodes(this, this._composeNode(this));
      var p$ = this.shadyRoot._insertionPoints;
      for (var i = 0, l = p$.length, p, parent; i < l && (p = p$[i]); i++) {
        parent = TreeApi.Logical.getParentNode(p);
        if (!parent._useContent && parent !== this && parent !== this.shadyRoot) {
          this._updateChildNodes(parent, this._composeNode(parent));
        }
      }
    },
    _composeNode: function _composeNode(node) {
      var children = [];
      var c$ = TreeApi.Logical.getChildNodes(node.shadyRoot || node);
      for (var i = 0; i < c$.length; i++) {
        var child = c$[i];
        if (isInsertionPoint(child)) {
          var distributedNodes = child._distributedNodes;
          for (var j = 0; j < distributedNodes.length; j++) {
            var distributedNode = distributedNodes[j];
            if (isFinalDestination(child, distributedNode)) {
              children.push(distributedNode);
            }
          }
        } else {
          children.push(child);
        }
      }
      return children;
    },
    _updateChildNodes: function _updateChildNodes(container, children) {
      var composed = TreeApi.Composed.getChildNodes(container);
      var splices = Polymer.ArraySplice.calculateSplices(children, composed);
      for (var i = 0, d = 0, s; i < splices.length && (s = splices[i]); i++) {
        for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
          if (TreeApi.Composed.getParentNode(n) === container) {
            TreeApi.Composed.removeChild(container, n);
          }
          composed.splice(s.index + d, 1);
        }
        d -= s.addedCount;
      }
      for (var i = 0, s, next; i < splices.length && (s = splices[i]); i++) {
        next = composed[s.index];
        for (j = s.index, n; j < s.index + s.addedCount; j++) {
          n = children[j];
          TreeApi.Composed.insertBefore(container, n, next);
          composed.splice(j, 0, n);
        }
      }
    },
    _matchesContentSelect: function _matchesContentSelect(node, contentElement) {
      var select = contentElement.getAttribute('select');
      if (!select) {
        return true;
      }
      select = select.trim();
      if (!select) {
        return true;
      }
      if (!(node instanceof Element)) {
        return false;
      }
      var validSelectors = /^(:not\()?[*.#[a-zA-Z_|]/;
      if (!validSelectors.test(select)) {
        return false;
      }
      return this.elementMatches(select, node);
    },
    _elementAdd: function _elementAdd() {},
    _elementRemove: function _elementRemove() {}
  });
  var domHostDesc = {
    get: function get() {
      var root = Polymer.dom(this).getOwnerRoot();
      return root && root.host;
    },
    configurable: true
  };
  Object.defineProperty(Polymer.Base, 'domHost', domHostDesc);
  Polymer.BaseDescriptors.domHost = domHostDesc;
  function distributeNodeInto(child, insertionPoint) {
    insertionPoint._distributedNodes.push(child);
    var points = child._destinationInsertionPoints;
    if (!points) {
      child._destinationInsertionPoints = [insertionPoint];
    } else {
      points.push(insertionPoint);
    }
  }
  function clearDistributedDestinationInsertionPoints(content) {
    var e$ = content._distributedNodes;
    if (e$) {
      for (var i = 0; i < e$.length; i++) {
        var d = e$[i]._destinationInsertionPoints;
        if (d) {
          d.splice(d.indexOf(content) + 1, d.length);
        }
      }
    }
  }
  function maybeRedistributeParent(content, host) {
    var parent = TreeApi.Logical.getParentNode(content);
    if (parent && parent.shadyRoot && DomApi.hasInsertionPoint(parent.shadyRoot) && parent.shadyRoot._distributionClean) {
      parent.shadyRoot._distributionClean = false;
      host.shadyRoot._dirtyRoots.push(parent);
    }
  }
  function isFinalDestination(insertionPoint, node) {
    var points = node._destinationInsertionPoints;
    return points && points[points.length - 1] === insertionPoint;
  }
  function isInsertionPoint(node) {
    return node.localName == 'content';
  }
  function getTopDistributingHost(host) {
    while (host && hostNeedsRedistribution(host)) {
      host = host.domHost;
    }
    return host;
  }
  function hostNeedsRedistribution(host) {
    var c$ = TreeApi.Logical.getChildNodes(host);
    for (var i = 0, c; i < c$.length; i++) {
      c = c$[i];
      if (c.localName && c.localName === 'content') {
        return host.domHost;
      }
    }
  }
  function notifyContentObservers(root) {
    for (var i = 0, c; i < root._insertionPoints.length; i++) {
      c = root._insertionPoints[i];
      if (DomApi.hasApi(c)) {
        Polymer.dom(c).notifyObserver();
      }
    }
  }
  function notifyInitialDistribution(host) {
    if (DomApi.hasApi(host)) {
      Polymer.dom(host).notifyObserver();
    }
  }
  var needsUpgrade = window.CustomElements && !CustomElements.useNative;
  function upgradeLogicalChildren(children) {
    if (needsUpgrade && children) {
      for (var i = 0; i < children.length; i++) {
        CustomElements.upgrade(children[i]);
      }
    }
  }
})();if (Polymer.Settings.useShadow) {
  Polymer.Base._addFeature({
    _poolContent: function _poolContent() {},
    _beginDistribute: function _beginDistribute() {},
    distributeContent: function distributeContent() {},
    _distributeContent: function _distributeContent() {},
    _finishDistribute: function _finishDistribute() {},
    _createLocalRoot: function _createLocalRoot() {
      this.createShadowRoot();
      this.shadowRoot.appendChild(this.root);
      this.root = this.shadowRoot;
    }
  });
}Polymer.Async = {
  _currVal: 0,
  _lastVal: 0,
  _callbacks: [],
  _twiddleContent: 0,
  _twiddle: document.createTextNode(''),
  run: function run(callback, waitTime) {
    if (waitTime > 0) {
      return ~setTimeout(callback, waitTime);
    } else {
      this._twiddle.textContent = this._twiddleContent++;
      this._callbacks.push(callback);
      return this._currVal++;
    }
  },
  cancel: function cancel(handle) {
    if (handle < 0) {
      clearTimeout(~handle);
    } else {
      var idx = handle - this._lastVal;
      if (idx >= 0) {
        if (!this._callbacks[idx]) {
          throw 'invalid async handle: ' + handle;
        }
        this._callbacks[idx] = null;
      }
    }
  },
  _atEndOfMicrotask: function _atEndOfMicrotask() {
    var len = this._callbacks.length;
    for (var i = 0; i < len; i++) {
      var cb = this._callbacks[i];
      if (cb) {
        try {
          cb();
        } catch (e) {
          i++;
          this._callbacks.splice(0, i);
          this._lastVal += i;
          this._twiddle.textContent = this._twiddleContent++;
          throw e;
        }
      }
    }
    this._callbacks.splice(0, len);
    this._lastVal += len;
  }
};
new window.MutationObserver(function () {
  Polymer.Async._atEndOfMicrotask();
}).observe(Polymer.Async._twiddle, { characterData: true });Polymer.Debounce = function () {
  var Async = Polymer.Async;
  var Debouncer = function Debouncer(context) {
    this.context = context;
    var self = this;
    this.boundComplete = function () {
      self.complete();
    };
  };
  Debouncer.prototype = {
    go: function go(callback, wait) {
      var h;
      this.finish = function () {
        Async.cancel(h);
      };
      h = Async.run(this.boundComplete, wait);
      this.callback = callback;
    },
    stop: function stop() {
      if (this.finish) {
        this.finish();
        this.finish = null;
        this.callback = null;
      }
    },
    complete: function complete() {
      if (this.finish) {
        var callback = this.callback;
        this.stop();
        callback.call(this.context);
      }
    }
  };
  function debounce(debouncer, callback, wait) {
    if (debouncer) {
      debouncer.stop();
    } else {
      debouncer = new Debouncer(this);
    }
    debouncer.go(callback, wait);
    return debouncer;
  }
  return debounce;
}();Polymer.Base._addFeature({
  _setupDebouncers: function _setupDebouncers() {
    this._debouncers = {};
  },
  debounce: function debounce(jobName, callback, wait) {
    return this._debouncers[jobName] = Polymer.Debounce.call(this, this._debouncers[jobName], callback, wait);
  },
  isDebouncerActive: function isDebouncerActive(jobName) {
    var debouncer = this._debouncers[jobName];
    return !!(debouncer && debouncer.finish);
  },
  flushDebouncer: function flushDebouncer(jobName) {
    var debouncer = this._debouncers[jobName];
    if (debouncer) {
      debouncer.complete();
    }
  },
  cancelDebouncer: function cancelDebouncer(jobName) {
    var debouncer = this._debouncers[jobName];
    if (debouncer) {
      debouncer.stop();
    }
  }
});Polymer.DomModule = document.createElement('dom-module');
Polymer.Base._addFeature({
  _registerFeatures: function _registerFeatures() {
    this._prepIs();
    this._prepBehaviors();
    this._prepConstructor();
    this._prepTemplate();
    this._prepShady();
    this._prepPropertyInfo();
  },
  _prepBehavior: function _prepBehavior(b) {
    this._addHostAttributes(b.hostAttributes);
  },
  _initFeatures: function _initFeatures() {
    this._registerHost();
    if (this._template) {
      this._poolContent();
      this._beginHosting();
      this._stampTemplate();
      this._endHosting();
    }
    this._marshalHostAttributes();
    this._setupDebouncers();
    this._marshalBehaviors();
    this._tryReady();
  },
  _marshalBehavior: function _marshalBehavior(b) {}
});</script><script>var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function () {
  Polymer.nar = [];
  var disableUpgradeEnabled = Polymer.Settings.disableUpgradeEnabled;
  Polymer.Annotations = {
    parseAnnotations: function parseAnnotations(template, stripWhiteSpace) {
      var list = [];
      var content = template._content || template.content;
      this._parseNodeAnnotations(content, list, stripWhiteSpace || template.hasAttribute('strip-whitespace'));
      return list;
    },
    _parseNodeAnnotations: function _parseNodeAnnotations(node, list, stripWhiteSpace) {
      return node.nodeType === Node.TEXT_NODE ? this._parseTextNodeAnnotation(node, list) : this._parseElementAnnotations(node, list, stripWhiteSpace);
    },
    _bindingRegex: function () {
      var IDENT = '(?:' + '[a-zA-Z_$][\\w.:$\\-*]*' + ')';
      var NUMBER = '(?:' + '[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';
      var SQUOTE_STRING = '(?:' + '\'(?:[^\'\\\\]|\\\\.)*\'' + ')';
      var DQUOTE_STRING = '(?:' + '"(?:[^"\\\\]|\\\\.)*"' + ')';
      var STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';
      var ARGUMENT = '(?:' + IDENT + '|' + NUMBER + '|' + STRING + '\\s*' + ')';
      var ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\s*' + ARGUMENT + ')*' + ')';
      var ARGUMENT_LIST = '(?:' + '\\(\\s*' + '(?:' + ARGUMENTS + '?' + ')' + '\\)\\s*' + ')';
      var BINDING = '(' + IDENT + '\\s*' + ARGUMENT_LIST + '?' + ')';
      var OPEN_BRACKET = '(\\[\\[|{{)' + '\\s*';
      var CLOSE_BRACKET = '(?:]]|}})';
      var NEGATE = '(?:(!)\\s*)?';
      var EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
      return new RegExp(EXPRESSION, 'g');
    }(),
    _parseBindings: function _parseBindings(text) {
      var re = this._bindingRegex;
      var parts = [];
      var lastIndex = 0;
      var m;
      while ((m = re.exec(text)) !== null) {
        if (m.index > lastIndex) {
          parts.push({ literal: text.slice(lastIndex, m.index) });
        }
        var mode = m[1][0];
        var negate = Boolean(m[2]);
        var value = m[3].trim();
        var customEvent, notifyEvent, colon;
        if (mode == '{' && (colon = value.indexOf('::')) > 0) {
          notifyEvent = value.substring(colon + 2);
          value = value.substring(0, colon);
          customEvent = true;
        }
        parts.push({
          compoundIndex: parts.length,
          value: value,
          mode: mode,
          negate: negate,
          event: notifyEvent,
          customEvent: customEvent
        });
        lastIndex = re.lastIndex;
      }
      if (lastIndex && lastIndex < text.length) {
        var literal = text.substring(lastIndex);
        if (literal) {
          parts.push({ literal: literal });
        }
      }
      if (parts.length) {
        return parts;
      }
    },
    _literalFromParts: function _literalFromParts(parts) {
      var s = '';
      for (var i = 0; i < parts.length; i++) {
        var literal = parts[i].literal;
        s += literal || '';
      }
      return s;
    },
    _parseTextNodeAnnotation: function _parseTextNodeAnnotation(node, list) {
      var parts = this._parseBindings(node.textContent);
      if (parts) {
        node.textContent = this._literalFromParts(parts) || ' ';
        var annote = {
          bindings: [{
            kind: 'text',
            name: 'textContent',
            parts: parts,
            isCompound: parts.length !== 1
          }]
        };
        list.push(annote);
        return annote;
      }
    },
    _parseElementAnnotations: function _parseElementAnnotations(element, list, stripWhiteSpace) {
      var annote = {
        bindings: [],
        events: []
      };
      if (element.localName === 'content') {
        list._hasContent = true;
      }
      this._parseChildNodesAnnotations(element, annote, list, stripWhiteSpace);
      if (element.attributes) {
        this._parseNodeAttributeAnnotations(element, annote, list);
        if (this.prepElement) {
          this.prepElement(element);
        }
      }
      if (annote.bindings.length || annote.events.length || annote.id) {
        list.push(annote);
      }
      return annote;
    },
    _parseChildNodesAnnotations: function _parseChildNodesAnnotations(root, annote, list, stripWhiteSpace) {
      if (root.firstChild) {
        var node = root.firstChild;
        var i = 0;
        while (node) {
          var next = node.nextSibling;
          if (node.localName === 'template' && !node.hasAttribute('preserve-content')) {
            this._parseTemplate(node, i, list, annote, stripWhiteSpace);
          }
          if (node.localName == 'slot') {
            node = this._replaceSlotWithContent(node);
          }
          if (node.nodeType === Node.TEXT_NODE) {
            var n = next;
            while (n && n.nodeType === Node.TEXT_NODE) {
              node.textContent += n.textContent;
              next = n.nextSibling;
              root.removeChild(n);
              n = next;
            }
            if (stripWhiteSpace && !node.textContent.trim()) {
              root.removeChild(node);
              i--;
            }
          }
          if (node.parentNode) {
            var childAnnotation = this._parseNodeAnnotations(node, list, stripWhiteSpace);
            if (childAnnotation) {
              childAnnotation.parent = annote;
              childAnnotation.index = i;
            }
          }
          node = next;
          i++;
        }
      }
    },
    _replaceSlotWithContent: function _replaceSlotWithContent(slot) {
      var content = slot.ownerDocument.createElement('content');
      while (slot.firstChild) {
        content.appendChild(slot.firstChild);
      }
      var attrs = slot.attributes;
      for (var i = 0; i < attrs.length; i++) {
        var attr = attrs[i];
        content.setAttribute(attr.name, attr.value);
      }
      var name = slot.getAttribute('name');
      if (name) {
        content.setAttribute('select', '[slot=\'' + name + '\']');
      }
      slot.parentNode.replaceChild(content, slot);
      return content;
    },
    _parseTemplate: function _parseTemplate(node, index, list, parent, stripWhiteSpace) {
      var content = document.createDocumentFragment();
      content._notes = this.parseAnnotations(node, stripWhiteSpace);
      content.appendChild(node.content);
      list.push({
        bindings: Polymer.nar,
        events: Polymer.nar,
        templateContent: content,
        parent: parent,
        index: index
      });
    },
    _parseNodeAttributeAnnotations: function _parseNodeAttributeAnnotations(node, annotation) {
      var attrs = Array.prototype.slice.call(node.attributes);
      for (var i = attrs.length - 1, a; a = attrs[i]; i--) {
        var n = a.name;
        var v = a.value;
        var b;
        if (n.slice(0, 3) === 'on-') {
          node.removeAttribute(n);
          annotation.events.push({
            name: n.slice(3),
            value: v
          });
        } else if (b = this._parseNodeAttributeAnnotation(node, n, v)) {
          annotation.bindings.push(b);
        } else if (n === 'id') {
          annotation.id = v;
        }
      }
    },
    _parseNodeAttributeAnnotation: function _parseNodeAttributeAnnotation(node, name, value) {
      var parts = this._parseBindings(value);
      if (parts) {
        var origName = name;
        var kind = 'property';
        if (name[name.length - 1] == '$') {
          name = name.slice(0, -1);
          kind = 'attribute';
        }
        var literal = this._literalFromParts(parts);
        if (literal && kind == 'attribute') {
          node.setAttribute(name, literal);
        }
        if (node.localName === 'input' && origName === 'value') {
          node.setAttribute(origName, '');
        }
        if (disableUpgradeEnabled && origName === 'disable-upgrade$') {
          node.setAttribute(name, '');
        }
        node.removeAttribute(origName);
        var propertyName = Polymer.CaseMap.dashToCamelCase(name);
        if (kind === 'property') {
          name = propertyName;
        }
        return {
          kind: kind,
          name: name,
          propertyName: propertyName,
          parts: parts,
          literal: literal,
          isCompound: parts.length !== 1
        };
      }
    },
    findAnnotatedNode: function findAnnotatedNode(root, annote) {
      var parent = annote.parent && Polymer.Annotations.findAnnotatedNode(root, annote.parent);
      if (parent) {
        for (var n = parent.firstChild, i = 0; n; n = n.nextSibling) {
          if (annote.index === i++) {
            return n;
          }
        }
      } else {
        return root;
      }
    }
  };
})();Polymer.Path = {
  root: function root(path) {
    var dotIndex = path.indexOf('.');
    if (dotIndex === -1) {
      return path;
    }
    return path.slice(0, dotIndex);
  },
  isDeep: function isDeep(path) {
    return path.indexOf('.') !== -1;
  },
  isAncestor: function isAncestor(base, path) {
    return base.indexOf(path + '.') === 0;
  },
  isDescendant: function isDescendant(base, path) {
    return path.indexOf(base + '.') === 0;
  },
  translate: function translate(base, newBase, path) {
    return newBase + path.slice(base.length);
  },
  matches: function matches(base, wildcard, path) {
    return base === path || this.isAncestor(base, path) || Boolean(wildcard) && this.isDescendant(base, path);
  }
};Polymer.Base._addFeature({
  _prepAnnotations: function _prepAnnotations() {
    if (!this._template) {
      this._notes = [];
    } else {
      var self = this;
      Polymer.Annotations.prepElement = function (element) {
        self._prepElement(element);
      };
      if (this._template._content && this._template._content._notes) {
        this._notes = this._template._content._notes;
      } else {
        this._notes = Polymer.Annotations.parseAnnotations(this._template);
        this._processAnnotations(this._notes);
      }
      Polymer.Annotations.prepElement = null;
    }
  },
  _processAnnotations: function _processAnnotations(notes) {
    for (var i = 0; i < notes.length; i++) {
      var note = notes[i];
      for (var j = 0; j < note.bindings.length; j++) {
        var b = note.bindings[j];
        for (var k = 0; k < b.parts.length; k++) {
          var p = b.parts[k];
          if (!p.literal) {
            var signature = this._parseMethod(p.value);
            if (signature) {
              p.signature = signature;
            } else {
              p.model = Polymer.Path.root(p.value);
            }
          }
        }
      }
      if (note.templateContent) {
        this._processAnnotations(note.templateContent._notes);
        var pp = note.templateContent._parentProps = this._discoverTemplateParentProps(note.templateContent._notes);
        var bindings = [];
        for (var prop in pp) {
          var name = '_parent_' + prop;
          bindings.push({
            index: note.index,
            kind: 'property',
            name: name,
            propertyName: name,
            parts: [{
              mode: '{',
              model: prop,
              value: prop
            }]
          });
        }
        note.bindings = note.bindings.concat(bindings);
      }
    }
  },
  _discoverTemplateParentProps: function _discoverTemplateParentProps(notes) {
    var pp = {};
    for (var i = 0, n; i < notes.length && (n = notes[i]); i++) {
      for (var j = 0, b$ = n.bindings, b; j < b$.length && (b = b$[j]); j++) {
        for (var k = 0, p$ = b.parts, p; k < p$.length && (p = p$[k]); k++) {
          if (p.signature) {
            var args = p.signature.args;
            for (var kk = 0; kk < args.length; kk++) {
              var model = args[kk].model;
              if (model) {
                pp[model] = true;
              }
            }
            if (p.signature.dynamicFn) {
              pp[p.signature.method] = true;
            }
          } else {
            if (p.model) {
              pp[p.model] = true;
            }
          }
        }
      }
      if (n.templateContent) {
        var tpp = n.templateContent._parentProps;
        Polymer.Base.mixin(pp, tpp);
      }
    }
    return pp;
  },
  _prepElement: function _prepElement(element) {
    Polymer.ResolveUrl.resolveAttrs(element, this._template.ownerDocument);
  },
  _findAnnotatedNode: Polymer.Annotations.findAnnotatedNode,
  _marshalAnnotationReferences: function _marshalAnnotationReferences() {
    if (this._template) {
      this._marshalIdNodes();
      this._marshalAnnotatedNodes();
      this._marshalAnnotatedListeners();
    }
  },
  _configureAnnotationReferences: function _configureAnnotationReferences() {
    var notes = this._notes;
    var nodes = this._nodes;
    for (var i = 0; i < notes.length; i++) {
      var note = notes[i];
      var node = nodes[i];
      this._configureTemplateContent(note, node);
      this._configureCompoundBindings(note, node);
    }
  },
  _configureTemplateContent: function _configureTemplateContent(note, node) {
    if (note.templateContent) {
      node._content = note.templateContent;
    }
  },
  _configureCompoundBindings: function _configureCompoundBindings(note, node) {
    var bindings = note.bindings;
    for (var i = 0; i < bindings.length; i++) {
      var binding = bindings[i];
      if (binding.isCompound) {
        var storage = node.__compoundStorage__ || (node.__compoundStorage__ = {});
        var parts = binding.parts;
        var literals = new Array(parts.length);
        for (var j = 0; j < parts.length; j++) {
          literals[j] = parts[j].literal;
        }
        var name = binding.name;
        storage[name] = literals;
        if (binding.literal && binding.kind == 'property') {
          if (node._configValue) {
            node._configValue(name, binding.literal);
          } else {
            node[name] = binding.literal;
          }
        }
      }
    }
  },
  _marshalIdNodes: function _marshalIdNodes() {
    this.$ = {};
    for (var i = 0, l = this._notes.length, a; i < l && (a = this._notes[i]); i++) {
      if (a.id) {
        this.$[a.id] = this._findAnnotatedNode(this.root, a);
      }
    }
  },
  _marshalAnnotatedNodes: function _marshalAnnotatedNodes() {
    if (this._notes && this._notes.length) {
      var r = new Array(this._notes.length);
      for (var i = 0; i < this._notes.length; i++) {
        r[i] = this._findAnnotatedNode(this.root, this._notes[i]);
      }
      this._nodes = r;
    }
  },
  _marshalAnnotatedListeners: function _marshalAnnotatedListeners() {
    for (var i = 0, l = this._notes.length, a; i < l && (a = this._notes[i]); i++) {
      if (a.events && a.events.length) {
        var node = this._findAnnotatedNode(this.root, a);
        for (var j = 0, e$ = a.events, e; j < e$.length && (e = e$[j]); j++) {
          this.listen(node, e.name, e.value);
        }
      }
    }
  }
});Polymer.Base._addFeature({
  listeners: {},
  _listenListeners: function _listenListeners(listeners) {
    var node, name, eventName;
    for (eventName in listeners) {
      if (eventName.indexOf('.') < 0) {
        node = this;
        name = eventName;
      } else {
        name = eventName.split('.');
        node = this.$[name[0]];
        name = name[1];
      }
      this.listen(node, name, listeners[eventName]);
    }
  },
  listen: function listen(node, eventName, methodName) {
    var handler = this._recallEventHandler(this, eventName, node, methodName);
    if (!handler) {
      handler = this._createEventHandler(node, eventName, methodName);
    }
    if (handler._listening) {
      return;
    }
    this._listen(node, eventName, handler);
    handler._listening = true;
  },
  _boundListenerKey: function _boundListenerKey(eventName, methodName) {
    return eventName + ':' + methodName;
  },
  _recordEventHandler: function _recordEventHandler(host, eventName, target, methodName, handler) {
    var hbl = host.__boundListeners;
    if (!hbl) {
      hbl = host.__boundListeners = new WeakMap();
    }
    var bl = hbl.get(target);
    if (!bl) {
      bl = {};
      if (!Polymer.Settings.isIE || target != window) {
        hbl.set(target, bl);
      }
    }
    var key = this._boundListenerKey(eventName, methodName);
    bl[key] = handler;
  },
  _recallEventHandler: function _recallEventHandler(host, eventName, target, methodName) {
    var hbl = host.__boundListeners;
    if (!hbl) {
      return;
    }
    var bl = hbl.get(target);
    if (!bl) {
      return;
    }
    var key = this._boundListenerKey(eventName, methodName);
    return bl[key];
  },
  _createEventHandler: function _createEventHandler(node, eventName, methodName) {
    var host = this;
    var handler = function handler(e) {
      if (host[methodName]) {
        host[methodName](e, e.detail);
      } else {
        host._warn(host._logf('_createEventHandler', 'listener method `' + methodName + '` not defined'));
      }
    };
    handler._listening = false;
    this._recordEventHandler(host, eventName, node, methodName, handler);
    return handler;
  },
  unlisten: function unlisten(node, eventName, methodName) {
    var handler = this._recallEventHandler(this, eventName, node, methodName);
    if (handler) {
      this._unlisten(node, eventName, handler);
      handler._listening = false;
    }
  },
  _listen: function _listen(node, eventName, handler) {
    node.addEventListener(eventName, handler);
  },
  _unlisten: function _unlisten(node, eventName, handler) {
    node.removeEventListener(eventName, handler);
  }
});(function () {
  'use strict';

  var wrap = Polymer.DomApi.wrap;
  var HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';
  var GESTURE_KEY = '__polymerGestures';
  var HANDLED_OBJ = '__polymerGesturesHandled';
  var TOUCH_ACTION = '__polymerGesturesTouchAction';
  var TAP_DISTANCE = 25;
  var TRACK_DISTANCE = 5;
  var TRACK_LENGTH = 2;
  var MOUSE_TIMEOUT = 2500;
  var MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'click'];
  var MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];
  var MOUSE_HAS_BUTTONS = function () {
    try {
      return new MouseEvent('test', { buttons: 1 }).buttons === 1;
    } catch (e) {
      return false;
    }
  }();
  var SUPPORTS_PASSIVE = false;
  (function () {
    try {
      var opts = Object.defineProperty({}, 'passive', {
        get: function get() {
          SUPPORTS_PASSIVE = true;
        }
      });
      window.addEventListener('test', null, opts);
      window.removeEventListener('test', null, opts);
    } catch (e) {}
  })();
  var IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);
  var mouseCanceller = function mouseCanceller(mouseEvent) {
    var sc = mouseEvent.sourceCapabilities;
    if (sc && !sc.firesTouchEvents) {
      return;
    }
    mouseEvent[HANDLED_OBJ] = { skip: true };
    if (mouseEvent.type === 'click') {
      var path = Polymer.dom(mouseEvent).path;
      for (var i = 0; i < path.length; i++) {
        if (path[i] === POINTERSTATE.mouse.target) {
          return;
        }
      }
      mouseEvent.preventDefault();
      mouseEvent.stopPropagation();
    }
  };
  function setupTeardownMouseCanceller(setup) {
    var events = IS_TOUCH_ONLY ? ['click'] : MOUSE_EVENTS;
    for (var i = 0, en; i < events.length; i++) {
      en = events[i];
      if (setup) {
        document.addEventListener(en, mouseCanceller, true);
      } else {
        document.removeEventListener(en, mouseCanceller, true);
      }
    }
  }
  function ignoreMouse(ev) {
    if (!POINTERSTATE.mouse.mouseIgnoreJob) {
      setupTeardownMouseCanceller(true);
    }
    var unset = function unset() {
      setupTeardownMouseCanceller();
      POINTERSTATE.mouse.target = null;
      POINTERSTATE.mouse.mouseIgnoreJob = null;
    };
    POINTERSTATE.mouse.target = Polymer.dom(ev).rootTarget;
    POINTERSTATE.mouse.mouseIgnoreJob = Polymer.Debounce(POINTERSTATE.mouse.mouseIgnoreJob, unset, MOUSE_TIMEOUT);
  }
  function hasLeftMouseButton(ev) {
    var type = ev.type;
    if (MOUSE_EVENTS.indexOf(type) === -1) {
      return false;
    }
    if (type === 'mousemove') {
      var buttons = ev.buttons === undefined ? 1 : ev.buttons;
      if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {
        buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
      }
      return Boolean(buttons & 1);
    } else {
      var button = ev.button === undefined ? 0 : ev.button;
      return button === 0;
    }
  }
  function isSyntheticClick(ev) {
    if (ev.type === 'click') {
      if (ev.detail === 0) {
        return true;
      }
      var t = Gestures.findOriginalTarget(ev);
      var bcr = t.getBoundingClientRect();
      var x = ev.pageX,
          y = ev.pageY;
      return !(x >= bcr.left && x <= bcr.right && y >= bcr.top && y <= bcr.bottom);
    }
    return false;
  }
  var POINTERSTATE = {
    mouse: {
      target: null,
      mouseIgnoreJob: null
    },
    touch: {
      x: 0,
      y: 0,
      id: -1,
      scrollDecided: false
    }
  };
  function firstTouchAction(ev) {
    var path = Polymer.dom(ev).path;
    var ta = 'auto';
    for (var i = 0, n; i < path.length; i++) {
      n = path[i];
      if (n[TOUCH_ACTION]) {
        ta = n[TOUCH_ACTION];
        break;
      }
    }
    return ta;
  }
  function trackDocument(stateObj, movefn, upfn) {
    stateObj.movefn = movefn;
    stateObj.upfn = upfn;
    document.addEventListener('mousemove', movefn);
    document.addEventListener('mouseup', upfn);
  }
  function untrackDocument(stateObj) {
    document.removeEventListener('mousemove', stateObj.movefn);
    document.removeEventListener('mouseup', stateObj.upfn);
    stateObj.movefn = null;
    stateObj.upfn = null;
  }
  document.addEventListener('touchend', ignoreMouse, SUPPORTS_PASSIVE ? { passive: true } : false);
  var Gestures = {
    gestures: {},
    recognizers: [],
    deepTargetFind: function deepTargetFind(x, y) {
      var node = document.elementFromPoint(x, y);
      var next = node;
      while (next && next.shadowRoot) {
        next = next.shadowRoot.elementFromPoint(x, y);
        if (next) {
          node = next;
        }
      }
      return node;
    },
    findOriginalTarget: function findOriginalTarget(ev) {
      if (ev.path) {
        return ev.path[0];
      }
      return ev.target;
    },
    handleNative: function handleNative(ev) {
      var handled;
      var type = ev.type;
      var node = wrap(ev.currentTarget);
      var gobj = node[GESTURE_KEY];
      if (!gobj) {
        return;
      }
      var gs = gobj[type];
      if (!gs) {
        return;
      }
      if (!ev[HANDLED_OBJ]) {
        ev[HANDLED_OBJ] = {};
        if (type.slice(0, 5) === 'touch') {
          var t = ev.changedTouches[0];
          if (type === 'touchstart') {
            if (ev.touches.length === 1) {
              POINTERSTATE.touch.id = t.identifier;
            }
          }
          if (POINTERSTATE.touch.id !== t.identifier) {
            return;
          }
          if (!HAS_NATIVE_TA) {
            if (type === 'touchstart' || type === 'touchmove') {
              Gestures.handleTouchAction(ev);
            }
          }
        }
      }
      handled = ev[HANDLED_OBJ];
      if (handled.skip) {
        return;
      }
      var recognizers = Gestures.recognizers;
      for (var i = 0, r; i < recognizers.length; i++) {
        r = recognizers[i];
        if (gs[r.name] && !handled[r.name]) {
          if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {
            r.reset();
          }
        }
      }
      for (i = 0, r; i < recognizers.length; i++) {
        r = recognizers[i];
        if (gs[r.name] && !handled[r.name]) {
          handled[r.name] = true;
          r[type](ev);
        }
      }
    },
    handleTouchAction: function handleTouchAction(ev) {
      var t = ev.changedTouches[0];
      var type = ev.type;
      if (type === 'touchstart') {
        POINTERSTATE.touch.x = t.clientX;
        POINTERSTATE.touch.y = t.clientY;
        POINTERSTATE.touch.scrollDecided = false;
      } else if (type === 'touchmove') {
        if (POINTERSTATE.touch.scrollDecided) {
          return;
        }
        POINTERSTATE.touch.scrollDecided = true;
        var ta = firstTouchAction(ev);
        var prevent = false;
        var dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
        var dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
        if (!ev.cancelable) {} else if (ta === 'none') {
          prevent = true;
        } else if (ta === 'pan-x') {
          prevent = dy > dx;
        } else if (ta === 'pan-y') {
          prevent = dx > dy;
        }
        if (prevent) {
          ev.preventDefault();
        } else {
          Gestures.prevent('track');
        }
      }
    },
    add: function add(node, evType, handler) {
      node = wrap(node);
      var recognizer = this.gestures[evType];
      var deps = recognizer.deps;
      var name = recognizer.name;
      var gobj = node[GESTURE_KEY];
      if (!gobj) {
        node[GESTURE_KEY] = gobj = {};
      }
      for (var i = 0, dep, gd; i < deps.length; i++) {
        dep = deps[i];
        if (IS_TOUCH_ONLY && MOUSE_EVENTS.indexOf(dep) > -1 && dep !== 'click') {
          continue;
        }
        gd = gobj[dep];
        if (!gd) {
          gobj[dep] = gd = { _count: 0 };
        }
        if (gd._count === 0) {
          node.addEventListener(dep, this.handleNative);
        }
        gd[name] = (gd[name] || 0) + 1;
        gd._count = (gd._count || 0) + 1;
      }
      node.addEventListener(evType, handler);
      if (recognizer.touchAction) {
        this.setTouchAction(node, recognizer.touchAction);
      }
    },
    remove: function remove(node, evType, handler) {
      node = wrap(node);
      var recognizer = this.gestures[evType];
      var deps = recognizer.deps;
      var name = recognizer.name;
      var gobj = node[GESTURE_KEY];
      if (gobj) {
        for (var i = 0, dep, gd; i < deps.length; i++) {
          dep = deps[i];
          gd = gobj[dep];
          if (gd && gd[name]) {
            gd[name] = (gd[name] || 1) - 1;
            gd._count = (gd._count || 1) - 1;
            if (gd._count === 0) {
              node.removeEventListener(dep, this.handleNative);
            }
          }
        }
      }
      node.removeEventListener(evType, handler);
    },
    register: function register(recog) {
      this.recognizers.push(recog);
      for (var i = 0; i < recog.emits.length; i++) {
        this.gestures[recog.emits[i]] = recog;
      }
    },
    findRecognizerByEvent: function findRecognizerByEvent(evName) {
      for (var i = 0, r; i < this.recognizers.length; i++) {
        r = this.recognizers[i];
        for (var j = 0, n; j < r.emits.length; j++) {
          n = r.emits[j];
          if (n === evName) {
            return r;
          }
        }
      }
      return null;
    },
    setTouchAction: function setTouchAction(node, value) {
      if (HAS_NATIVE_TA) {
        node.style.touchAction = value;
      }
      node[TOUCH_ACTION] = value;
    },
    fire: function fire(target, type, detail) {
      var ev = Polymer.Base.fire(type, detail, {
        node: target,
        bubbles: true,
        cancelable: true
      });
      if (ev.defaultPrevented) {
        var preventer = detail.preventer || detail.sourceEvent;
        if (preventer && preventer.preventDefault) {
          preventer.preventDefault();
        }
      }
    },
    prevent: function prevent(evName) {
      var recognizer = this.findRecognizerByEvent(evName);
      if (recognizer.info) {
        recognizer.info.prevent = true;
      }
    },
    resetMouseCanceller: function resetMouseCanceller() {
      if (POINTERSTATE.mouse.mouseIgnoreJob) {
        POINTERSTATE.mouse.mouseIgnoreJob.complete();
      }
    }
  };
  Gestures.register({
    name: 'downup',
    deps: ['mousedown', 'touchstart', 'touchend'],
    flow: {
      start: ['mousedown', 'touchstart'],
      end: ['mouseup', 'touchend']
    },
    emits: ['down', 'up'],
    info: {
      movefn: null,
      upfn: null
    },
    reset: function reset() {
      untrackDocument(this.info);
    },
    mousedown: function mousedown(e) {
      if (!hasLeftMouseButton(e)) {
        return;
      }
      var t = Gestures.findOriginalTarget(e);
      var self = this;
      var movefn = function movefn(e) {
        if (!hasLeftMouseButton(e)) {
          self.fire('up', t, e);
          untrackDocument(self.info);
        }
      };
      var upfn = function upfn(e) {
        if (hasLeftMouseButton(e)) {
          self.fire('up', t, e);
        }
        untrackDocument(self.info);
      };
      trackDocument(this.info, movefn, upfn);
      this.fire('down', t, e);
    },
    touchstart: function touchstart(e) {
      this.fire('down', Gestures.findOriginalTarget(e), e.changedTouches[0], e);
    },
    touchend: function touchend(e) {
      this.fire('up', Gestures.findOriginalTarget(e), e.changedTouches[0], e);
    },
    fire: function fire(type, target, event, preventer) {
      Gestures.fire(target, type, {
        x: event.clientX,
        y: event.clientY,
        sourceEvent: event,
        preventer: preventer,
        prevent: function prevent(e) {
          return Gestures.prevent(e);
        }
      });
    }
  });
  Gestures.register({
    name: 'track',
    touchAction: 'none',
    deps: ['mousedown', 'touchstart', 'touchmove', 'touchend'],
    flow: {
      start: ['mousedown', 'touchstart'],
      end: ['mouseup', 'touchend']
    },
    emits: ['track'],
    info: {
      x: 0,
      y: 0,
      state: 'start',
      started: false,
      moves: [],
      addMove: function addMove(move) {
        if (this.moves.length > TRACK_LENGTH) {
          this.moves.shift();
        }
        this.moves.push(move);
      },
      movefn: null,
      upfn: null,
      prevent: false
    },
    reset: function reset() {
      this.info.state = 'start';
      this.info.started = false;
      this.info.moves = [];
      this.info.x = 0;
      this.info.y = 0;
      this.info.prevent = false;
      untrackDocument(this.info);
    },
    hasMovedEnough: function hasMovedEnough(x, y) {
      if (this.info.prevent) {
        return false;
      }
      if (this.info.started) {
        return true;
      }
      var dx = Math.abs(this.info.x - x);
      var dy = Math.abs(this.info.y - y);
      return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;
    },
    mousedown: function mousedown(e) {
      if (!hasLeftMouseButton(e)) {
        return;
      }
      var t = Gestures.findOriginalTarget(e);
      var self = this;
      var movefn = function movefn(e) {
        var x = e.clientX,
            y = e.clientY;
        if (self.hasMovedEnough(x, y)) {
          self.info.state = self.info.started ? e.type === 'mouseup' ? 'end' : 'track' : 'start';
          if (self.info.state === 'start') {
            Gestures.prevent('tap');
          }
          self.info.addMove({
            x: x,
            y: y
          });
          if (!hasLeftMouseButton(e)) {
            self.info.state = 'end';
            untrackDocument(self.info);
          }
          self.fire(t, e);
          self.info.started = true;
        }
      };
      var upfn = function upfn(e) {
        if (self.info.started) {
          movefn(e);
        }
        untrackDocument(self.info);
      };
      trackDocument(this.info, movefn, upfn);
      this.info.x = e.clientX;
      this.info.y = e.clientY;
    },
    touchstart: function touchstart(e) {
      var ct = e.changedTouches[0];
      this.info.x = ct.clientX;
      this.info.y = ct.clientY;
    },
    touchmove: function touchmove(e) {
      var t = Gestures.findOriginalTarget(e);
      var ct = e.changedTouches[0];
      var x = ct.clientX,
          y = ct.clientY;
      if (this.hasMovedEnough(x, y)) {
        if (this.info.state === 'start') {
          Gestures.prevent('tap');
        }
        this.info.addMove({
          x: x,
          y: y
        });
        this.fire(t, ct);
        this.info.state = 'track';
        this.info.started = true;
      }
    },
    touchend: function touchend(e) {
      var t = Gestures.findOriginalTarget(e);
      var ct = e.changedTouches[0];
      if (this.info.started) {
        this.info.state = 'end';
        this.info.addMove({
          x: ct.clientX,
          y: ct.clientY
        });
        this.fire(t, ct, e);
      }
    },
    fire: function fire(target, touch, preventer) {
      var secondlast = this.info.moves[this.info.moves.length - 2];
      var lastmove = this.info.moves[this.info.moves.length - 1];
      var dx = lastmove.x - this.info.x;
      var dy = lastmove.y - this.info.y;
      var ddx,
          ddy = 0;
      if (secondlast) {
        ddx = lastmove.x - secondlast.x;
        ddy = lastmove.y - secondlast.y;
      }
      return Gestures.fire(target, 'track', {
        state: this.info.state,
        x: touch.clientX,
        y: touch.clientY,
        dx: dx,
        dy: dy,
        ddx: ddx,
        ddy: ddy,
        sourceEvent: touch,
        preventer: preventer,
        hover: function hover() {
          return Gestures.deepTargetFind(touch.clientX, touch.clientY);
        }
      });
    }
  });
  Gestures.register({
    name: 'tap',
    deps: ['mousedown', 'click', 'touchstart', 'touchend'],
    flow: {
      start: ['mousedown', 'touchstart'],
      end: ['click', 'touchend']
    },
    emits: ['tap'],
    info: {
      x: NaN,
      y: NaN,
      prevent: false
    },
    reset: function reset() {
      this.info.x = NaN;
      this.info.y = NaN;
      this.info.prevent = false;
    },
    save: function save(e) {
      this.info.x = e.clientX;
      this.info.y = e.clientY;
    },
    mousedown: function mousedown(e) {
      if (hasLeftMouseButton(e)) {
        this.save(e);
      }
    },
    click: function click(e) {
      if (hasLeftMouseButton(e)) {
        this.forward(e);
      }
    },
    touchstart: function touchstart(e) {
      this.save(e.changedTouches[0], e);
    },
    touchend: function touchend(e) {
      this.forward(e.changedTouches[0], e);
    },
    forward: function forward(e, preventer) {
      var dx = Math.abs(e.clientX - this.info.x);
      var dy = Math.abs(e.clientY - this.info.y);
      var t = Gestures.findOriginalTarget(e);
      if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e)) {
        if (!this.info.prevent) {
          Gestures.fire(t, 'tap', {
            x: e.clientX,
            y: e.clientY,
            sourceEvent: e,
            preventer: preventer
          });
        }
      }
    }
  });
  var DIRECTION_MAP = {
    x: 'pan-x',
    y: 'pan-y',
    none: 'none',
    all: 'auto'
  };
  Polymer.Base._addFeature({
    _setupGestures: function _setupGestures() {
      this.__polymerGestures = null;
    },
    _listen: function _listen(node, eventName, handler) {
      if (Gestures.gestures[eventName]) {
        Gestures.add(node, eventName, handler);
      } else {
        node.addEventListener(eventName, handler);
      }
    },
    _unlisten: function _unlisten(node, eventName, handler) {
      if (Gestures.gestures[eventName]) {
        Gestures.remove(node, eventName, handler);
      } else {
        node.removeEventListener(eventName, handler);
      }
    },
    setScrollDirection: function setScrollDirection(direction, node) {
      node = node || this;
      Gestures.setTouchAction(node, DIRECTION_MAP[direction] || 'auto');
    }
  });
  Polymer.Gestures = Gestures;
})();(function () {
  'use strict';

  Polymer.Base._addFeature({
    $$: function $$(slctr) {
      return Polymer.dom(this.root).querySelector(slctr);
    },
    toggleClass: function toggleClass(name, bool, node) {
      node = node || this;
      if (arguments.length == 1) {
        bool = !node.classList.contains(name);
      }
      if (bool) {
        Polymer.dom(node).classList.add(name);
      } else {
        Polymer.dom(node).classList.remove(name);
      }
    },
    toggleAttribute: function toggleAttribute(name, bool, node) {
      node = node || this;
      if (arguments.length == 1) {
        bool = !node.hasAttribute(name);
      }
      if (bool) {
        Polymer.dom(node).setAttribute(name, '');
      } else {
        Polymer.dom(node).removeAttribute(name);
      }
    },
    classFollows: function classFollows(name, toElement, fromElement) {
      if (fromElement) {
        Polymer.dom(fromElement).classList.remove(name);
      }
      if (toElement) {
        Polymer.dom(toElement).classList.add(name);
      }
    },
    attributeFollows: function attributeFollows(name, toElement, fromElement) {
      if (fromElement) {
        Polymer.dom(fromElement).removeAttribute(name);
      }
      if (toElement) {
        Polymer.dom(toElement).setAttribute(name, '');
      }
    },
    getEffectiveChildNodes: function getEffectiveChildNodes() {
      return Polymer.dom(this).getEffectiveChildNodes();
    },
    getEffectiveChildren: function getEffectiveChildren() {
      var list = Polymer.dom(this).getEffectiveChildNodes();
      return list.filter(function (n) {
        return n.nodeType === Node.ELEMENT_NODE;
      });
    },
    getEffectiveTextContent: function getEffectiveTextContent() {
      var cn = this.getEffectiveChildNodes();
      var tc = [];
      for (var i = 0, c; c = cn[i]; i++) {
        if (c.nodeType !== Node.COMMENT_NODE) {
          tc.push(Polymer.dom(c).textContent);
        }
      }
      return tc.join('');
    },
    queryEffectiveChildren: function queryEffectiveChildren(slctr) {
      var e$ = Polymer.dom(this).queryDistributedElements(slctr);
      return e$ && e$[0];
    },
    queryAllEffectiveChildren: function queryAllEffectiveChildren(slctr) {
      return Polymer.dom(this).queryDistributedElements(slctr);
    },
    getContentChildNodes: function getContentChildNodes(slctr) {
      var content = Polymer.dom(this.root).querySelector(slctr || 'content');
      return content ? Polymer.dom(content).getDistributedNodes() : [];
    },
    getContentChildren: function getContentChildren(slctr) {
      return this.getContentChildNodes(slctr).filter(function (n) {
        return n.nodeType === Node.ELEMENT_NODE;
      });
    },
    fire: function fire(type, detail, options) {
      options = options || Polymer.nob;
      var node = options.node || this;
      detail = detail === null || detail === undefined ? {} : detail;
      var bubbles = options.bubbles === undefined ? true : options.bubbles;
      var cancelable = Boolean(options.cancelable);
      var useCache = options._useCache;
      var event = this._getEvent(type, bubbles, cancelable, useCache);
      event.detail = detail;
      if (useCache) {
        this.__eventCache[type] = null;
      }
      node.dispatchEvent(event);
      if (useCache) {
        this.__eventCache[type] = event;
      }
      return event;
    },
    __eventCache: {},
    _getEvent: function _getEvent(type, bubbles, cancelable, useCache) {
      var event = useCache && this.__eventCache[type];
      if (!event || event.bubbles != bubbles || event.cancelable != cancelable) {
        event = new Event(type, {
          bubbles: Boolean(bubbles),
          cancelable: cancelable
        });
      }
      return event;
    },
    async: function async(callback, waitTime) {
      var self = this;
      return Polymer.Async.run(function () {
        callback.call(self);
      }, waitTime);
    },
    cancelAsync: function cancelAsync(handle) {
      Polymer.Async.cancel(handle);
    },
    arrayDelete: function arrayDelete(path, item) {
      var index;
      if (Array.isArray(path)) {
        index = path.indexOf(item);
        if (index >= 0) {
          return path.splice(index, 1);
        }
      } else {
        var arr = this._get(path);
        index = arr.indexOf(item);
        if (index >= 0) {
          return this.splice(path, index, 1);
        }
      }
    },
    transform: function transform(_transform, node) {
      node = node || this;
      node.style.webkitTransform = _transform;
      node.style.transform = _transform;
    },
    translate3d: function translate3d(x, y, z, node) {
      node = node || this;
      this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);
    },
    importHref: function importHref(href, onload, onerror, optAsync) {
      var link = document.createElement('link');
      link.rel = 'import';
      link.href = href;
      var list = Polymer.Base.importHref.imported = Polymer.Base.importHref.imported || {};
      var cached = list[link.href];
      var imprt = cached || link;
      var self = this;
      var loadListener = function loadListener(e) {
        e.target.__firedLoad = true;
        e.target.removeEventListener('load', loadListener);
        e.target.removeEventListener('error', errorListener);
        return onload.call(self, e);
      };
      var errorListener = function errorListener(e) {
        e.target.__firedError = true;
        e.target.removeEventListener('load', loadListener);
        e.target.removeEventListener('error', errorListener);
        return onerror.call(self, e);
      };
      if (onload) {
        imprt.addEventListener('load', loadListener);
      }
      if (onerror) {
        imprt.addEventListener('error', errorListener);
      }
      if (cached) {
        if (cached.__firedLoad) {
          cached.dispatchEvent(new Event('load'));
        }
        if (cached.__firedError) {
          cached.dispatchEvent(new Event('error'));
        }
      } else {
        list[link.href] = link;
        optAsync = Boolean(optAsync);
        if (optAsync) {
          link.setAttribute('async', '');
        }
        document.head.appendChild(link);
      }
      return imprt;
    },
    create: function create(tag, props) {
      var elt = document.createElement(tag);
      if (props) {
        for (var n in props) {
          elt[n] = props[n];
        }
      }
      return elt;
    },
    isLightDescendant: function isLightDescendant(node) {
      return this !== node && this.contains(node) && Polymer.dom(this).getOwnerRoot() === Polymer.dom(node).getOwnerRoot();
    },
    isLocalDescendant: function isLocalDescendant(node) {
      return this.root === Polymer.dom(node).getOwnerRoot();
    }
  });
  if (!Polymer.Settings.useNativeCustomElements) {
    var importHref = Polymer.Base.importHref;
    Polymer.Base.importHref = function (href, onload, onerror, optAsync) {
      CustomElements.ready = false;
      var loadFn = function loadFn(e) {
        CustomElements.upgradeDocumentTree(document);
        CustomElements.ready = true;
        if (onload) {
          return onload.call(this, e);
        }
      };
      return importHref.call(this, href, loadFn, onerror, optAsync);
    };
  }
})();Polymer.Bind = {
  prepareModel: function prepareModel(model) {
    Polymer.Base.mixin(model, this._modelApi);
  },
  _modelApi: {
    _notifyChange: function _notifyChange(source, event, value) {
      value = value === undefined ? this[source] : value;
      event = event || Polymer.CaseMap.camelToDashCase(source) + '-changed';
      this.fire(event, { value: value }, {
        bubbles: false,
        cancelable: false,
        _useCache: Polymer.Settings.eventDataCache || !Polymer.Settings.isIE
      });
    },
    _propertySetter: function _propertySetter(property, value, effects, fromAbove) {
      var old = this.__data__[property];
      if (old !== value && (old === old || value === value)) {
        this.__data__[property] = value;
        if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') {
          this._clearPath(property);
        }
        if (this._propertyChanged) {
          this._propertyChanged(property, value, old);
        }
        if (effects) {
          this._effectEffects(property, value, effects, old, fromAbove);
        }
      }
      return old;
    },
    __setProperty: function __setProperty(property, value, quiet, node) {
      node = node || this;
      var effects = node._propertyEffects && node._propertyEffects[property];
      if (effects) {
        node._propertySetter(property, value, effects, quiet);
      } else if (node[property] !== value) {
        node[property] = value;
      }
    },
    _effectEffects: function _effectEffects(property, value, effects, old, fromAbove) {
      for (var i = 0, l = effects.length, fx; i < l && (fx = effects[i]); i++) {
        fx.fn.call(this, property, this[property], fx.effect, old, fromAbove);
      }
    },
    _clearPath: function _clearPath(path) {
      for (var prop in this.__data__) {
        if (Polymer.Path.isDescendant(path, prop)) {
          this.__data__[prop] = undefined;
        }
      }
    }
  },
  ensurePropertyEffects: function ensurePropertyEffects(model, property) {
    if (!model._propertyEffects) {
      model._propertyEffects = {};
    }
    var fx = model._propertyEffects[property];
    if (!fx) {
      fx = model._propertyEffects[property] = [];
    }
    return fx;
  },
  addPropertyEffect: function addPropertyEffect(model, property, kind, effect) {
    var fx = this.ensurePropertyEffects(model, property);
    var propEffect = {
      kind: kind,
      effect: effect,
      fn: Polymer.Bind['_' + kind + 'Effect']
    };
    fx.push(propEffect);
    return propEffect;
  },
  createBindings: function createBindings(model) {
    var fx$ = model._propertyEffects;
    if (fx$) {
      for (var n in fx$) {
        var fx = fx$[n];
        fx.sort(this._sortPropertyEffects);
        this._createAccessors(model, n, fx);
      }
    }
  },
  _sortPropertyEffects: function () {
    var EFFECT_ORDER = {
      'compute': 0,
      'annotation': 1,
      'annotatedComputation': 2,
      'reflect': 3,
      'notify': 4,
      'observer': 5,
      'complexObserver': 6,
      'function': 7
    };
    return function (a, b) {
      return EFFECT_ORDER[a.kind] - EFFECT_ORDER[b.kind];
    };
  }(),
  _createAccessors: function _createAccessors(model, property, effects) {
    var defun = {
      get: function get() {
        return this.__data__[property];
      }
    };
    var setter = function setter(value) {
      this._propertySetter(property, value, effects);
    };
    var info = model.getPropertyInfo && model.getPropertyInfo(property);
    if (info && info.readOnly) {
      if (!info.computed) {
        model['_set' + this.upper(property)] = setter;
      }
    } else {
      defun.set = setter;
    }
    Object.defineProperty(model, property, defun);
  },
  upper: function upper(name) {
    return name[0].toUpperCase() + name.substring(1);
  },
  _addAnnotatedListener: function _addAnnotatedListener(model, index, property, path, event, negated) {
    if (!model._bindListeners) {
      model._bindListeners = [];
    }
    var fn = this._notedListenerFactory(property, path, Polymer.Path.isDeep(path), negated);
    var eventName = event || Polymer.CaseMap.camelToDashCase(property) + '-changed';
    model._bindListeners.push({
      index: index,
      property: property,
      path: path,
      changedFn: fn,
      event: eventName
    });
  },
  _isEventBogus: function _isEventBogus(e, target) {
    return e.path && e.path[0] !== target;
  },
  _notedListenerFactory: function _notedListenerFactory(property, path, isStructured, negated) {
    return function (target, value, targetPath) {
      if (targetPath) {
        var newPath = Polymer.Path.translate(property, path, targetPath);
        this._notifyPath(newPath, value);
      } else {
        value = target[property];
        if (negated) {
          value = !value;
        }
        if (!isStructured) {
          this[path] = value;
        } else {
          if (this.__data__[path] != value) {
            this.set(path, value);
          }
        }
      }
    };
  },
  prepareInstance: function prepareInstance(inst) {
    inst.__data__ = Object.create(null);
  },
  setupBindListeners: function setupBindListeners(inst) {
    var b$ = inst._bindListeners;
    for (var i = 0, l = b$.length, info; i < l && (info = b$[i]); i++) {
      var node = inst._nodes[info.index];
      this._addNotifyListener(node, inst, info.event, info.changedFn);
    }
  },
  _addNotifyListener: function _addNotifyListener(element, context, event, changedFn) {
    element.addEventListener(event, function (e) {
      return context._notifyListener(changedFn, e);
    });
  }
};Polymer.Base.mixin(Polymer.Bind, {
  _shouldAddListener: function _shouldAddListener(effect) {
    return effect.name && effect.kind != 'attribute' && effect.kind != 'text' && !effect.isCompound && effect.parts[0].mode === '{';
  },
  _annotationEffect: function _annotationEffect(source, value, effect) {
    if (source != effect.value) {
      value = this._get(effect.value);
      this.__data__[effect.value] = value;
    }
    this._applyEffectValue(effect, value);
  },
  _reflectEffect: function _reflectEffect(source, value, effect) {
    this.reflectPropertyToAttribute(source, effect.attribute, value);
  },
  _notifyEffect: function _notifyEffect(source, value, effect, old, fromAbove) {
    if (!fromAbove) {
      this._notifyChange(source, effect.event, value);
    }
  },
  _functionEffect: function _functionEffect(source, value, fn, old, fromAbove) {
    fn.call(this, source, value, old, fromAbove);
  },
  _observerEffect: function _observerEffect(source, value, effect, old) {
    var fn = this[effect.method];
    if (fn) {
      fn.call(this, value, old);
    } else {
      this._warn(this._logf('_observerEffect', 'observer method `' + effect.method + '` not defined'));
    }
  },
  _complexObserverEffect: function _complexObserverEffect(source, value, effect) {
    var fn = this[effect.method];
    if (fn) {
      var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
      if (args) {
        fn.apply(this, args);
      }
    } else if (effect.dynamicFn) {} else {
      this._warn(this._logf('_complexObserverEffect', 'observer method `' + effect.method + '` not defined'));
    }
  },
  _computeEffect: function _computeEffect(source, value, effect) {
    var fn = this[effect.method];
    if (fn) {
      var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
      if (args) {
        var computedvalue = fn.apply(this, args);
        this.__setProperty(effect.name, computedvalue);
      }
    } else if (effect.dynamicFn) {} else {
      this._warn(this._logf('_computeEffect', 'compute method `' + effect.method + '` not defined'));
    }
  },
  _annotatedComputationEffect: function _annotatedComputationEffect(source, value, effect) {
    var computedHost = this._rootDataHost || this;
    var fn = computedHost[effect.method];
    if (fn) {
      var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
      if (args) {
        var computedvalue = fn.apply(computedHost, args);
        this._applyEffectValue(effect, computedvalue);
      }
    } else if (effect.dynamicFn) {} else {
      computedHost._warn(computedHost._logf('_annotatedComputationEffect', 'compute method `' + effect.method + '` not defined'));
    }
  },
  _marshalArgs: function _marshalArgs(model, effect, path, value) {
    var values = [];
    var args = effect.args;
    var bailoutEarly = args.length > 1 || effect.dynamicFn;
    for (var i = 0, l = args.length; i < l; i++) {
      var arg = args[i];
      var name = arg.name;
      var v;
      if (arg.literal) {
        v = arg.value;
      } else if (path === name) {
        v = value;
      } else {
        v = model[name];
        if (v === undefined && arg.structured) {
          v = Polymer.Base._get(name, model);
        }
      }
      if (bailoutEarly && v === undefined) {
        return;
      }
      if (arg.wildcard) {
        var matches = Polymer.Path.isAncestor(path, name);
        values[i] = {
          path: matches ? path : name,
          value: matches ? value : v,
          base: v
        };
      } else {
        values[i] = v;
      }
    }
    return values;
  }
});Polymer.Base._addFeature({
  _addPropertyEffect: function _addPropertyEffect(property, kind, effect) {
    var prop = Polymer.Bind.addPropertyEffect(this, property, kind, effect);
    prop.pathFn = this['_' + prop.kind + 'PathEffect'];
  },
  _prepEffects: function _prepEffects() {
    Polymer.Bind.prepareModel(this);
    this._addAnnotationEffects(this._notes);
  },
  _prepBindings: function _prepBindings() {
    Polymer.Bind.createBindings(this);
  },
  _addPropertyEffects: function _addPropertyEffects(properties) {
    if (properties) {
      for (var p in properties) {
        var prop = properties[p];
        if (prop.observer) {
          this._addObserverEffect(p, prop.observer);
        }
        if (prop.computed) {
          prop.readOnly = true;
          this._addComputedEffect(p, prop.computed);
        }
        if (prop.notify) {
          this._addPropertyEffect(p, 'notify', { event: Polymer.CaseMap.camelToDashCase(p) + '-changed' });
        }
        if (prop.reflectToAttribute) {
          var attr = Polymer.CaseMap.camelToDashCase(p);
          if (attr[0] === '-') {
            this._warn(this._logf('_addPropertyEffects', 'Property ' + p + ' cannot be reflected to attribute ' + attr + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property instead.'));
          } else {
            this._addPropertyEffect(p, 'reflect', { attribute: attr });
          }
        }
        if (prop.readOnly) {
          Polymer.Bind.ensurePropertyEffects(this, p);
        }
      }
    }
  },
  _addComputedEffect: function _addComputedEffect(name, expression) {
    var sig = this._parseMethod(expression);
    var dynamicFn = sig.dynamicFn;
    for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
      this._addPropertyEffect(arg.model, 'compute', {
        method: sig.method,
        args: sig.args,
        trigger: arg,
        name: name,
        dynamicFn: dynamicFn
      });
    }
    if (dynamicFn) {
      this._addPropertyEffect(sig.method, 'compute', {
        method: sig.method,
        args: sig.args,
        trigger: null,
        name: name,
        dynamicFn: dynamicFn
      });
    }
  },
  _addObserverEffect: function _addObserverEffect(property, observer) {
    this._addPropertyEffect(property, 'observer', {
      method: observer,
      property: property
    });
  },
  _addComplexObserverEffects: function _addComplexObserverEffects(observers) {
    if (observers) {
      for (var i = 0, o; i < observers.length && (o = observers[i]); i++) {
        this._addComplexObserverEffect(o);
      }
    }
  },
  _addComplexObserverEffect: function _addComplexObserverEffect(observer) {
    var sig = this._parseMethod(observer);
    if (!sig) {
      throw new Error('Malformed observer expression \'' + observer + '\'');
    }
    var dynamicFn = sig.dynamicFn;
    for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
      this._addPropertyEffect(arg.model, 'complexObserver', {
        method: sig.method,
        args: sig.args,
        trigger: arg,
        dynamicFn: dynamicFn
      });
    }
    if (dynamicFn) {
      this._addPropertyEffect(sig.method, 'complexObserver', {
        method: sig.method,
        args: sig.args,
        trigger: null,
        dynamicFn: dynamicFn
      });
    }
  },
  _addAnnotationEffects: function _addAnnotationEffects(notes) {
    for (var i = 0, note; i < notes.length && (note = notes[i]); i++) {
      var b$ = note.bindings;
      for (var j = 0, binding; j < b$.length && (binding = b$[j]); j++) {
        this._addAnnotationEffect(binding, i);
      }
    }
  },
  _addAnnotationEffect: function _addAnnotationEffect(note, index) {
    if (Polymer.Bind._shouldAddListener(note)) {
      Polymer.Bind._addAnnotatedListener(this, index, note.name, note.parts[0].value, note.parts[0].event, note.parts[0].negate);
    }
    for (var i = 0; i < note.parts.length; i++) {
      var part = note.parts[i];
      if (part.signature) {
        this._addAnnotatedComputationEffect(note, part, index);
      } else if (!part.literal) {
        if (note.kind === 'attribute' && note.name[0] === '-') {
          this._warn(this._logf('_addAnnotationEffect', 'Cannot set attribute ' + note.name + ' because "-" is not a valid attribute starting character'));
        } else {
          this._addPropertyEffect(part.model, 'annotation', {
            kind: note.kind,
            index: index,
            name: note.name,
            propertyName: note.propertyName,
            value: part.value,
            isCompound: note.isCompound,
            compoundIndex: part.compoundIndex,
            event: part.event,
            customEvent: part.customEvent,
            negate: part.negate
          });
        }
      }
    }
  },
  _addAnnotatedComputationEffect: function _addAnnotatedComputationEffect(note, part, index) {
    var sig = part.signature;
    if (sig.static) {
      this.__addAnnotatedComputationEffect('__static__', index, note, part, null);
    } else {
      for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
        if (!arg.literal) {
          this.__addAnnotatedComputationEffect(arg.model, index, note, part, arg);
        }
      }
      if (sig.dynamicFn) {
        this.__addAnnotatedComputationEffect(sig.method, index, note, part, null);
      }
    }
  },
  __addAnnotatedComputationEffect: function __addAnnotatedComputationEffect(property, index, note, part, trigger) {
    this._addPropertyEffect(property, 'annotatedComputation', {
      index: index,
      isCompound: note.isCompound,
      compoundIndex: part.compoundIndex,
      kind: note.kind,
      name: note.name,
      negate: part.negate,
      method: part.signature.method,
      args: part.signature.args,
      trigger: trigger,
      dynamicFn: part.signature.dynamicFn
    });
  },
  _parseMethod: function _parseMethod(expression) {
    var m = expression.match(/([^\s]+?)\(([\s\S]*)\)/);
    if (m) {
      var sig = {
        method: m[1],
        static: true
      };
      if (this.getPropertyInfo(sig.method) !== Polymer.nob) {
        sig.static = false;
        sig.dynamicFn = true;
      }
      if (m[2].trim()) {
        var args = m[2].replace(/\\,/g, '&comma;').split(',');
        return this._parseArgs(args, sig);
      } else {
        sig.args = Polymer.nar;
        return sig;
      }
    }
  },
  _parseArgs: function _parseArgs(argList, sig) {
    sig.args = argList.map(function (rawArg) {
      var arg = this._parseArg(rawArg);
      if (!arg.literal) {
        sig.static = false;
      }
      return arg;
    }, this);
    return sig;
  },
  _parseArg: function _parseArg(rawArg) {
    var arg = rawArg.trim().replace(/&comma;/g, ',').replace(/\\(.)/g, '$1');
    var a = { name: arg };
    var fc = arg[0];
    if (fc === '-') {
      fc = arg[1];
    }
    if (fc >= '0' && fc <= '9') {
      fc = '#';
    }
    switch (fc) {
      case '\'':
      case '"':
        a.value = arg.slice(1, -1);
        a.literal = true;
        break;
      case '#':
        a.value = Number(arg);
        a.literal = true;
        break;
    }
    if (!a.literal) {
      a.model = Polymer.Path.root(arg);
      a.structured = Polymer.Path.isDeep(arg);
      if (a.structured) {
        a.wildcard = arg.slice(-2) == '.*';
        if (a.wildcard) {
          a.name = arg.slice(0, -2);
        }
      }
    }
    return a;
  },
  _marshalInstanceEffects: function _marshalInstanceEffects() {
    Polymer.Bind.prepareInstance(this);
    if (this._bindListeners) {
      Polymer.Bind.setupBindListeners(this);
    }
  },
  _applyEffectValue: function _applyEffectValue(info, value) {
    var node = this._nodes[info.index];
    var property = info.name;
    value = this._computeFinalAnnotationValue(node, property, value, info);
    if (info.kind == 'attribute') {
      this.serializeValueToAttribute(value, property, node);
    } else {
      var pinfo = node._propertyInfo && node._propertyInfo[property];
      if (pinfo && pinfo.readOnly) {
        return;
      }
      this.__setProperty(property, value, Polymer.Settings.suppressBindingNotifications, node);
    }
  },
  _computeFinalAnnotationValue: function _computeFinalAnnotationValue(node, property, value, info) {
    if (info.negate) {
      value = !value;
    }
    if (info.isCompound) {
      var storage = node.__compoundStorage__[property];
      storage[info.compoundIndex] = value;
      value = storage.join('');
    }
    if (info.kind !== 'attribute') {
      if (property === 'className') {
        value = this._scopeElementClass(node, value);
      }
      if (property === 'textContent' || node.localName == 'input' && property == 'value') {
        value = value == undefined ? '' : value;
      }
    }
    return value;
  },
  _executeStaticEffects: function _executeStaticEffects() {
    if (this._propertyEffects && this._propertyEffects.__static__) {
      this._effectEffects('__static__', null, this._propertyEffects.__static__);
    }
  }
});(function () {
  var usePolyfillProto = Polymer.Settings.usePolyfillProto;
  var avoidInstanceProperties = Boolean(Object.getOwnPropertyDescriptor(document.documentElement, 'properties'));
  Polymer.Base._addFeature({
    _setupConfigure: function _setupConfigure(initialConfig) {
      this._config = {};
      this._handlers = [];
      this._aboveConfig = null;
      if (initialConfig) {
        for (var i in initialConfig) {
          if (initialConfig[i] !== undefined) {
            this._config[i] = initialConfig[i];
          }
        }
      }
    },
    _marshalAttributes: function _marshalAttributes() {
      this._takeAttributesToModel(this._config);
    },
    _attributeChangedImpl: function _attributeChangedImpl(name) {
      var model = this._clientsReadied ? this : this._config;
      this._setAttributeToProperty(model, name);
    },
    _configValue: function _configValue(name, value) {
      var info = this._propertyInfo[name];
      if (!info || !info.readOnly) {
        this._config[name] = value;
      }
    },
    _beforeClientsReady: function _beforeClientsReady() {
      this._configure();
    },
    _configure: function _configure() {
      this._configureAnnotationReferences();
      this._configureInstanceProperties();
      this._aboveConfig = this.mixin({}, this._config);
      var config = {};
      for (var i = 0; i < this.behaviors.length; i++) {
        this._configureProperties(this.behaviors[i].properties, config);
      }
      this._configureProperties(avoidInstanceProperties ? this.__proto__.properties : this.properties, config);
      this.mixin(config, this._aboveConfig);
      this._config = config;
      if (this._clients && this._clients.length) {
        this._distributeConfig(this._config);
      }
    },
    _configureInstanceProperties: function _configureInstanceProperties() {
      for (var i in this._propertyEffects) {
        if (!usePolyfillProto && this.hasOwnProperty(i)) {
          this._configValue(i, this[i]);
          delete this[i];
        }
      }
    },
    _configureProperties: function _configureProperties(properties, config) {
      for (var i in properties) {
        var c = properties[i];
        if (c.value !== undefined) {
          var value = c.value;
          if (typeof value == 'function') {
            value = value.call(this, this._config);
          }
          config[i] = value;
        }
      }
    },
    _distributeConfig: function _distributeConfig(config) {
      var fx$ = this._propertyEffects;
      if (fx$) {
        for (var p in config) {
          var fx = fx$[p];
          if (fx) {
            for (var i = 0, l = fx.length, x; i < l && (x = fx[i]); i++) {
              if (x.kind === 'annotation') {
                var node = this._nodes[x.effect.index];
                var name = x.effect.propertyName;
                var isAttr = x.effect.kind == 'attribute';
                var hasEffect = node._propertyEffects && node._propertyEffects[name];
                if (node._configValue && (hasEffect || !isAttr)) {
                  var value = p === x.effect.value ? config[p] : this._get(x.effect.value, config);
                  value = this._computeFinalAnnotationValue(node, name, value, x.effect);
                  if (isAttr) {
                    value = node.deserialize(this.serialize(value), node._propertyInfo[name].type);
                  }
                  node._configValue(name, value);
                }
              }
            }
          }
        }
      }
    },
    _afterClientsReady: function _afterClientsReady() {
      this.importPath = this._importPath;
      this.rootPath = Polymer.rootPath;
      this._executeStaticEffects();
      this._applyConfig(this._config, this._aboveConfig);
      this._flushHandlers();
    },
    _applyConfig: function _applyConfig(config, aboveConfig) {
      for (var n in config) {
        if (this[n] === undefined) {
          this.__setProperty(n, config[n], n in aboveConfig);
        }
      }
    },
    _notifyListener: function _notifyListener(fn, e) {
      if (!Polymer.Bind._isEventBogus(e, e.target)) {
        var value, path;
        if (e.detail) {
          value = e.detail.value;
          path = e.detail.path;
        }
        if (!this._clientsReadied) {
          this._queueHandler([fn, e.target, value, path]);
        } else {
          return fn.call(this, e.target, value, path);
        }
      }
    },
    _queueHandler: function _queueHandler(args) {
      this._handlers.push(args);
    },
    _flushHandlers: function _flushHandlers() {
      var h$ = this._handlers;
      for (var i = 0, l = h$.length, h; i < l && (h = h$[i]); i++) {
        h[0].call(this, h[1], h[2], h[3]);
      }
      this._handlers = [];
    }
  });
})();(function () {
  'use strict';

  var Path = Polymer.Path;
  Polymer.Base._addFeature({
    notifyPath: function notifyPath(path, value, fromAbove) {
      var info = {};
      var v = this._get(path, this, info);
      if (arguments.length === 1) {
        value = v;
      }
      if (info.path) {
        this._notifyPath(info.path, value, fromAbove);
      }
    },
    _notifyPath: function _notifyPath(path, value, fromAbove) {
      var old = this._propertySetter(path, value);
      if (old !== value && (old === old || value === value)) {
        this._pathEffector(path, value);
        if (!fromAbove) {
          this._notifyPathUp(path, value);
        }
        return true;
      }
    },
    _getPathParts: function _getPathParts(path) {
      if (Array.isArray(path)) {
        var parts = [];
        for (var i = 0; i < path.length; i++) {
          var args = path[i].toString().split('.');
          for (var j = 0; j < args.length; j++) {
            parts.push(args[j]);
          }
        }
        return parts;
      } else {
        return path.toString().split('.');
      }
    },
    set: function set(path, value, root) {
      var prop = root || this;
      var parts = this._getPathParts(path);
      var array;
      var last = parts[parts.length - 1];
      if (parts.length > 1) {
        for (var i = 0; i < parts.length - 1; i++) {
          var part = parts[i];
          if (array && part[0] == '#') {
            prop = Polymer.Collection.get(array).getItem(part);
          } else {
            prop = prop[part];
            if (array && parseInt(part, 10) == part) {
              parts[i] = Polymer.Collection.get(array).getKey(prop);
            }
          }
          if (!prop) {
            return;
          }
          array = Array.isArray(prop) ? prop : null;
        }
        if (array) {
          var coll = Polymer.Collection.get(array);
          var old, key;
          if (last[0] == '#') {
            key = last;
            old = coll.getItem(key);
            last = array.indexOf(old);
            coll.setItem(key, value);
          } else if (parseInt(last, 10) == last) {
            old = prop[last];
            key = coll.getKey(old);
            parts[i] = key;
            coll.setItem(key, value);
          }
        }
        prop[last] = value;
        if (!root) {
          this._notifyPath(parts.join('.'), value);
        }
      } else {
        prop[path] = value;
      }
    },
    get: function get(path, root) {
      return this._get(path, root);
    },
    _get: function _get(path, root, info) {
      var prop = root || this;
      var parts = this._getPathParts(path);
      var array;
      for (var i = 0; i < parts.length; i++) {
        if (!prop) {
          return;
        }
        var part = parts[i];
        if (array && part[0] == '#') {
          prop = Polymer.Collection.get(array).getItem(part);
        } else {
          prop = prop[part];
          if (info && array && parseInt(part, 10) == part) {
            parts[i] = Polymer.Collection.get(array).getKey(prop);
          }
        }
        array = Array.isArray(prop) ? prop : null;
      }
      if (info) {
        info.path = parts.join('.');
      }
      return prop;
    },
    _pathEffector: function _pathEffector(path, value) {
      var model = Path.root(path);
      var fx$ = this._propertyEffects && this._propertyEffects[model];
      if (fx$) {
        for (var i = 0, fx; i < fx$.length && (fx = fx$[i]); i++) {
          var fxFn = fx.pathFn;
          if (fxFn) {
            fxFn.call(this, path, value, fx.effect);
          }
        }
      }
      if (this._boundPaths) {
        this._notifyBoundPaths(path, value);
      }
    },
    _annotationPathEffect: function _annotationPathEffect(path, value, effect) {
      if (Path.matches(effect.value, false, path)) {
        Polymer.Bind._annotationEffect.call(this, path, value, effect);
      } else if (!effect.negate && Path.isDescendant(effect.value, path)) {
        var node = this._nodes[effect.index];
        if (node && node._notifyPath) {
          var newPath = Path.translate(effect.value, effect.name, path);
          node._notifyPath(newPath, value, true);
        }
      }
    },
    _complexObserverPathEffect: function _complexObserverPathEffect(path, value, effect) {
      if (Path.matches(effect.trigger.name, effect.trigger.wildcard, path)) {
        Polymer.Bind._complexObserverEffect.call(this, path, value, effect);
      }
    },
    _computePathEffect: function _computePathEffect(path, value, effect) {
      if (Path.matches(effect.trigger.name, effect.trigger.wildcard, path)) {
        Polymer.Bind._computeEffect.call(this, path, value, effect);
      }
    },
    _annotatedComputationPathEffect: function _annotatedComputationPathEffect(path, value, effect) {
      if (Path.matches(effect.trigger.name, effect.trigger.wildcard, path)) {
        Polymer.Bind._annotatedComputationEffect.call(this, path, value, effect);
      }
    },
    linkPaths: function linkPaths(to, from) {
      this._boundPaths = this._boundPaths || {};
      if (from) {
        this._boundPaths[to] = from;
      } else {
        this.unlinkPaths(to);
      }
    },
    unlinkPaths: function unlinkPaths(path) {
      if (this._boundPaths) {
        delete this._boundPaths[path];
      }
    },
    _notifyBoundPaths: function _notifyBoundPaths(path, value) {
      for (var a in this._boundPaths) {
        var b = this._boundPaths[a];
        if (Path.isDescendant(a, path)) {
          this._notifyPath(Path.translate(a, b, path), value);
        } else if (Path.isDescendant(b, path)) {
          this._notifyPath(Path.translate(b, a, path), value);
        }
      }
    },
    _notifyPathUp: function _notifyPathUp(path, value) {
      var rootName = Path.root(path);
      var dashCaseName = Polymer.CaseMap.camelToDashCase(rootName);
      var eventName = dashCaseName + this._EVENT_CHANGED;
      this.fire(eventName, {
        path: path,
        value: value
      }, {
        bubbles: false,
        _useCache: Polymer.Settings.eventDataCache || !Polymer.Settings.isIE
      });
    },
    _EVENT_CHANGED: '-changed',
    notifySplices: function notifySplices(path, splices) {
      var info = {};
      var array = this._get(path, this, info);
      this._notifySplices(array, info.path, splices);
    },
    _notifySplices: function _notifySplices(array, path, splices) {
      var change = {
        keySplices: Polymer.Collection.applySplices(array, splices),
        indexSplices: splices
      };
      var splicesPath = path + '.splices';
      this._notifyPath(splicesPath, change);
      this._notifyPath(path + '.length', array.length);
      this.__data__[splicesPath] = {
        keySplices: null,
        indexSplices: null
      };
    },
    _notifySplice: function _notifySplice(array, path, index, added, removed) {
      this._notifySplices(array, path, [{
        index: index,
        addedCount: added,
        removed: removed,
        object: array,
        type: 'splice'
      }]);
    },
    push: function push(path) {
      var info = {};
      var array = this._get(path, this, info);
      var args = Array.prototype.slice.call(arguments, 1);
      var len = array.length;
      var ret = array.push.apply(array, args);
      if (args.length) {
        this._notifySplice(array, info.path, len, args.length, []);
      }
      return ret;
    },
    pop: function pop(path) {
      var info = {};
      var array = this._get(path, this, info);
      var hadLength = Boolean(array.length);
      var args = Array.prototype.slice.call(arguments, 1);
      var ret = array.pop.apply(array, args);
      if (hadLength) {
        this._notifySplice(array, info.path, array.length, 0, [ret]);
      }
      return ret;
    },
    splice: function splice(path, start) {
      var info = {};
      var array = this._get(path, this, info);
      if (start < 0) {
        start = array.length - Math.floor(-start);
      } else {
        start = Math.floor(start);
      }
      if (!start) {
        start = 0;
      }
      var args = Array.prototype.slice.call(arguments, 1);
      var ret = array.splice.apply(array, args);
      var addedCount = Math.max(args.length - 2, 0);
      if (addedCount || ret.length) {
        this._notifySplice(array, info.path, start, addedCount, ret);
      }
      return ret;
    },
    shift: function shift(path) {
      var info = {};
      var array = this._get(path, this, info);
      var hadLength = Boolean(array.length);
      var args = Array.prototype.slice.call(arguments, 1);
      var ret = array.shift.apply(array, args);
      if (hadLength) {
        this._notifySplice(array, info.path, 0, 0, [ret]);
      }
      return ret;
    },
    unshift: function unshift(path) {
      var info = {};
      var array = this._get(path, this, info);
      var args = Array.prototype.slice.call(arguments, 1);
      var ret = array.unshift.apply(array, args);
      if (args.length) {
        this._notifySplice(array, info.path, 0, args.length, []);
      }
      return ret;
    },
    prepareModelNotifyPath: function prepareModelNotifyPath(model) {
      this.mixin(model, {
        fire: Polymer.Base.fire,
        _getEvent: Polymer.Base._getEvent,
        __eventCache: Polymer.Base.__eventCache,
        notifyPath: Polymer.Base.notifyPath,
        _get: Polymer.Base._get,
        _EVENT_CHANGED: Polymer.Base._EVENT_CHANGED,
        _notifyPath: Polymer.Base._notifyPath,
        _notifyPathUp: Polymer.Base._notifyPathUp,
        _pathEffector: Polymer.Base._pathEffector,
        _annotationPathEffect: Polymer.Base._annotationPathEffect,
        _complexObserverPathEffect: Polymer.Base._complexObserverPathEffect,
        _annotatedComputationPathEffect: Polymer.Base._annotatedComputationPathEffect,
        _computePathEffect: Polymer.Base._computePathEffect,
        _notifyBoundPaths: Polymer.Base._notifyBoundPaths,
        _getPathParts: Polymer.Base._getPathParts
      });
    }
  });
})();Polymer.Base._addFeature({
  resolveUrl: function resolveUrl(url) {
    return Polymer.ResolveUrl.resolveUrl(url, this._importPath);
  }
});Polymer.CssParse = function () {
  return {
    parse: function parse(text) {
      text = this._clean(text);
      return this._parseCss(this._lex(text), text);
    },
    _clean: function _clean(cssText) {
      return cssText.replace(this._rx.comments, '').replace(this._rx.port, '');
    },
    _lex: function _lex(text) {
      var root = {
        start: 0,
        end: text.length
      };
      var n = root;
      for (var i = 0, l = text.length; i < l; i++) {
        switch (text[i]) {
          case this.OPEN_BRACE:
            if (!n.rules) {
              n.rules = [];
            }
            var p = n;
            var previous = p.rules[p.rules.length - 1];
            n = {
              start: i + 1,
              parent: p,
              previous: previous
            };
            p.rules.push(n);
            break;
          case this.CLOSE_BRACE:
            n.end = i + 1;
            n = n.parent || root;
            break;
        }
      }
      return root;
    },
    _parseCss: function _parseCss(node, text) {
      var t = text.substring(node.start, node.end - 1);
      node.parsedCssText = node.cssText = t.trim();
      if (node.parent) {
        var ss = node.previous ? node.previous.end : node.parent.start;
        t = text.substring(ss, node.start - 1);
        t = this._expandUnicodeEscapes(t);
        t = t.replace(this._rx.multipleSpaces, ' ');
        t = t.substring(t.lastIndexOf(';') + 1);
        var s = node.parsedSelector = node.selector = t.trim();
        node.atRule = s.indexOf(this.AT_START) === 0;
        if (node.atRule) {
          if (s.indexOf(this.MEDIA_START) === 0) {
            node.type = this.types.MEDIA_RULE;
          } else if (s.match(this._rx.keyframesRule)) {
            node.type = this.types.KEYFRAMES_RULE;
            node.keyframesName = node.selector.split(this._rx.multipleSpaces).pop();
          }
        } else {
          if (s.indexOf(this.VAR_START) === 0) {
            node.type = this.types.MIXIN_RULE;
          } else {
            node.type = this.types.STYLE_RULE;
          }
        }
      }
      var r$ = node.rules;
      if (r$) {
        for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
          this._parseCss(r, text);
        }
      }
      return node;
    },
    _expandUnicodeEscapes: function _expandUnicodeEscapes(s) {
      return s.replace(/\\([0-9a-f]{1,6})\s/gi, function () {
        var code = arguments[1],
            repeat = 6 - code.length;
        while (repeat--) {
          code = '0' + code;
        }
        return '\\' + code;
      });
    },
    stringify: function stringify(node, preserveProperties, text) {
      text = text || '';
      var cssText = '';
      if (node.cssText || node.rules) {
        var r$ = node.rules;
        if (r$ && !this._hasMixinRules(r$)) {
          for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
            cssText = this.stringify(r, preserveProperties, cssText);
          }
        } else {
          cssText = preserveProperties ? node.cssText : this.removeCustomProps(node.cssText);
          cssText = cssText.trim();
          if (cssText) {
            cssText = '  ' + cssText + '\n';
          }
        }
      }
      if (cssText) {
        if (node.selector) {
          text += node.selector + ' ' + this.OPEN_BRACE + '\n';
        }
        text += cssText;
        if (node.selector) {
          text += this.CLOSE_BRACE + '\n\n';
        }
      }
      return text;
    },
    _hasMixinRules: function _hasMixinRules(rules) {
      return rules[0].selector.indexOf(this.VAR_START) === 0;
    },
    removeCustomProps: function removeCustomProps(cssText) {
      cssText = this.removeCustomPropAssignment(cssText);
      return this.removeCustomPropApply(cssText);
    },
    removeCustomPropAssignment: function removeCustomPropAssignment(cssText) {
      return cssText.replace(this._rx.customProp, '').replace(this._rx.mixinProp, '');
    },
    removeCustomPropApply: function removeCustomPropApply(cssText) {
      return cssText.replace(this._rx.mixinApply, '').replace(this._rx.varApply, '');
    },
    types: {
      STYLE_RULE: 1,
      KEYFRAMES_RULE: 7,
      MEDIA_RULE: 4,
      MIXIN_RULE: 1000
    },
    OPEN_BRACE: '{',
    CLOSE_BRACE: '}',
    _rx: {
      comments: /\/\*[^*]*\*+([^\/*][^*]*\*+)*\//gim,
      port: /@import[^;]*;/gim,
      customProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,
      mixinProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,
      mixinApply: /@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,
      varApply: /[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,
      keyframesRule: /^@[^\s]*keyframes/,
      multipleSpaces: /\s+/g
    },
    VAR_START: '--',
    MEDIA_START: '@media',
    AT_START: '@'
  };
}();Polymer.StyleUtil = function () {
  var settings = Polymer.Settings;
  return {
    NATIVE_VARIABLES: Polymer.Settings.useNativeCSSProperties,
    MODULE_STYLES_SELECTOR: 'style, link[rel=import][type~=css], template',
    INCLUDE_ATTR: 'include',
    toCssText: function toCssText(rules, callback) {
      if (typeof rules === 'string') {
        rules = this.parser.parse(rules);
      }
      if (callback) {
        this.forEachRule(rules, callback);
      }
      return this.parser.stringify(rules, this.NATIVE_VARIABLES);
    },
    forRulesInStyles: function forRulesInStyles(styles, styleRuleCallback, keyframesRuleCallback) {
      if (styles) {
        for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
          this.forEachRuleInStyle(s, styleRuleCallback, keyframesRuleCallback);
        }
      }
    },
    forActiveRulesInStyles: function forActiveRulesInStyles(styles, styleRuleCallback, keyframesRuleCallback) {
      if (styles) {
        for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
          this.forEachRuleInStyle(s, styleRuleCallback, keyframesRuleCallback, true);
        }
      }
    },
    rulesForStyle: function rulesForStyle(style) {
      if (!style.__cssRules && style.textContent) {
        style.__cssRules = this.parser.parse(style.textContent);
      }
      return style.__cssRules;
    },
    isKeyframesSelector: function isKeyframesSelector(rule) {
      return rule.parent && rule.parent.type === this.ruleTypes.KEYFRAMES_RULE;
    },
    forEachRuleInStyle: function forEachRuleInStyle(style, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {
      var rules = this.rulesForStyle(style);
      var styleCallback, keyframeCallback;
      if (styleRuleCallback) {
        styleCallback = function styleCallback(rule) {
          styleRuleCallback(rule, style);
        };
      }
      if (keyframesRuleCallback) {
        keyframeCallback = function keyframeCallback(rule) {
          keyframesRuleCallback(rule, style);
        };
      }
      this.forEachRule(rules, styleCallback, keyframeCallback, onlyActiveRules);
    },
    forEachRule: function forEachRule(node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {
      if (!node) {
        return;
      }
      var skipRules = false;
      if (onlyActiveRules) {
        if (node.type === this.ruleTypes.MEDIA_RULE) {
          var matchMedia = node.selector.match(this.rx.MEDIA_MATCH);
          if (matchMedia) {
            if (!window.matchMedia(matchMedia[1]).matches) {
              skipRules = true;
            }
          }
        }
      }
      if (node.type === this.ruleTypes.STYLE_RULE) {
        styleRuleCallback(node);
      } else if (keyframesRuleCallback && node.type === this.ruleTypes.KEYFRAMES_RULE) {
        keyframesRuleCallback(node);
      } else if (node.type === this.ruleTypes.MIXIN_RULE) {
        skipRules = true;
      }
      var r$ = node.rules;
      if (r$ && !skipRules) {
        for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
          this.forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);
        }
      }
    },
    applyCss: function applyCss(cssText, moniker, target, contextNode) {
      var style = this.createScopeStyle(cssText, moniker);
      return this.applyStyle(style, target, contextNode);
    },
    applyStyle: function applyStyle(style, target, contextNode) {
      target = target || document.head;
      var after = contextNode && contextNode.nextSibling || target.firstChild;
      this.__lastHeadApplyNode = style;
      return target.insertBefore(style, after);
    },
    createScopeStyle: function createScopeStyle(cssText, moniker) {
      var style = document.createElement('style');
      if (moniker) {
        style.setAttribute('scope', moniker);
      }
      style.textContent = cssText;
      return style;
    },
    __lastHeadApplyNode: null,
    applyStylePlaceHolder: function applyStylePlaceHolder(moniker) {
      var placeHolder = document.createComment(' Shady DOM styles for ' + moniker + ' ');
      var after = this.__lastHeadApplyNode ? this.__lastHeadApplyNode.nextSibling : null;
      var scope = document.head;
      scope.insertBefore(placeHolder, after || scope.firstChild);
      this.__lastHeadApplyNode = placeHolder;
      return placeHolder;
    },
    cssFromModules: function cssFromModules(moduleIds, warnIfNotFound) {
      var modules = moduleIds.trim().split(' ');
      var cssText = '';
      for (var i = 0; i < modules.length; i++) {
        cssText += this.cssFromModule(modules[i], warnIfNotFound);
      }
      return cssText;
    },
    cssFromModule: function cssFromModule(moduleId, warnIfNotFound) {
      var m = Polymer.DomModule.import(moduleId);
      if (m && !m._cssText) {
        m._cssText = this.cssFromElement(m);
      }
      if (!m && warnIfNotFound) {
        console.warn('Could not find style data in module named', moduleId);
      }
      return m && m._cssText || '';
    },
    cssFromElement: function cssFromElement(element) {
      var cssText = '';
      var content = element.content || element;
      var e$ = Polymer.TreeApi.arrayCopy(content.querySelectorAll(this.MODULE_STYLES_SELECTOR));
      for (var i = 0, e; i < e$.length; i++) {
        e = e$[i];
        if (e.localName === 'template') {
          if (!e.hasAttribute('preserve-content')) {
            cssText += this.cssFromElement(e);
          }
        } else {
          if (e.localName === 'style') {
            var include = e.getAttribute(this.INCLUDE_ATTR);
            if (include) {
              cssText += this.cssFromModules(include, true);
            }
            e = e.__appliedElement || e;
            e.parentNode.removeChild(e);
            cssText += this.resolveCss(e.textContent, element.ownerDocument);
          } else if (e.import && e.import.body) {
            cssText += this.resolveCss(e.import.body.textContent, e.import);
          }
        }
      }
      return cssText;
    },
    styleIncludesToTemplate: function styleIncludesToTemplate(targetTemplate) {
      var styles = targetTemplate.content.querySelectorAll('style[include]');
      for (var i = 0, s; i < styles.length; i++) {
        s = styles[i];
        s.parentNode.insertBefore(this._includesToFragment(s.getAttribute('include')), s);
      }
    },
    _includesToFragment: function _includesToFragment(styleIncludes) {
      var includeArray = styleIncludes.trim().split(' ');
      var frag = document.createDocumentFragment();
      for (var i = 0; i < includeArray.length; i++) {
        var t = Polymer.DomModule.import(includeArray[i], 'template');
        if (t) {
          this._addStylesToFragment(frag, t.content);
        }
      }
      return frag;
    },
    _addStylesToFragment: function _addStylesToFragment(frag, source) {
      var s$ = source.querySelectorAll('style');
      for (var i = 0, s; i < s$.length; i++) {
        s = s$[i];
        var include = s.getAttribute('include');
        if (include) {
          frag.appendChild(this._includesToFragment(include));
        }
        if (s.textContent) {
          frag.appendChild(s.cloneNode(true));
        }
      }
    },
    isTargetedBuild: function isTargetedBuild(buildType) {
      return settings.useNativeShadow ? buildType === 'shadow' : buildType === 'shady';
    },
    cssBuildTypeForModule: function cssBuildTypeForModule(module) {
      var dm = Polymer.DomModule.import(module);
      if (dm) {
        return this.getCssBuildType(dm);
      }
    },
    getCssBuildType: function getCssBuildType(element) {
      return element.getAttribute('css-build');
    },
    _findMatchingParen: function _findMatchingParen(text, start) {
      var level = 0;
      for (var i = start, l = text.length; i < l; i++) {
        switch (text[i]) {
          case '(':
            level++;
            break;
          case ')':
            if (--level === 0) {
              return i;
            }
            break;
        }
      }
      return -1;
    },
    processVariableAndFallback: function processVariableAndFallback(str, callback) {
      var start = str.indexOf('var(');
      if (start === -1) {
        return callback(str, '', '', '');
      }
      var end = this._findMatchingParen(str, start + 3);
      var inner = str.substring(start + 4, end);
      var prefix = str.substring(0, start);
      var suffix = this.processVariableAndFallback(str.substring(end + 1), callback);
      var comma = inner.indexOf(',');
      if (comma === -1) {
        return callback(prefix, inner.trim(), '', suffix);
      }
      var value = inner.substring(0, comma).trim();
      var fallback = inner.substring(comma + 1).trim();
      return callback(prefix, value, fallback, suffix);
    },
    rx: {
      VAR_ASSIGN: /(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:([^;{]*)|{([^}]*)})(?:(?=[;\s}])|$)/gi,
      MIXIN_MATCH: /(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi,
      VAR_CONSUMED: /(--[\w-]+)\s*([:,;)]|$)/gi,
      ANIMATION_MATCH: /(animation\s*:)|(animation-name\s*:)/,
      MEDIA_MATCH: /@media[^(]*(\([^)]*\))/,
      IS_VAR: /^--/,
      BRACKETED: /\{[^}]*\}/g,
      HOST_PREFIX: '(?:^|[^.#[:])',
      HOST_SUFFIX: '($|[.:[\\s>+~])'
    },
    resolveCss: Polymer.ResolveUrl.resolveCss,
    parser: Polymer.CssParse,
    ruleTypes: Polymer.CssParse.types
  };
}();Polymer.StyleTransformer = function () {
  var styleUtil = Polymer.StyleUtil;
  var settings = Polymer.Settings;
  var api = {
    dom: function dom(node, scope, useAttr, shouldRemoveScope) {
      this._transformDom(node, scope || '', useAttr, shouldRemoveScope);
    },
    _transformDom: function _transformDom(node, selector, useAttr, shouldRemoveScope) {
      if (node.setAttribute) {
        this.element(node, selector, useAttr, shouldRemoveScope);
      }
      var c$ = Polymer.dom(node).childNodes;
      for (var i = 0; i < c$.length; i++) {
        this._transformDom(c$[i], selector, useAttr, shouldRemoveScope);
      }
    },
    element: function element(_element, scope, useAttr, shouldRemoveScope) {
      if (useAttr) {
        if (shouldRemoveScope) {
          _element.removeAttribute(SCOPE_NAME);
        } else {
          _element.setAttribute(SCOPE_NAME, scope);
        }
      } else {
        if (scope) {
          if (_element.classList) {
            if (shouldRemoveScope) {
              _element.classList.remove(SCOPE_NAME);
              _element.classList.remove(scope);
            } else {
              _element.classList.add(SCOPE_NAME);
              _element.classList.add(scope);
            }
          } else if (_element.getAttribute) {
            var c = _element.getAttribute(CLASS);
            if (shouldRemoveScope) {
              if (c) {
                _element.setAttribute(CLASS, c.replace(SCOPE_NAME, '').replace(scope, ''));
              }
            } else {
              _element.setAttribute(CLASS, (c ? c + ' ' : '') + SCOPE_NAME + ' ' + scope);
            }
          }
        }
      }
    },
    elementStyles: function elementStyles(element, callback) {
      var styles = element._styles;
      var cssText = '';
      var cssBuildType = element.__cssBuild;
      var passthrough = settings.useNativeShadow || cssBuildType === 'shady';
      var cb;
      if (passthrough) {
        var self = this;
        cb = function cb(rule) {
          rule.selector = self._slottedToContent(rule.selector);
          rule.selector = rule.selector.replace(ROOT, ':host > *');
          if (callback) {
            callback(rule);
          }
        };
      }
      for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
        var rules = styleUtil.rulesForStyle(s);
        cssText += passthrough ? styleUtil.toCssText(rules, cb) : this.css(rules, element.is, element.extends, callback, element._scopeCssViaAttr) + '\n\n';
      }
      return cssText.trim();
    },
    css: function css(rules, scope, ext, callback, useAttr) {
      var hostScope = this._calcHostScope(scope, ext);
      scope = this._calcElementScope(scope, useAttr);
      var self = this;
      return styleUtil.toCssText(rules, function (rule) {
        if (!rule.isScoped) {
          self.rule(rule, scope, hostScope);
          rule.isScoped = true;
        }
        if (callback) {
          callback(rule, scope, hostScope);
        }
      });
    },
    _calcElementScope: function _calcElementScope(scope, useAttr) {
      if (scope) {
        return useAttr ? CSS_ATTR_PREFIX + scope + CSS_ATTR_SUFFIX : CSS_CLASS_PREFIX + scope;
      } else {
        return '';
      }
    },
    _calcHostScope: function _calcHostScope(scope, ext) {
      return ext ? '[is=' + scope + ']' : scope;
    },
    rule: function rule(_rule, scope, hostScope) {
      this._transformRule(_rule, this._transformComplexSelector, scope, hostScope);
    },
    _transformRule: function _transformRule(rule, transformer, scope, hostScope) {
      rule.selector = rule.transformedSelector = this._transformRuleCss(rule, transformer, scope, hostScope);
    },
    _transformRuleCss: function _transformRuleCss(rule, transformer, scope, hostScope) {
      var p$ = rule.selector.split(COMPLEX_SELECTOR_SEP);
      if (!styleUtil.isKeyframesSelector(rule)) {
        for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
          p$[i] = transformer.call(this, p, scope, hostScope);
        }
      }
      return p$.join(COMPLEX_SELECTOR_SEP);
    },
    _transformComplexSelector: function _transformComplexSelector(selector, scope, hostScope) {
      var stop = false;
      var hostContext = false;
      var self = this;
      selector = selector.trim();
      selector = this._slottedToContent(selector);
      selector = selector.replace(ROOT, ':host > *');
      selector = selector.replace(CONTENT_START, HOST + ' $1');
      selector = selector.replace(SIMPLE_SELECTOR_SEP, function (m, c, s) {
        if (!stop) {
          var info = self._transformCompoundSelector(s, c, scope, hostScope);
          stop = stop || info.stop;
          hostContext = hostContext || info.hostContext;
          c = info.combinator;
          s = info.value;
        } else {
          s = s.replace(SCOPE_JUMP, ' ');
        }
        return c + s;
      });
      if (hostContext) {
        selector = selector.replace(HOST_CONTEXT_PAREN, function (m, pre, paren, post) {
          return pre + paren + ' ' + hostScope + post + COMPLEX_SELECTOR_SEP + ' ' + pre + hostScope + paren + post;
        });
      }
      return selector;
    },
    _transformCompoundSelector: function _transformCompoundSelector(selector, combinator, scope, hostScope) {
      var jumpIndex = selector.search(SCOPE_JUMP);
      var hostContext = false;
      if (selector.indexOf(HOST_CONTEXT) >= 0) {
        hostContext = true;
      } else if (selector.indexOf(HOST) >= 0) {
        selector = this._transformHostSelector(selector, hostScope);
      } else if (jumpIndex !== 0) {
        selector = scope ? this._transformSimpleSelector(selector, scope) : selector;
      }
      if (selector.indexOf(CONTENT) >= 0) {
        combinator = '';
      }
      var stop;
      if (jumpIndex >= 0) {
        selector = selector.replace(SCOPE_JUMP, ' ');
        stop = true;
      }
      return {
        value: selector,
        combinator: combinator,
        stop: stop,
        hostContext: hostContext
      };
    },
    _transformSimpleSelector: function _transformSimpleSelector(selector, scope) {
      var p$ = selector.split(PSEUDO_PREFIX);
      p$[0] += scope;
      return p$.join(PSEUDO_PREFIX);
    },
    _transformHostSelector: function _transformHostSelector(selector, hostScope) {
      var m = selector.match(HOST_PAREN);
      var paren = m && m[2].trim() || '';
      if (paren) {
        if (!paren[0].match(SIMPLE_SELECTOR_PREFIX)) {
          var typeSelector = paren.split(SIMPLE_SELECTOR_PREFIX)[0];
          if (typeSelector === hostScope) {
            return paren;
          } else {
            return SELECTOR_NO_MATCH;
          }
        } else {
          return selector.replace(HOST_PAREN, function (m, host, paren) {
            return hostScope + paren;
          });
        }
      } else {
        return selector.replace(HOST, hostScope);
      }
    },
    documentRule: function documentRule(rule) {
      rule.selector = rule.parsedSelector;
      this.normalizeRootSelector(rule);
      if (!settings.useNativeShadow) {
        this._transformRule(rule, this._transformDocumentSelector);
      }
    },
    normalizeRootSelector: function normalizeRootSelector(rule) {
      rule.selector = rule.selector.replace(ROOT, 'html');
    },
    _transformDocumentSelector: function _transformDocumentSelector(selector) {
      return selector.match(SCOPE_JUMP) ? this._transformComplexSelector(selector, SCOPE_DOC_SELECTOR) : this._transformSimpleSelector(selector.trim(), SCOPE_DOC_SELECTOR);
    },
    _slottedToContent: function _slottedToContent(cssText) {
      return cssText.replace(SLOTTED_PAREN, CONTENT + '> $1');
    },
    SCOPE_NAME: 'style-scope'
  };
  var SCOPE_NAME = api.SCOPE_NAME;
  var SCOPE_DOC_SELECTOR = ':not([' + SCOPE_NAME + '])' + ':not(.' + SCOPE_NAME + ')';
  var COMPLEX_SELECTOR_SEP = ',';
  var SIMPLE_SELECTOR_SEP = /(^|[\s>+~]+)((?:\[.+?\]|[^\s>+~=\[])+)/g;
  var SIMPLE_SELECTOR_PREFIX = /[[.:#*]/;
  var HOST = ':host';
  var ROOT = ':root';
  var HOST_PAREN = /(:host)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/;
  var HOST_CONTEXT = ':host-context';
  var HOST_CONTEXT_PAREN = /(.*)(?::host-context)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))(.*)/;
  var CONTENT = '::content';
  var SCOPE_JUMP = /::content|::shadow|\/deep\//;
  var CSS_CLASS_PREFIX = '.';
  var CSS_ATTR_PREFIX = '[' + SCOPE_NAME + '~=';
  var CSS_ATTR_SUFFIX = ']';
  var PSEUDO_PREFIX = ':';
  var CLASS = 'class';
  var CONTENT_START = new RegExp('^(' + CONTENT + ')');
  var SELECTOR_NO_MATCH = 'should_not_match';
  var SLOTTED_PAREN = /(?:::slotted)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/g;
  return api;
}();Polymer.StyleExtends = function () {
  var styleUtil = Polymer.StyleUtil;
  return {
    hasExtends: function hasExtends(cssText) {
      return Boolean(cssText.match(this.rx.EXTEND));
    },
    transform: function transform(style) {
      var rules = styleUtil.rulesForStyle(style);
      var self = this;
      styleUtil.forEachRule(rules, function (rule) {
        self._mapRuleOntoParent(rule);
        if (rule.parent) {
          var m;
          while (m = self.rx.EXTEND.exec(rule.cssText)) {
            var extend = m[1];
            var extendor = self._findExtendor(extend, rule);
            if (extendor) {
              self._extendRule(rule, extendor);
            }
          }
        }
        rule.cssText = rule.cssText.replace(self.rx.EXTEND, '');
      });
      return styleUtil.toCssText(rules, function (rule) {
        if (rule.selector.match(self.rx.STRIP)) {
          rule.cssText = '';
        }
      }, true);
    },
    _mapRuleOntoParent: function _mapRuleOntoParent(rule) {
      if (rule.parent) {
        var map = rule.parent.map || (rule.parent.map = {});
        var parts = rule.selector.split(',');
        for (var i = 0, p; i < parts.length; i++) {
          p = parts[i];
          map[p.trim()] = rule;
        }
        return map;
      }
    },
    _findExtendor: function _findExtendor(extend, rule) {
      return rule.parent && rule.parent.map && rule.parent.map[extend] || this._findExtendor(extend, rule.parent);
    },
    _extendRule: function _extendRule(target, source) {
      if (target.parent !== source.parent) {
        this._cloneAndAddRuleToParent(source, target.parent);
      }
      target.extends = target.extends || [];
      target.extends.push(source);
      source.selector = source.selector.replace(this.rx.STRIP, '');
      source.selector = (source.selector && source.selector + ',\n') + target.selector;
      if (source.extends) {
        source.extends.forEach(function (e) {
          this._extendRule(target, e);
        }, this);
      }
    },
    _cloneAndAddRuleToParent: function _cloneAndAddRuleToParent(rule, parent) {
      rule = Object.create(rule);
      rule.parent = parent;
      if (rule.extends) {
        rule.extends = rule.extends.slice();
      }
      parent.rules.push(rule);
    },
    rx: {
      EXTEND: /@extends\(([^)]*)\)\s*?;/gim,
      STRIP: /%[^,]*$/
    }
  };
}();Polymer.ApplyShim = function () {
  'use strict';

  var styleUtil = Polymer.StyleUtil;
  var MIXIN_MATCH = styleUtil.rx.MIXIN_MATCH;
  var VAR_ASSIGN = styleUtil.rx.VAR_ASSIGN;
  var BAD_VAR = /var\(\s*(--[^,]*),\s*(--[^)]*)\)/g;
  var APPLY_NAME_CLEAN = /;\s*/m;
  var INITIAL_INHERIT = /^\s*(initial)|(inherit)\s*$/;
  var MIXIN_VAR_SEP = '_-_';
  var mixinMap = {};
  function mapSet(name, props) {
    name = name.trim();
    mixinMap[name] = {
      properties: props,
      dependants: {}
    };
  }
  function mapGet(name) {
    name = name.trim();
    return mixinMap[name];
  }
  function replaceInitialOrInherit(property, value) {
    var match = INITIAL_INHERIT.exec(value);
    if (match) {
      if (match[1]) {
        value = ApplyShim._getInitialValueForProperty(property);
      } else {
        value = 'apply-shim-inherit';
      }
    }
    return value;
  }
  function cssTextToMap(text) {
    var props = text.split(';');
    var property, value;
    var out = {};
    for (var i = 0, p, sp; i < props.length; i++) {
      p = props[i];
      if (p) {
        sp = p.split(':');
        if (sp.length > 1) {
          property = sp[0].trim();
          value = replaceInitialOrInherit(property, sp.slice(1).join(':'));
          out[property] = value;
        }
      }
    }
    return out;
  }
  function invalidateMixinEntry(mixinEntry) {
    var currentProto = ApplyShim.__currentElementProto;
    var currentElementName = currentProto && currentProto.is;
    for (var elementName in mixinEntry.dependants) {
      if (elementName !== currentElementName) {
        mixinEntry.dependants[elementName].__applyShimInvalid = true;
      }
    }
  }
  function produceCssProperties(matchText, propertyName, valueProperty, valueMixin) {
    if (valueProperty) {
      styleUtil.processVariableAndFallback(valueProperty, function (prefix, value) {
        if (value && mapGet(value)) {
          valueMixin = '@apply ' + value + ';';
        }
      });
    }
    if (!valueMixin) {
      return matchText;
    }
    var mixinAsProperties = consumeCssProperties(valueMixin);
    var prefix = matchText.slice(0, matchText.indexOf('--'));
    var mixinValues = cssTextToMap(mixinAsProperties);
    var combinedProps = mixinValues;
    var mixinEntry = mapGet(propertyName);
    var oldProps = mixinEntry && mixinEntry.properties;
    if (oldProps) {
      combinedProps = Object.create(oldProps);
      combinedProps = Polymer.Base.mixin(combinedProps, mixinValues);
    } else {
      mapSet(propertyName, combinedProps);
    }
    var out = [];
    var p, v;
    var needToInvalidate = false;
    for (p in combinedProps) {
      v = mixinValues[p];
      if (v === undefined) {
        v = 'initial';
      }
      if (oldProps && !(p in oldProps)) {
        needToInvalidate = true;
      }
      out.push(propertyName + MIXIN_VAR_SEP + p + ': ' + v);
    }
    if (needToInvalidate) {
      invalidateMixinEntry(mixinEntry);
    }
    if (mixinEntry) {
      mixinEntry.properties = combinedProps;
    }
    if (valueProperty) {
      prefix = matchText + ';' + prefix;
    }
    return prefix + out.join('; ') + ';';
  }
  function fixVars(matchText, varA, varB) {
    return 'var(' + varA + ',' + 'var(' + varB + '))';
  }
  function atApplyToCssProperties(mixinName, fallbacks) {
    mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');
    var vars = [];
    var mixinEntry = mapGet(mixinName);
    if (!mixinEntry) {
      mapSet(mixinName, {});
      mixinEntry = mapGet(mixinName);
    }
    if (mixinEntry) {
      var currentProto = ApplyShim.__currentElementProto;
      if (currentProto) {
        mixinEntry.dependants[currentProto.is] = currentProto;
      }
      var p, parts, f;
      for (p in mixinEntry.properties) {
        f = fallbacks && fallbacks[p];
        parts = [p, ': var(', mixinName, MIXIN_VAR_SEP, p];
        if (f) {
          parts.push(',', f);
        }
        parts.push(')');
        vars.push(parts.join(''));
      }
    }
    return vars.join('; ');
  }
  function consumeCssProperties(text) {
    var m;
    while (m = MIXIN_MATCH.exec(text)) {
      var matchText = m[0];
      var mixinName = m[1];
      var idx = m.index;
      var applyPos = idx + matchText.indexOf('@apply');
      var afterApplyPos = idx + matchText.length;
      var textBeforeApply = text.slice(0, applyPos);
      var textAfterApply = text.slice(afterApplyPos);
      var defaults = cssTextToMap(textBeforeApply);
      var replacement = atApplyToCssProperties(mixinName, defaults);
      text = [textBeforeApply, replacement, textAfterApply].join('');
      MIXIN_MATCH.lastIndex = idx + replacement.length;
    }
    return text;
  }
  var ApplyShim = {
    _measureElement: null,
    _map: mixinMap,
    _separator: MIXIN_VAR_SEP,
    transform: function transform(styles, elementProto) {
      this.__currentElementProto = elementProto;
      styleUtil.forRulesInStyles(styles, this._boundFindDefinitions);
      styleUtil.forRulesInStyles(styles, this._boundFindApplications);
      if (elementProto) {
        elementProto.__applyShimInvalid = false;
      }
      this.__currentElementProto = null;
    },
    _findDefinitions: function _findDefinitions(rule) {
      var cssText = rule.parsedCssText;
      cssText = cssText.replace(BAD_VAR, fixVars);
      cssText = cssText.replace(VAR_ASSIGN, produceCssProperties);
      rule.cssText = cssText;
      if (rule.selector === ':root') {
        rule.selector = ':host > *';
      }
    },
    _findApplications: function _findApplications(rule) {
      rule.cssText = consumeCssProperties(rule.cssText);
    },
    transformRule: function transformRule(rule) {
      this._findDefinitions(rule);
      this._findApplications(rule);
    },
    _getInitialValueForProperty: function _getInitialValueForProperty(property) {
      if (!this._measureElement) {
        this._measureElement = document.createElement('meta');
        this._measureElement.style.all = 'initial';
        document.head.appendChild(this._measureElement);
      }
      return window.getComputedStyle(this._measureElement).getPropertyValue(property);
    }
  };
  ApplyShim._boundTransformRule = ApplyShim.transformRule.bind(ApplyShim);
  ApplyShim._boundFindDefinitions = ApplyShim._findDefinitions.bind(ApplyShim);
  ApplyShim._boundFindApplications = ApplyShim._findApplications.bind(ApplyShim);
  return ApplyShim;
}();(function () {
  var prepElement = Polymer.Base._prepElement;
  var nativeShadow = Polymer.Settings.useNativeShadow;
  var styleUtil = Polymer.StyleUtil;
  var styleTransformer = Polymer.StyleTransformer;
  var styleExtends = Polymer.StyleExtends;
  var applyShim = Polymer.ApplyShim;
  var settings = Polymer.Settings;
  Polymer.Base._addFeature({
    _prepElement: function _prepElement(element) {
      if (this._encapsulateStyle && this.__cssBuild !== 'shady') {
        styleTransformer.element(element, this.is, this._scopeCssViaAttr);
      }
      prepElement.call(this, element);
    },
    _prepStyles: function _prepStyles() {
      if (this._encapsulateStyle === undefined) {
        this._encapsulateStyle = !nativeShadow;
      }
      if (!nativeShadow) {
        this._scopeStyle = styleUtil.applyStylePlaceHolder(this.is);
      }
      this.__cssBuild = styleUtil.cssBuildTypeForModule(this.is);
    },
    _prepShimStyles: function _prepShimStyles() {
      if (this._template) {
        var hasTargetedCssBuild = styleUtil.isTargetedBuild(this.__cssBuild);
        if (settings.useNativeCSSProperties && this.__cssBuild === 'shadow' && hasTargetedCssBuild) {
          if (settings.preserveStyleIncludes) {
            styleUtil.styleIncludesToTemplate(this._template);
          }
          return;
        }
        this._styles = this._styles || this._collectStyles();
        if (settings.useNativeCSSProperties && !this.__cssBuild) {
          applyShim.transform(this._styles, this);
        }
        var cssText = settings.useNativeCSSProperties && hasTargetedCssBuild ? this._styles.length && this._styles[0].textContent.trim() : styleTransformer.elementStyles(this);
        this._prepStyleProperties();
        if (!this._needsStyleProperties() && cssText) {
          styleUtil.applyCss(cssText, this.is, nativeShadow ? this._template.content : null, this._scopeStyle);
        }
      } else {
        this._styles = [];
      }
    },
    _collectStyles: function _collectStyles() {
      var styles = [];
      var cssText = '',
          m$ = this.styleModules;
      if (m$) {
        for (var i = 0, l = m$.length, m; i < l && (m = m$[i]); i++) {
          cssText += styleUtil.cssFromModule(m);
        }
      }
      cssText += styleUtil.cssFromModule(this.is);
      var p = this._template && this._template.parentNode;
      if (this._template && (!p || p.id.toLowerCase() !== this.is)) {
        cssText += styleUtil.cssFromElement(this._template);
      }
      if (cssText) {
        var style = document.createElement('style');
        style.textContent = cssText;
        if (styleExtends.hasExtends(style.textContent)) {
          cssText = styleExtends.transform(style);
        }
        styles.push(style);
      }
      return styles;
    },
    _elementAdd: function _elementAdd(node) {
      if (this._encapsulateStyle) {
        if (node.__styleScoped) {
          node.__styleScoped = false;
        } else {
          styleTransformer.dom(node, this.is, this._scopeCssViaAttr);
        }
      }
    },
    _elementRemove: function _elementRemove(node) {
      if (this._encapsulateStyle) {
        styleTransformer.dom(node, this.is, this._scopeCssViaAttr, true);
      }
    },
    scopeSubtree: function scopeSubtree(container, shouldObserve) {
      if (nativeShadow) {
        return;
      }
      var self = this;
      var scopify = function scopify(node) {
        if (node.nodeType === Node.ELEMENT_NODE) {
          var className = node.getAttribute('class');
          node.setAttribute('class', self._scopeElementClass(node, className));
          var n$ = node.querySelectorAll('*');
          for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
            className = n.getAttribute('class');
            n.setAttribute('class', self._scopeElementClass(n, className));
          }
        }
      };
      scopify(container);
      if (shouldObserve) {
        var mo = new MutationObserver(function (mxns) {
          for (var i = 0, m; i < mxns.length && (m = mxns[i]); i++) {
            if (m.addedNodes) {
              for (var j = 0; j < m.addedNodes.length; j++) {
                scopify(m.addedNodes[j]);
              }
            }
          }
        });
        mo.observe(container, {
          childList: true,
          subtree: true
        });
        return mo;
      }
    }
  });
})();Polymer.StyleProperties = function () {
  'use strict';

  var matchesSelector = Polymer.DomApi.matchesSelector;
  var styleUtil = Polymer.StyleUtil;
  var styleTransformer = Polymer.StyleTransformer;
  var IS_IE = navigator.userAgent.match('Trident');
  var settings = Polymer.Settings;
  return {
    decorateStyles: function decorateStyles(styles, scope) {
      var self = this,
          props = {},
          keyframes = [],
          ruleIndex = 0;
      var scopeSelector = styleTransformer._calcHostScope(scope.is, scope.extends);
      styleUtil.forRulesInStyles(styles, function (rule, style) {
        self.decorateRule(rule);
        rule.index = ruleIndex++;
        self.whenHostOrRootRule(scope, rule, style, function (info) {
          if (rule.parent.type === styleUtil.ruleTypes.MEDIA_RULE) {
            scope.__notStyleScopeCacheable = true;
          }
          if (info.isHost) {
            var hostContextOrFunction = info.selector.split(' ').some(function (s) {
              return s.indexOf(scopeSelector) === 0 && s.length !== scopeSelector.length;
            });
            scope.__notStyleScopeCacheable = scope.__notStyleScopeCacheable || hostContextOrFunction;
          }
        });
        self.collectPropertiesInCssText(rule.propertyInfo.cssText, props);
      }, function onKeyframesRule(rule) {
        keyframes.push(rule);
      });
      styles._keyframes = keyframes;
      var names = [];
      for (var i in props) {
        names.push(i);
      }
      return names;
    },
    decorateRule: function decorateRule(rule) {
      if (rule.propertyInfo) {
        return rule.propertyInfo;
      }
      var info = {},
          properties = {};
      var hasProperties = this.collectProperties(rule, properties);
      if (hasProperties) {
        info.properties = properties;
        rule.rules = null;
      }
      info.cssText = this.collectCssText(rule);
      rule.propertyInfo = info;
      return info;
    },
    collectProperties: function collectProperties(rule, properties) {
      var info = rule.propertyInfo;
      if (info) {
        if (info.properties) {
          Polymer.Base.mixin(properties, info.properties);
          return true;
        }
      } else {
        var m,
            rx = this.rx.VAR_ASSIGN;
        var cssText = rule.parsedCssText;
        var value;
        var any;
        while (m = rx.exec(cssText)) {
          value = (m[2] || m[3]).trim();
          if (value !== 'inherit') {
            properties[m[1].trim()] = value;
          }
          any = true;
        }
        return any;
      }
    },
    collectCssText: function collectCssText(rule) {
      return this.collectConsumingCssText(rule.parsedCssText);
    },
    collectConsumingCssText: function collectConsumingCssText(cssText) {
      return cssText.replace(this.rx.BRACKETED, '').replace(this.rx.VAR_ASSIGN, '');
    },
    collectPropertiesInCssText: function collectPropertiesInCssText(cssText, props) {
      var m;
      while (m = this.rx.VAR_CONSUMED.exec(cssText)) {
        var name = m[1];
        if (m[2] !== ':') {
          props[name] = true;
        }
      }
    },
    reify: function reify(props) {
      var names = Object.getOwnPropertyNames(props);
      for (var i = 0, n; i < names.length; i++) {
        n = names[i];
        props[n] = this.valueForProperty(props[n], props);
      }
    },
    valueForProperty: function valueForProperty(property, props) {
      if (property) {
        if (property.indexOf(';') >= 0) {
          property = this.valueForProperties(property, props);
        } else {
          var self = this;
          var fn = function fn(prefix, value, fallback, suffix) {
            var propertyValue = self.valueForProperty(props[value], props);
            if (!propertyValue || propertyValue === 'initial') {
              propertyValue = self.valueForProperty(props[fallback] || fallback, props) || fallback;
            } else if (propertyValue === 'apply-shim-inherit') {
              propertyValue = 'inherit';
            }
            return prefix + (propertyValue || '') + suffix;
          };
          property = styleUtil.processVariableAndFallback(property, fn);
        }
      }
      return property && property.trim() || '';
    },
    valueForProperties: function valueForProperties(property, props) {
      var parts = property.split(';');
      for (var i = 0, p, m; i < parts.length; i++) {
        if (p = parts[i]) {
          this.rx.MIXIN_MATCH.lastIndex = 0;
          m = this.rx.MIXIN_MATCH.exec(p);
          if (m) {
            p = this.valueForProperty(props[m[1]], props);
          } else {
            var colon = p.indexOf(':');
            if (colon !== -1) {
              var pp = p.substring(colon);
              pp = pp.trim();
              pp = this.valueForProperty(pp, props) || pp;
              p = p.substring(0, colon) + pp;
            }
          }
          parts[i] = p && p.lastIndexOf(';') === p.length - 1 ? p.slice(0, -1) : p || '';
        }
      }
      return parts.join(';');
    },
    applyProperties: function applyProperties(rule, props) {
      var output = '';
      if (!rule.propertyInfo) {
        this.decorateRule(rule);
      }
      if (rule.propertyInfo.cssText) {
        output = this.valueForProperties(rule.propertyInfo.cssText, props);
      }
      rule.cssText = output;
    },
    applyKeyframeTransforms: function applyKeyframeTransforms(rule, keyframeTransforms) {
      var input = rule.cssText;
      var output = rule.cssText;
      if (rule.hasAnimations == null) {
        rule.hasAnimations = this.rx.ANIMATION_MATCH.test(input);
      }
      if (rule.hasAnimations) {
        var transform;
        if (rule.keyframeNamesToTransform == null) {
          rule.keyframeNamesToTransform = [];
          for (var keyframe in keyframeTransforms) {
            transform = keyframeTransforms[keyframe];
            output = transform(input);
            if (input !== output) {
              input = output;
              rule.keyframeNamesToTransform.push(keyframe);
            }
          }
        } else {
          for (var i = 0; i < rule.keyframeNamesToTransform.length; ++i) {
            transform = keyframeTransforms[rule.keyframeNamesToTransform[i]];
            input = transform(input);
          }
          output = input;
        }
      }
      rule.cssText = output;
    },
    propertyDataFromStyles: function propertyDataFromStyles(styles, element) {
      var props = {},
          self = this;
      var o = [];
      styleUtil.forActiveRulesInStyles(styles, function (rule) {
        if (!rule.propertyInfo) {
          self.decorateRule(rule);
        }
        var selectorToMatch = rule.transformedSelector || rule.parsedSelector;
        if (element && rule.propertyInfo.properties && selectorToMatch) {
          if (matchesSelector.call(element, selectorToMatch)) {
            self.collectProperties(rule, props);
            addToBitMask(rule.index, o);
          }
        }
      });
      return {
        properties: props,
        key: o
      };
    },
    _rootSelector: /:root|:host\s*>\s*\*/,
    _checkRoot: function _checkRoot(hostScope, selector) {
      return Boolean(selector.match(this._rootSelector)) || hostScope === 'html' && selector.indexOf('html') > -1;
    },
    whenHostOrRootRule: function whenHostOrRootRule(scope, rule, style, callback) {
      if (!rule.propertyInfo) {
        self.decorateRule(rule);
      }
      if (!rule.propertyInfo.properties) {
        return;
      }
      var hostScope = scope.is ? styleTransformer._calcHostScope(scope.is, scope.extends) : 'html';
      var parsedSelector = rule.parsedSelector;
      var isRoot = this._checkRoot(hostScope, parsedSelector);
      var isHost = !isRoot && parsedSelector.indexOf(':host') === 0;
      var cssBuild = scope.__cssBuild || style.__cssBuild;
      if (cssBuild === 'shady') {
        isRoot = parsedSelector === hostScope + ' > *.' + hostScope || parsedSelector.indexOf('html') > -1;
        isHost = !isRoot && parsedSelector.indexOf(hostScope) === 0;
      }
      if (!isRoot && !isHost) {
        return;
      }
      var selectorToMatch = hostScope;
      if (isHost) {
        if (settings.useNativeShadow && !rule.transformedSelector) {
          rule.transformedSelector = styleTransformer._transformRuleCss(rule, styleTransformer._transformComplexSelector, scope.is, hostScope);
        }
        selectorToMatch = rule.transformedSelector || rule.parsedSelector;
      }
      if (isRoot && hostScope === 'html') {
        selectorToMatch = rule.transformedSelector || rule.parsedSelector;
      }
      callback({
        selector: selectorToMatch,
        isHost: isHost,
        isRoot: isRoot
      });
    },
    hostAndRootPropertiesForScope: function hostAndRootPropertiesForScope(scope) {
      var hostProps = {},
          rootProps = {},
          self = this;
      styleUtil.forActiveRulesInStyles(scope._styles, function (rule, style) {
        self.whenHostOrRootRule(scope, rule, style, function (info) {
          var element = scope._element || scope;
          if (matchesSelector.call(element, info.selector)) {
            if (info.isHost) {
              self.collectProperties(rule, hostProps);
            } else {
              self.collectProperties(rule, rootProps);
            }
          }
        });
      });
      return {
        rootProps: rootProps,
        hostProps: hostProps
      };
    },
    transformStyles: function transformStyles(element, properties, scopeSelector) {
      var self = this;
      var hostSelector = styleTransformer._calcHostScope(element.is, element.extends);
      var rxHostSelector = element.extends ? '\\' + hostSelector.slice(0, -1) + '\\]' : hostSelector;
      var hostRx = new RegExp(this.rx.HOST_PREFIX + rxHostSelector + this.rx.HOST_SUFFIX);
      var keyframeTransforms = this._elementKeyframeTransforms(element, scopeSelector);
      return styleTransformer.elementStyles(element, function (rule) {
        self.applyProperties(rule, properties);
        if (!settings.useNativeShadow && !Polymer.StyleUtil.isKeyframesSelector(rule) && rule.cssText) {
          self.applyKeyframeTransforms(rule, keyframeTransforms);
          self._scopeSelector(rule, hostRx, hostSelector, element._scopeCssViaAttr, scopeSelector);
        }
      });
    },
    _elementKeyframeTransforms: function _elementKeyframeTransforms(element, scopeSelector) {
      var keyframesRules = element._styles._keyframes;
      var keyframeTransforms = {};
      if (!settings.useNativeShadow && keyframesRules) {
        for (var i = 0, keyframesRule = keyframesRules[i]; i < keyframesRules.length; keyframesRule = keyframesRules[++i]) {
          this._scopeKeyframes(keyframesRule, scopeSelector);
          keyframeTransforms[keyframesRule.keyframesName] = this._keyframesRuleTransformer(keyframesRule);
        }
      }
      return keyframeTransforms;
    },
    _keyframesRuleTransformer: function _keyframesRuleTransformer(keyframesRule) {
      return function (cssText) {
        return cssText.replace(keyframesRule.keyframesNameRx, keyframesRule.transformedKeyframesName);
      };
    },
    _scopeKeyframes: function _scopeKeyframes(rule, scopeId) {
      rule.keyframesNameRx = new RegExp(rule.keyframesName, 'g');
      rule.transformedKeyframesName = rule.keyframesName + '-' + scopeId;
      rule.transformedSelector = rule.transformedSelector || rule.selector;
      rule.selector = rule.transformedSelector.replace(rule.keyframesName, rule.transformedKeyframesName);
    },
    _scopeSelector: function _scopeSelector(rule, hostRx, hostSelector, viaAttr, scopeId) {
      rule.transformedSelector = rule.transformedSelector || rule.selector;
      var selector = rule.transformedSelector;
      var scope = viaAttr ? '[' + styleTransformer.SCOPE_NAME + '~=' + scopeId + ']' : '.' + scopeId;
      var parts = selector.split(',');
      for (var i = 0, l = parts.length, p; i < l && (p = parts[i]); i++) {
        parts[i] = p.match(hostRx) ? p.replace(hostSelector, scope) : scope + ' ' + p;
      }
      rule.selector = parts.join(',');
    },
    applyElementScopeSelector: function applyElementScopeSelector(element, selector, old, viaAttr) {
      var c = viaAttr ? element.getAttribute(styleTransformer.SCOPE_NAME) : element.getAttribute('class') || '';
      var v = old ? c.replace(old, selector) : (c ? c + ' ' : '') + this.XSCOPE_NAME + ' ' + selector;
      if (c !== v) {
        if (viaAttr) {
          element.setAttribute(styleTransformer.SCOPE_NAME, v);
        } else {
          element.setAttribute('class', v);
        }
      }
    },
    applyElementStyle: function applyElementStyle(element, properties, selector, style) {
      var cssText = style ? style.textContent || '' : this.transformStyles(element, properties, selector);
      var s = element._customStyle;
      if (s && !settings.useNativeShadow && s !== style) {
        s._useCount--;
        if (s._useCount <= 0 && s.parentNode) {
          s.parentNode.removeChild(s);
        }
      }
      if (settings.useNativeShadow) {
        if (element._customStyle) {
          element._customStyle.textContent = cssText;
          style = element._customStyle;
        } else if (cssText) {
          style = styleUtil.applyCss(cssText, selector, element.root, element._scopeStyle);
        }
      } else {
        if (!style) {
          if (cssText) {
            style = styleUtil.applyCss(cssText, selector, null, element._scopeStyle);
          }
        } else if (!style.parentNode) {
          if (IS_IE && cssText.indexOf('@media') > -1) {
            style.textContent = cssText;
          }
          styleUtil.applyStyle(style, null, element._scopeStyle);
        }
      }
      if (style) {
        style._useCount = style._useCount || 0;
        if (element._customStyle != style) {
          style._useCount++;
        }
        element._customStyle = style;
      }
      return style;
    },
    mixinCustomStyle: function mixinCustomStyle(props, customStyle) {
      var v;
      for (var i in customStyle) {
        v = customStyle[i];
        if (v || v === 0) {
          props[i] = v;
        }
      }
    },
    updateNativeStyleProperties: function updateNativeStyleProperties(element, properties) {
      var oldPropertyNames = element.__customStyleProperties;
      if (oldPropertyNames) {
        for (var i = 0; i < oldPropertyNames.length; i++) {
          element.style.removeProperty(oldPropertyNames[i]);
        }
      }
      var propertyNames = [];
      for (var p in properties) {
        if (properties[p] !== null) {
          element.style.setProperty(p, properties[p]);
          propertyNames.push(p);
        }
      }
      element.__customStyleProperties = propertyNames;
    },
    rx: styleUtil.rx,
    XSCOPE_NAME: 'x-scope'
  };
  function addToBitMask(n, bits) {
    var o = parseInt(n / 32);
    var v = 1 << n % 32;
    bits[o] = (bits[o] || 0) | v;
  }
}();(function () {
  Polymer.StyleCache = function () {
    this.cache = {};
  };
  Polymer.StyleCache.prototype = {
    MAX: 100,
    store: function store(is, data, keyValues, keyStyles) {
      data.keyValues = keyValues;
      data.styles = keyStyles;
      var s$ = this.cache[is] = this.cache[is] || [];
      s$.push(data);
      if (s$.length > this.MAX) {
        s$.shift();
      }
    },
    retrieve: function retrieve(is, keyValues, keyStyles) {
      var cache = this.cache[is];
      if (cache) {
        for (var i = cache.length - 1, data; i >= 0; i--) {
          data = cache[i];
          if (keyStyles === data.styles && this._objectsEqual(keyValues, data.keyValues)) {
            return data;
          }
        }
      }
    },
    clear: function clear() {
      this.cache = {};
    },
    _objectsEqual: function _objectsEqual(target, source) {
      var t, s;
      for (var i in target) {
        t = target[i], s = source[i];
        if (!((typeof t === 'undefined' ? 'undefined' : _typeof(t)) === 'object' && t ? this._objectsStrictlyEqual(t, s) : t === s)) {
          return false;
        }
      }
      if (Array.isArray(target)) {
        return target.length === source.length;
      }
      return true;
    },
    _objectsStrictlyEqual: function _objectsStrictlyEqual(target, source) {
      return this._objectsEqual(target, source) && this._objectsEqual(source, target);
    }
  };
})();Polymer.StyleDefaults = function () {
  var styleProperties = Polymer.StyleProperties;
  var StyleCache = Polymer.StyleCache;
  var nativeVariables = Polymer.Settings.useNativeCSSProperties;
  var api = {
    _styles: [],
    _properties: null,
    customStyle: {},
    _styleCache: new StyleCache(),
    _element: Polymer.DomApi.wrap(document.documentElement),
    addStyle: function addStyle(style) {
      this._styles.push(style);
      this._properties = null;
    },
    get _styleProperties() {
      if (!this._properties) {
        styleProperties.decorateStyles(this._styles, this);
        this._styles._scopeStyleProperties = null;
        this._properties = styleProperties.hostAndRootPropertiesForScope(this).rootProps;
        styleProperties.mixinCustomStyle(this._properties, this.customStyle);
        styleProperties.reify(this._properties);
      }
      return this._properties;
    },
    hasStyleProperties: function hasStyleProperties() {
      return Boolean(this._properties);
    },
    _needsStyleProperties: function _needsStyleProperties() {},
    _computeStyleProperties: function _computeStyleProperties() {
      return this._styleProperties;
    },
    updateStyles: function updateStyles(properties) {
      this._properties = null;
      if (properties) {
        Polymer.Base.mixin(this.customStyle, properties);
      }
      this._styleCache.clear();
      for (var i = 0, s; i < this._styles.length; i++) {
        s = this._styles[i];
        s = s.__importElement || s;
        s._apply();
      }
      if (nativeVariables) {
        styleProperties.updateNativeStyleProperties(document.documentElement, this.customStyle);
      }
    }
  };
  return api;
}();(function () {
  'use strict';

  var _serializeValueToAttribute = Polymer.Base.serializeValueToAttribute;
  var propertyUtils = Polymer.StyleProperties;
  var styleTransformer = Polymer.StyleTransformer;
  var styleDefaults = Polymer.StyleDefaults;
  var nativeShadow = Polymer.Settings.useNativeShadow;
  var nativeVariables = Polymer.Settings.useNativeCSSProperties;
  Polymer.Base._addFeature({
    _prepStyleProperties: function _prepStyleProperties() {
      if (!nativeVariables) {
        this._ownStylePropertyNames = this._styles && this._styles.length ? propertyUtils.decorateStyles(this._styles, this) : null;
      }
    },
    customStyle: null,
    getComputedStyleValue: function getComputedStyleValue(property) {
      if (!nativeVariables && !this._styleProperties) {
        this._computeStyleProperties();
      }
      return !nativeVariables && this._styleProperties && this._styleProperties[property] || getComputedStyle(this).getPropertyValue(property);
    },
    _setupStyleProperties: function _setupStyleProperties() {
      this.customStyle = {};
      this._styleCache = null;
      this._styleProperties = null;
      this._scopeSelector = null;
      this._ownStyleProperties = null;
      this._customStyle = null;
    },
    _needsStyleProperties: function _needsStyleProperties() {
      return Boolean(!nativeVariables && this._ownStylePropertyNames && this._ownStylePropertyNames.length);
    },
    _validateApplyShim: function _validateApplyShim() {
      if (this.__applyShimInvalid) {
        Polymer.ApplyShim.transform(this._styles, this.__proto__);
        var cssText = styleTransformer.elementStyles(this);
        if (nativeShadow) {
          var templateStyle = this._template.content.querySelector('style');
          if (templateStyle) {
            templateStyle.textContent = cssText;
          }
        } else {
          var shadyStyle = this._scopeStyle && this._scopeStyle.nextSibling;
          if (shadyStyle) {
            shadyStyle.textContent = cssText;
          }
        }
      }
    },
    _beforeAttached: function _beforeAttached() {
      if ((!this._scopeSelector || this.__stylePropertiesInvalid) && this._needsStyleProperties()) {
        this.__stylePropertiesInvalid = false;
        this._updateStyleProperties();
      }
    },
    _findStyleHost: function _findStyleHost() {
      var e = this,
          root;
      while (root = Polymer.dom(e).getOwnerRoot()) {
        if (Polymer.isInstance(root.host)) {
          return root.host;
        }
        e = root.host;
      }
      return styleDefaults;
    },
    _updateStyleProperties: function _updateStyleProperties() {
      var info,
          scope = this._findStyleHost();
      if (!scope._styleProperties) {
        scope._computeStyleProperties();
      }
      if (!scope._styleCache) {
        scope._styleCache = new Polymer.StyleCache();
      }
      var scopeData = propertyUtils.propertyDataFromStyles(scope._styles, this);
      var scopeCacheable = !this.__notStyleScopeCacheable;
      if (scopeCacheable) {
        scopeData.key.customStyle = this.customStyle;
        info = scope._styleCache.retrieve(this.is, scopeData.key, this._styles);
      }
      var scopeCached = Boolean(info);
      if (scopeCached) {
        this._styleProperties = info._styleProperties;
      } else {
        this._computeStyleProperties(scopeData.properties);
      }
      this._computeOwnStyleProperties();
      if (!scopeCached) {
        info = styleCache.retrieve(this.is, this._ownStyleProperties, this._styles);
      }
      var globalCached = Boolean(info) && !scopeCached;
      var style = this._applyStyleProperties(info);
      if (!scopeCached) {
        style = style && nativeShadow ? style.cloneNode(true) : style;
        info = {
          style: style,
          _scopeSelector: this._scopeSelector,
          _styleProperties: this._styleProperties
        };
        if (scopeCacheable) {
          scopeData.key.customStyle = {};
          this.mixin(scopeData.key.customStyle, this.customStyle);
          scope._styleCache.store(this.is, info, scopeData.key, this._styles);
        }
        if (!globalCached) {
          styleCache.store(this.is, Object.create(info), this._ownStyleProperties, this._styles);
        }
      }
    },
    _computeStyleProperties: function _computeStyleProperties(scopeProps) {
      var scope = this._findStyleHost();
      if (!scope._styleProperties) {
        scope._computeStyleProperties();
      }
      var props = Object.create(scope._styleProperties);
      var hostAndRootProps = propertyUtils.hostAndRootPropertiesForScope(this);
      this.mixin(props, hostAndRootProps.hostProps);
      scopeProps = scopeProps || propertyUtils.propertyDataFromStyles(scope._styles, this).properties;
      this.mixin(props, scopeProps);
      this.mixin(props, hostAndRootProps.rootProps);
      propertyUtils.mixinCustomStyle(props, this.customStyle);
      propertyUtils.reify(props);
      this._styleProperties = props;
    },
    _computeOwnStyleProperties: function _computeOwnStyleProperties() {
      var props = {};
      for (var i = 0, n; i < this._ownStylePropertyNames.length; i++) {
        n = this._ownStylePropertyNames[i];
        props[n] = this._styleProperties[n];
      }
      this._ownStyleProperties = props;
    },
    _scopeCount: 0,
    _applyStyleProperties: function _applyStyleProperties(info) {
      var oldScopeSelector = this._scopeSelector;
      this._scopeSelector = info ? info._scopeSelector : this.is + '-' + this.__proto__._scopeCount++;
      var style = propertyUtils.applyElementStyle(this, this._styleProperties, this._scopeSelector, info && info.style);
      if (!nativeShadow) {
        propertyUtils.applyElementScopeSelector(this, this._scopeSelector, oldScopeSelector, this._scopeCssViaAttr);
      }
      return style;
    },
    serializeValueToAttribute: function serializeValueToAttribute(value, attribute, node) {
      node = node || this;
      if (attribute === 'class' && !nativeShadow) {
        var host = node === this ? this.domHost || this.dataHost : this;
        if (host) {
          value = host._scopeElementClass(node, value);
        }
      }
      node = this.shadyRoot && this.shadyRoot._hasDistributed ? Polymer.dom(node) : node;
      _serializeValueToAttribute.call(this, value, attribute, node);
    },
    _scopeElementClass: function _scopeElementClass(element, selector) {
      if (!nativeShadow && !this._scopeCssViaAttr) {
        selector = (selector ? selector + ' ' : '') + SCOPE_NAME + ' ' + this.is + (element._scopeSelector ? ' ' + XSCOPE_NAME + ' ' + element._scopeSelector : '');
      }
      return selector;
    },
    updateStyles: function updateStyles(properties) {
      if (properties) {
        this.mixin(this.customStyle, properties);
      }
      if (nativeVariables) {
        propertyUtils.updateNativeStyleProperties(this, this.customStyle);
      } else {
        if (this.isAttached) {
          if (this._needsStyleProperties()) {
            this._updateStyleProperties();
          } else {
            this._styleProperties = null;
          }
        } else {
          this.__stylePropertiesInvalid = true;
        }
        if (this._styleCache) {
          this._styleCache.clear();
        }
        this._updateRootStyles();
      }
    },
    _updateRootStyles: function _updateRootStyles(root) {
      root = root || this.root;
      var c$ = Polymer.dom(root)._query(function (e) {
        return e.shadyRoot || e.shadowRoot;
      });
      for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
        if (c.updateStyles) {
          c.updateStyles();
        }
      }
    }
  });
  Polymer.updateStyles = function (properties) {
    styleDefaults.updateStyles(properties);
    Polymer.Base._updateRootStyles(document);
  };
  var styleCache = new Polymer.StyleCache();
  Polymer.customStyleCache = styleCache;
  var SCOPE_NAME = styleTransformer.SCOPE_NAME;
  var XSCOPE_NAME = propertyUtils.XSCOPE_NAME;
})();Polymer.Base._addFeature({
  _registerFeatures: function _registerFeatures() {
    this._prepIs();
    if (this.factoryImpl) {
      this._prepConstructor();
    }
    this._prepStyles();
  },
  _finishRegisterFeatures: function _finishRegisterFeatures() {
    this._prepTemplate();
    this._prepShimStyles();
    this._prepAnnotations();
    this._prepEffects();
    this._prepBehaviors();
    this._prepPropertyInfo();
    this._prepBindings();
    this._prepShady();
  },
  _prepBehavior: function _prepBehavior(b) {
    this._addPropertyEffects(b.properties);
    this._addComplexObserverEffects(b.observers);
    this._addHostAttributes(b.hostAttributes);
  },
  _initFeatures: function _initFeatures() {
    this._setupGestures();
    this._setupConfigure(this.__data__);
    this._setupStyleProperties();
    this._setupDebouncers();
    this._setupShady();
    this._registerHost();
    if (this._template) {
      this._validateApplyShim();
      this._poolContent();
      this._beginHosting();
      this._stampTemplate();
      this._endHosting();
      this._marshalAnnotationReferences();
    }
    this._marshalInstanceEffects();
    this._marshalBehaviors();
    this._marshalHostAttributes();
    this._marshalAttributes();
    this._tryReady();
  },
  _marshalBehavior: function _marshalBehavior(b) {
    if (b.listeners) {
      this._listenListeners(b.listeners);
    }
  }
});(function () {
  var propertyUtils = Polymer.StyleProperties;
  var styleUtil = Polymer.StyleUtil;
  var cssParse = Polymer.CssParse;
  var styleDefaults = Polymer.StyleDefaults;
  var styleTransformer = Polymer.StyleTransformer;
  var applyShim = Polymer.ApplyShim;
  var debounce = Polymer.Debounce;
  var settings = Polymer.Settings;
  var updateDebouncer;
  Polymer({
    is: 'custom-style',
    extends: 'style',
    _template: null,
    properties: { include: String },
    ready: function ready() {
      this.__appliedElement = this.__appliedElement || this;
      this.__cssBuild = styleUtil.getCssBuildType(this);
      if (this.__appliedElement !== this) {
        this.__appliedElement.__cssBuild = this.__cssBuild;
      }
      this._tryApply();
    },
    attached: function attached() {
      this._tryApply();
    },
    _tryApply: function _tryApply() {
      if (!this._appliesToDocument) {
        if (this.parentNode && this.parentNode.localName !== 'dom-module') {
          this._appliesToDocument = true;
          var e = this.__appliedElement;
          if (!settings.useNativeCSSProperties) {
            this.__needsUpdateStyles = styleDefaults.hasStyleProperties();
            styleDefaults.addStyle(e);
          }
          if (e.textContent || this.include) {
            this._apply(true);
          } else {
            var self = this;
            var observer = new MutationObserver(function () {
              observer.disconnect();
              self._apply(true);
            });
            observer.observe(e, { childList: true });
          }
        }
      }
    },
    _updateStyles: function _updateStyles() {
      Polymer.updateStyles();
    },
    _apply: function _apply(initialApply) {
      var e = this.__appliedElement;
      if (this.include) {
        e.textContent = styleUtil.cssFromModules(this.include, true) + e.textContent;
      }
      if (!e.textContent) {
        return;
      }
      var buildType = this.__cssBuild;
      var targetedBuild = styleUtil.isTargetedBuild(buildType);
      if (settings.useNativeCSSProperties && targetedBuild) {
        return;
      }
      var styleRules = styleUtil.rulesForStyle(e);
      if (!targetedBuild) {
        styleUtil.forEachRule(styleRules, function (rule) {
          styleTransformer.documentRule(rule);
        });
        if (settings.useNativeCSSProperties && !buildType) {
          applyShim.transform([e]);
        }
      }
      if (settings.useNativeCSSProperties) {
        e.textContent = styleUtil.toCssText(styleRules);
      } else {
        var self = this;
        var fn = function fn() {
          self._flushCustomProperties();
        };
        if (initialApply) {
          Polymer.RenderStatus.whenReady(fn);
        } else {
          fn();
        }
      }
    },
    _flushCustomProperties: function _flushCustomProperties() {
      if (this.__needsUpdateStyles) {
        this.__needsUpdateStyles = false;
        updateDebouncer = debounce(updateDebouncer, this._updateStyles);
      } else {
        this._applyCustomProperties();
      }
    },
    _applyCustomProperties: function _applyCustomProperties() {
      var element = this.__appliedElement;
      this._computeStyleProperties();
      var props = this._styleProperties;
      var rules = styleUtil.rulesForStyle(element);
      if (!rules) {
        return;
      }
      element.textContent = styleUtil.toCssText(rules, function (rule) {
        var css = rule.cssText = rule.parsedCssText;
        if (rule.propertyInfo && rule.propertyInfo.cssText) {
          css = cssParse.removeCustomPropAssignment(css);
          rule.cssText = propertyUtils.valueForProperties(css, props);
        }
      });
    }
  });
})();Polymer.Templatizer = {
  properties: { __hideTemplateChildren__: { observer: '_showHideChildren' } },
  _instanceProps: Polymer.nob,
  _parentPropPrefix: '_parent_',
  templatize: function templatize(template) {
    this._templatized = template;
    if (!template._content) {
      template._content = template.content;
    }
    if (template._content._ctor) {
      this.ctor = template._content._ctor;
      this._prepParentProperties(this.ctor.prototype, template);
      return;
    }
    var archetype = Object.create(Polymer.Base);
    this._customPrepAnnotations(archetype, template);
    this._prepParentProperties(archetype, template);
    archetype._prepEffects();
    this._customPrepEffects(archetype);
    archetype._prepBehaviors();
    archetype._prepPropertyInfo();
    archetype._prepBindings();
    archetype._notifyPathUp = this._notifyPathUpImpl;
    archetype._scopeElementClass = this._scopeElementClassImpl;
    archetype.listen = this._listenImpl;
    archetype._showHideChildren = this._showHideChildrenImpl;
    archetype.__setPropertyOrig = this.__setProperty;
    archetype.__setProperty = this.__setPropertyImpl;
    var _constructor = this._constructorImpl;
    var ctor = function TemplateInstance(model, host) {
      _constructor.call(this, model, host);
    };
    ctor.prototype = archetype;
    archetype.constructor = ctor;
    template._content._ctor = ctor;
    this.ctor = ctor;
  },
  _getRootDataHost: function _getRootDataHost() {
    return this.dataHost && this.dataHost._rootDataHost || this.dataHost;
  },
  _showHideChildrenImpl: function _showHideChildrenImpl(hide) {
    var c = this._children;
    for (var i = 0; i < c.length; i++) {
      var n = c[i];
      if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
        if (n.nodeType === Node.TEXT_NODE) {
          if (hide) {
            n.__polymerTextContent__ = n.textContent;
            n.textContent = '';
          } else {
            n.textContent = n.__polymerTextContent__;
          }
        } else if (n.style) {
          if (hide) {
            n.__polymerDisplay__ = n.style.display;
            n.style.display = 'none';
          } else {
            n.style.display = n.__polymerDisplay__;
          }
        }
      }
      n.__hideTemplateChildren__ = hide;
    }
  },
  __setPropertyImpl: function __setPropertyImpl(property, value, fromAbove, node) {
    if (node && node.__hideTemplateChildren__ && property == 'textContent') {
      property = '__polymerTextContent__';
    }
    this.__setPropertyOrig(property, value, fromAbove, node);
  },
  _debounceTemplate: function _debounceTemplate(fn) {
    Polymer.dom.addDebouncer(this.debounce('_debounceTemplate', fn));
  },
  _flushTemplates: function _flushTemplates() {
    Polymer.dom.flush();
  },
  _customPrepEffects: function _customPrepEffects(archetype) {
    var parentProps = archetype._parentProps;
    for (var prop in parentProps) {
      archetype._addPropertyEffect(prop, 'function', this._createHostPropEffector(prop));
    }
    for (prop in this._instanceProps) {
      archetype._addPropertyEffect(prop, 'function', this._createInstancePropEffector(prop));
    }
  },
  _customPrepAnnotations: function _customPrepAnnotations(archetype, template) {
    archetype._template = template;
    var c = template._content;
    if (!c._notes) {
      var rootDataHost = archetype._rootDataHost;
      if (rootDataHost) {
        Polymer.Annotations.prepElement = function () {
          rootDataHost._prepElement();
        };
      }
      c._notes = Polymer.Annotations.parseAnnotations(template);
      Polymer.Annotations.prepElement = null;
      this._processAnnotations(c._notes);
    }
    archetype._notes = c._notes;
    archetype._parentProps = c._parentProps;
  },
  _prepParentProperties: function _prepParentProperties(archetype, template) {
    var parentProps = this._parentProps = archetype._parentProps;
    if (this._forwardParentProp && parentProps) {
      var proto = archetype._parentPropProto;
      var prop;
      if (!proto) {
        for (prop in this._instanceProps) {
          delete parentProps[prop];
        }
        proto = archetype._parentPropProto = Object.create(null);
        if (template != this) {
          Polymer.Bind.prepareModel(proto);
          Polymer.Base.prepareModelNotifyPath(proto);
        }
        for (prop in parentProps) {
          var parentProp = this._parentPropPrefix + prop;
          var effects = [{
            kind: 'function',
            effect: this._createForwardPropEffector(prop),
            fn: Polymer.Bind._functionEffect
          }, {
            kind: 'notify',
            fn: Polymer.Bind._notifyEffect,
            effect: { event: Polymer.CaseMap.camelToDashCase(parentProp) + '-changed' }
          }];
          proto._propertyEffects = proto._propertyEffects || {};
          proto._propertyEffects[parentProp] = effects;
          Polymer.Bind._createAccessors(proto, parentProp, effects);
        }
      }
      var self = this;
      if (template != this) {
        Polymer.Bind.prepareInstance(template);
        template._forwardParentProp = function (source, value) {
          self._forwardParentProp(source, value);
        };
      }
      this._extendTemplate(template, proto);
      template._pathEffector = function (path, value, fromAbove) {
        return self._pathEffectorImpl(path, value, fromAbove);
      };
    }
  },
  _createForwardPropEffector: function _createForwardPropEffector(prop) {
    return function (source, value) {
      this._forwardParentProp(prop, value);
    };
  },
  _createHostPropEffector: function _createHostPropEffector(prop) {
    var prefix = this._parentPropPrefix;
    return function (source, value) {
      this.dataHost._templatized[prefix + prop] = value;
    };
  },
  _createInstancePropEffector: function _createInstancePropEffector(prop) {
    return function (source, value, old, fromAbove) {
      if (!fromAbove) {
        this.dataHost._forwardInstanceProp(this, prop, value);
      }
    };
  },
  _extendTemplate: function _extendTemplate(template, proto) {
    var n$ = Object.getOwnPropertyNames(proto);
    if (proto._propertySetter) {
      template._propertySetter = proto._propertySetter;
    }
    for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
      var val = template[n];
      if (val && n == '_propertyEffects') {
        var pe = Polymer.Base.mixin({}, val);
        template._propertyEffects = Polymer.Base.mixin(pe, proto._propertyEffects);
      } else {
        var pd = Object.getOwnPropertyDescriptor(proto, n);
        Object.defineProperty(template, n, pd);
        if (val !== undefined) {
          template._propertySetter(n, val);
        }
      }
    }
  },
  _showHideChildren: function _showHideChildren(hidden) {},
  _forwardInstancePath: function _forwardInstancePath(inst, path, value) {},
  _forwardInstanceProp: function _forwardInstanceProp(inst, prop, value) {},
  _notifyPathUpImpl: function _notifyPathUpImpl(path, value) {
    var dataHost = this.dataHost;
    var root = Polymer.Path.root(path);
    dataHost._forwardInstancePath.call(dataHost, this, path, value);
    if (root in dataHost._parentProps) {
      dataHost._templatized._notifyPath(dataHost._parentPropPrefix + path, value);
    }
  },
  _pathEffectorImpl: function _pathEffectorImpl(path, value, fromAbove) {
    if (this._forwardParentPath) {
      if (path.indexOf(this._parentPropPrefix) === 0) {
        var subPath = path.substring(this._parentPropPrefix.length);
        var model = Polymer.Path.root(subPath);
        if (model in this._parentProps) {
          this._forwardParentPath(subPath, value);
        }
      }
    }
    Polymer.Base._pathEffector.call(this._templatized, path, value, fromAbove);
  },
  _constructorImpl: function _constructorImpl(model, host) {
    this._rootDataHost = host._getRootDataHost();
    this._setupConfigure(model);
    this._registerHost(host);
    this._beginHosting();
    this.root = this.instanceTemplate(this._template);
    this.root.__noContent = !this._notes._hasContent;
    this.root.__styleScoped = true;
    this._endHosting();
    this._marshalAnnotatedNodes();
    this._marshalInstanceEffects();
    this._marshalAnnotatedListeners();
    var children = [];
    for (var n = this.root.firstChild; n; n = n.nextSibling) {
      children.push(n);
      n._templateInstance = this;
    }
    this._children = children;
    if (host.__hideTemplateChildren__) {
      this._showHideChildren(true);
    }
    this._tryReady();
  },
  _listenImpl: function _listenImpl(node, eventName, methodName) {
    var model = this;
    var host = this._rootDataHost;
    var handler = host._createEventHandler(node, eventName, methodName);
    var decorated = function decorated(e) {
      e.model = model;
      handler(e);
    };
    host._listen(node, eventName, decorated);
  },
  _scopeElementClassImpl: function _scopeElementClassImpl(node, value) {
    var host = this._rootDataHost;
    if (host) {
      return host._scopeElementClass(node, value);
    }
    return value;
  },
  stamp: function stamp(model) {
    model = model || {};
    if (this._parentProps) {
      var templatized = this._templatized;
      for (var prop in this._parentProps) {
        if (model[prop] === undefined) {
          model[prop] = templatized[this._parentPropPrefix + prop];
        }
      }
    }
    return new this.ctor(model, this);
  },
  modelForElement: function modelForElement(el) {
    var model;
    while (el) {
      if (model = el._templateInstance) {
        if (model.dataHost != this) {
          el = model.dataHost;
        } else {
          return model;
        }
      } else {
        el = el.parentNode;
      }
    }
  }
};Polymer({
  is: 'dom-template',
  extends: 'template',
  _template: null,
  behaviors: [Polymer.Templatizer],
  ready: function ready() {
    this.templatize(this);
  }
});Polymer._collections = new WeakMap();
Polymer.Collection = function (userArray) {
  Polymer._collections.set(userArray, this);
  this.userArray = userArray;
  this.store = userArray.slice();
  this.initMap();
};
Polymer.Collection.prototype = {
  constructor: Polymer.Collection,
  initMap: function initMap() {
    var omap = this.omap = new WeakMap();
    var pmap = this.pmap = {};
    var s = this.store;
    for (var i = 0; i < s.length; i++) {
      var item = s[i];
      if (item && (typeof item === 'undefined' ? 'undefined' : _typeof(item)) == 'object') {
        omap.set(item, i);
      } else {
        pmap[item] = i;
      }
    }
  },
  add: function add(item) {
    var key = this.store.push(item) - 1;
    if (item && (typeof item === 'undefined' ? 'undefined' : _typeof(item)) == 'object') {
      this.omap.set(item, key);
    } else {
      this.pmap[item] = key;
    }
    return '#' + key;
  },
  removeKey: function removeKey(key) {
    if (key = this._parseKey(key)) {
      this._removeFromMap(this.store[key]);
      delete this.store[key];
    }
  },
  _removeFromMap: function _removeFromMap(item) {
    if (item && (typeof item === 'undefined' ? 'undefined' : _typeof(item)) == 'object') {
      this.omap.delete(item);
    } else {
      delete this.pmap[item];
    }
  },
  remove: function remove(item) {
    var key = this.getKey(item);
    this.removeKey(key);
    return key;
  },
  getKey: function getKey(item) {
    var key;
    if (item && (typeof item === 'undefined' ? 'undefined' : _typeof(item)) == 'object') {
      key = this.omap.get(item);
    } else {
      key = this.pmap[item];
    }
    if (key != undefined) {
      return '#' + key;
    }
  },
  getKeys: function getKeys() {
    return Object.keys(this.store).map(function (key) {
      return '#' + key;
    });
  },
  _parseKey: function _parseKey(key) {
    if (key && key[0] == '#') {
      return key.slice(1);
    }
  },
  setItem: function setItem(key, item) {
    if (key = this._parseKey(key)) {
      var old = this.store[key];
      if (old) {
        this._removeFromMap(old);
      }
      if (item && (typeof item === 'undefined' ? 'undefined' : _typeof(item)) == 'object') {
        this.omap.set(item, key);
      } else {
        this.pmap[item] = key;
      }
      this.store[key] = item;
    }
  },
  getItem: function getItem(key) {
    if (key = this._parseKey(key)) {
      return this.store[key];
    }
  },
  getItems: function getItems() {
    var items = [],
        store = this.store;
    for (var key in store) {
      items.push(store[key]);
    }
    return items;
  },
  _applySplices: function _applySplices(splices) {
    var keyMap = {},
        key;
    for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
      s.addedKeys = [];
      for (var j = 0; j < s.removed.length; j++) {
        key = this.getKey(s.removed[j]);
        keyMap[key] = keyMap[key] ? null : -1;
      }
      for (j = 0; j < s.addedCount; j++) {
        var item = this.userArray[s.index + j];
        key = this.getKey(item);
        key = key === undefined ? this.add(item) : key;
        keyMap[key] = keyMap[key] ? null : 1;
        s.addedKeys.push(key);
      }
    }
    var removed = [];
    var added = [];
    for (key in keyMap) {
      if (keyMap[key] < 0) {
        this.removeKey(key);
        removed.push(key);
      }
      if (keyMap[key] > 0) {
        added.push(key);
      }
    }
    return [{
      removed: removed,
      added: added
    }];
  }
};
Polymer.Collection.get = function (userArray) {
  return Polymer._collections.get(userArray) || new Polymer.Collection(userArray);
};
Polymer.Collection.applySplices = function (userArray, splices) {
  var coll = Polymer._collections.get(userArray);
  return coll ? coll._applySplices(splices) : null;
};Polymer({
  is: 'dom-repeat',
  extends: 'template',
  _template: null,
  properties: {
    items: { type: Array },
    as: {
      type: String,
      value: 'item'
    },
    indexAs: {
      type: String,
      value: 'index'
    },
    sort: {
      type: Function,
      observer: '_sortChanged'
    },
    filter: {
      type: Function,
      observer: '_filterChanged'
    },
    observe: {
      type: String,
      observer: '_observeChanged'
    },
    delay: Number,
    renderedItemCount: {
      type: Number,
      notify: !Polymer.Settings.suppressTemplateNotifications,
      readOnly: true
    },
    initialCount: {
      type: Number,
      observer: '_initializeChunking'
    },
    targetFramerate: {
      type: Number,
      value: 20
    },
    notifyDomChange: { type: Boolean },
    _targetFrameTime: {
      type: Number,
      computed: '_computeFrameTime(targetFramerate)'
    }
  },
  behaviors: [Polymer.Templatizer],
  observers: ['_itemsChanged(items.*)'],
  created: function created() {
    this._instances = [];
    this._pool = [];
    this._limit = Infinity;
    var self = this;
    this._boundRenderChunk = function () {
      self._renderChunk();
    };
  },
  detached: function detached() {
    this.__isDetached = true;
    for (var i = 0; i < this._instances.length; i++) {
      this._detachInstance(i);
    }
  },
  attached: function attached() {
    if (this.__isDetached) {
      this.__isDetached = false;
      var refNode;
      var parentNode = Polymer.dom(this).parentNode;
      if (parentNode.localName == this.is) {
        refNode = parentNode;
        parentNode = Polymer.dom(parentNode).parentNode;
      } else {
        refNode = this;
      }
      var parent = Polymer.dom(parentNode);
      for (var i = 0; i < this._instances.length; i++) {
        this._attachInstance(i, parent, refNode);
      }
    }
  },
  ready: function ready() {
    this._instanceProps = { __key__: true };
    this._instanceProps[this.as] = true;
    this._instanceProps[this.indexAs] = true;
    if (!this.ctor) {
      this.templatize(this);
    }
  },
  _sortChanged: function _sortChanged(sort) {
    var dataHost = this._getRootDataHost();
    this._sortFn = sort && (typeof sort == 'function' ? sort : function () {
      return dataHost[sort].apply(dataHost, arguments);
    });
    this._needFullRefresh = true;
    if (this.items) {
      this._debounceTemplate(this._render);
    }
  },
  _filterChanged: function _filterChanged(filter) {
    var dataHost = this._getRootDataHost();
    this._filterFn = filter && (typeof filter == 'function' ? filter : function () {
      return dataHost[filter].apply(dataHost, arguments);
    });
    this._needFullRefresh = true;
    if (this.items) {
      this._debounceTemplate(this._render);
    }
  },
  _computeFrameTime: function _computeFrameTime(rate) {
    return Math.ceil(1000 / rate);
  },
  _initializeChunking: function _initializeChunking() {
    if (this.initialCount) {
      this._limit = this.initialCount;
      this._chunkCount = this.initialCount;
      this._lastChunkTime = performance.now();
    }
  },
  _tryRenderChunk: function _tryRenderChunk() {
    if (this.items && this._limit < this.items.length) {
      this.debounce('renderChunk', this._requestRenderChunk);
    }
  },
  _requestRenderChunk: function _requestRenderChunk() {
    requestAnimationFrame(this._boundRenderChunk);
  },
  _renderChunk: function _renderChunk() {
    var currChunkTime = performance.now();
    var ratio = this._targetFrameTime / (currChunkTime - this._lastChunkTime);
    this._chunkCount = Math.round(this._chunkCount * ratio) || 1;
    this._limit += this._chunkCount;
    this._lastChunkTime = currChunkTime;
    this._debounceTemplate(this._render);
  },
  _observeChanged: function _observeChanged() {
    this._observePaths = this.observe && this.observe.replace('.*', '.').split(' ');
  },
  _itemsChanged: function _itemsChanged(change) {
    if (change.path == 'items') {
      if (Array.isArray(this.items)) {
        this.collection = Polymer.Collection.get(this.items);
      } else if (!this.items) {
        this.collection = null;
      } else {
        this._error(this._logf('dom-repeat', 'expected array for `items`,' + ' found', this.items));
      }
      this._keySplices = [];
      this._indexSplices = [];
      this._needFullRefresh = true;
      this._initializeChunking();
      this._debounceTemplate(this._render);
    } else if (change.path == 'items.splices') {
      this._keySplices = this._keySplices.concat(change.value.keySplices);
      this._indexSplices = this._indexSplices.concat(change.value.indexSplices);
      this._debounceTemplate(this._render);
    } else {
      var subpath = change.path.slice(6);
      this._forwardItemPath(subpath, change.value);
      this._checkObservedPaths(subpath);
    }
  },
  _checkObservedPaths: function _checkObservedPaths(path) {
    if (this._observePaths) {
      path = path.substring(path.indexOf('.') + 1);
      var paths = this._observePaths;
      for (var i = 0; i < paths.length; i++) {
        if (path.indexOf(paths[i]) === 0) {
          this._needFullRefresh = true;
          if (this.delay) {
            this.debounce('render', this._render, this.delay);
          } else {
            this._debounceTemplate(this._render);
          }
          return;
        }
      }
    }
  },
  render: function render() {
    this._needFullRefresh = true;
    this._debounceTemplate(this._render);
    this._flushTemplates();
  },
  _render: function _render() {
    if (this._needFullRefresh) {
      this._applyFullRefresh();
      this._needFullRefresh = false;
    } else if (this._keySplices.length) {
      if (this._sortFn) {
        this._applySplicesUserSort(this._keySplices);
      } else {
        if (this._filterFn) {
          this._applyFullRefresh();
        } else {
          this._applySplicesArrayOrder(this._indexSplices);
        }
      }
    } else {}
    this._keySplices = [];
    this._indexSplices = [];
    var keyToIdx = this._keyToInstIdx = {};
    for (var i = this._instances.length - 1; i >= 0; i--) {
      var inst = this._instances[i];
      if (inst.isPlaceholder && i < this._limit) {
        inst = this._insertInstance(i, inst.__key__);
      } else if (!inst.isPlaceholder && i >= this._limit) {
        inst = this._downgradeInstance(i, inst.__key__);
      }
      keyToIdx[inst.__key__] = i;
      if (!inst.isPlaceholder) {
        inst.__setProperty(this.indexAs, i, true);
      }
    }
    this._pool.length = 0;
    this._setRenderedItemCount(this._instances.length);
    if (!Polymer.Settings.suppressTemplateNotifications || this.notifyDomChange) {
      this.fire('dom-change');
    }
    this._tryRenderChunk();
  },
  _applyFullRefresh: function _applyFullRefresh() {
    var c = this.collection;
    var keys;
    if (this._sortFn) {
      keys = c ? c.getKeys() : [];
    } else {
      keys = [];
      var items = this.items;
      if (items) {
        for (var i = 0; i < items.length; i++) {
          keys.push(c.getKey(items[i]));
        }
      }
    }
    var self = this;
    if (this._filterFn) {
      keys = keys.filter(function (a) {
        return self._filterFn(c.getItem(a));
      });
    }
    if (this._sortFn) {
      keys.sort(function (a, b) {
        return self._sortFn(c.getItem(a), c.getItem(b));
      });
    }
    for (i = 0; i < keys.length; i++) {
      var key = keys[i];
      var inst = this._instances[i];
      if (inst) {
        inst.__key__ = key;
        if (!inst.isPlaceholder && i < this._limit) {
          inst.__setProperty(this.as, c.getItem(key), true);
        }
      } else if (i < this._limit) {
        this._insertInstance(i, key);
      } else {
        this._insertPlaceholder(i, key);
      }
    }
    for (var j = this._instances.length - 1; j >= i; j--) {
      this._detachAndRemoveInstance(j);
    }
  },
  _numericSort: function _numericSort(a, b) {
    return a - b;
  },
  _applySplicesUserSort: function _applySplicesUserSort(splices) {
    var c = this.collection;
    var keyMap = {};
    var key;
    for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
      for (var j = 0; j < s.removed.length; j++) {
        key = s.removed[j];
        keyMap[key] = keyMap[key] ? null : -1;
      }
      for (j = 0; j < s.added.length; j++) {
        key = s.added[j];
        keyMap[key] = keyMap[key] ? null : 1;
      }
    }
    var removedIdxs = [];
    var addedKeys = [];
    for (key in keyMap) {
      if (keyMap[key] === -1) {
        removedIdxs.push(this._keyToInstIdx[key]);
      }
      if (keyMap[key] === 1) {
        addedKeys.push(key);
      }
    }
    if (removedIdxs.length) {
      removedIdxs.sort(this._numericSort);
      for (i = removedIdxs.length - 1; i >= 0; i--) {
        var idx = removedIdxs[i];
        if (idx !== undefined) {
          this._detachAndRemoveInstance(idx);
        }
      }
    }
    var self = this;
    if (addedKeys.length) {
      if (this._filterFn) {
        addedKeys = addedKeys.filter(function (a) {
          return self._filterFn(c.getItem(a));
        });
      }
      addedKeys.sort(function (a, b) {
        return self._sortFn(c.getItem(a), c.getItem(b));
      });
      var start = 0;
      for (i = 0; i < addedKeys.length; i++) {
        start = this._insertRowUserSort(start, addedKeys[i]);
      }
    }
  },
  _insertRowUserSort: function _insertRowUserSort(start, key) {
    var c = this.collection;
    var item = c.getItem(key);
    var end = this._instances.length - 1;
    var idx = -1;
    while (start <= end) {
      var mid = start + end >> 1;
      var midKey = this._instances[mid].__key__;
      var cmp = this._sortFn(c.getItem(midKey), item);
      if (cmp < 0) {
        start = mid + 1;
      } else if (cmp > 0) {
        end = mid - 1;
      } else {
        idx = mid;
        break;
      }
    }
    if (idx < 0) {
      idx = end + 1;
    }
    this._insertPlaceholder(idx, key);
    return idx;
  },
  _applySplicesArrayOrder: function _applySplicesArrayOrder(splices) {
    for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
      for (var j = 0; j < s.removed.length; j++) {
        this._detachAndRemoveInstance(s.index);
      }
      for (j = 0; j < s.addedKeys.length; j++) {
        this._insertPlaceholder(s.index + j, s.addedKeys[j]);
      }
    }
  },
  _detachInstance: function _detachInstance(idx) {
    var inst = this._instances[idx];
    if (!inst.isPlaceholder) {
      for (var i = 0; i < inst._children.length; i++) {
        var el = inst._children[i];
        Polymer.dom(inst.root).appendChild(el);
      }
      return inst;
    }
  },
  _attachInstance: function _attachInstance(idx, parent, refNode) {
    var inst = this._instances[idx];
    if (!inst.isPlaceholder) {
      parent.insertBefore(inst.root, refNode);
    }
  },
  _detachAndRemoveInstance: function _detachAndRemoveInstance(idx) {
    var inst = this._detachInstance(idx);
    if (inst) {
      this._pool.push(inst);
    }
    this._instances.splice(idx, 1);
  },
  _insertPlaceholder: function _insertPlaceholder(idx, key) {
    this._instances.splice(idx, 0, {
      isPlaceholder: true,
      __key__: key
    });
  },
  _stampInstance: function _stampInstance(idx, key) {
    var model = { __key__: key };
    model[this.as] = this.collection.getItem(key);
    model[this.indexAs] = idx;
    return this.stamp(model);
  },
  _insertInstance: function _insertInstance(idx, key) {
    var inst = this._pool.pop();
    if (inst) {
      inst.__setProperty(this.as, this.collection.getItem(key), true);
      inst.__setProperty('__key__', key, true);
    } else {
      inst = this._stampInstance(idx, key);
    }
    var beforeRow = this._instances[idx + 1];
    var beforeNode = beforeRow && !beforeRow.isPlaceholder ? beforeRow._children[0] : this;
    var parentNode = Polymer.dom(this).parentNode;
    if (parentNode.localName == this.is) {
      if (beforeNode == this) {
        beforeNode = parentNode;
      }
      parentNode = Polymer.dom(parentNode).parentNode;
    }
    Polymer.dom(parentNode).insertBefore(inst.root, beforeNode);
    this._instances[idx] = inst;
    return inst;
  },
  _downgradeInstance: function _downgradeInstance(idx, key) {
    var inst = this._detachInstance(idx);
    if (inst) {
      this._pool.push(inst);
    }
    inst = {
      isPlaceholder: true,
      __key__: key
    };
    this._instances[idx] = inst;
    return inst;
  },
  _showHideChildren: function _showHideChildren(hidden) {
    for (var i = 0; i < this._instances.length; i++) {
      if (!this._instances[i].isPlaceholder) this._instances[i]._showHideChildren(hidden);
    }
  },
  _forwardInstanceProp: function _forwardInstanceProp(inst, prop, value) {
    if (prop == this.as) {
      var idx;
      if (this._sortFn || this._filterFn) {
        idx = this.items.indexOf(this.collection.getItem(inst.__key__));
      } else {
        idx = inst[this.indexAs];
      }
      this.set('items.' + idx, value);
    }
  },
  _forwardInstancePath: function _forwardInstancePath(inst, path, value) {
    if (path.indexOf(this.as + '.') === 0) {
      this._notifyPath('items.' + inst.__key__ + '.' + path.slice(this.as.length + 1), value);
    }
  },
  _forwardParentProp: function _forwardParentProp(prop, value) {
    var i$ = this._instances;
    for (var i = 0, inst; i < i$.length && (inst = i$[i]); i++) {
      if (!inst.isPlaceholder) {
        inst.__setProperty(prop, value, true);
      }
    }
  },
  _forwardParentPath: function _forwardParentPath(path, value) {
    var i$ = this._instances;
    for (var i = 0, inst; i < i$.length && (inst = i$[i]); i++) {
      if (!inst.isPlaceholder) {
        inst._notifyPath(path, value, true);
      }
    }
  },
  _forwardItemPath: function _forwardItemPath(path, value) {
    if (this._keyToInstIdx) {
      var dot = path.indexOf('.');
      var key = path.substring(0, dot < 0 ? path.length : dot);
      var idx = this._keyToInstIdx[key];
      var inst = this._instances[idx];
      if (inst && !inst.isPlaceholder) {
        if (dot >= 0) {
          path = this.as + '.' + path.substring(dot + 1);
          inst._notifyPath(path, value, true);
        } else {
          inst.__setProperty(this.as, value, true);
        }
      }
    }
  },
  itemForElement: function itemForElement(el) {
    var instance = this.modelForElement(el);
    return instance && instance[this.as];
  },
  keyForElement: function keyForElement(el) {
    var instance = this.modelForElement(el);
    return instance && instance.__key__;
  },
  indexForElement: function indexForElement(el) {
    var instance = this.modelForElement(el);
    return instance && instance[this.indexAs];
  }
});Polymer({
  is: 'array-selector',
  _template: null,
  properties: {
    items: {
      type: Array,
      observer: 'clearSelection'
    },
    multi: {
      type: Boolean,
      value: false,
      observer: 'clearSelection'
    },
    selected: {
      type: Object,
      notify: true
    },
    selectedItem: {
      type: Object,
      notify: true
    },
    toggle: {
      type: Boolean,
      value: false
    }
  },
  clearSelection: function clearSelection() {
    if (Array.isArray(this.selected)) {
      for (var i = 0; i < this.selected.length; i++) {
        this.unlinkPaths('selected.' + i);
      }
    } else {
      this.unlinkPaths('selected');
      this.unlinkPaths('selectedItem');
    }
    if (this.multi) {
      if (!this.selected || this.selected.length) {
        this.selected = [];
        this._selectedColl = Polymer.Collection.get(this.selected);
      }
    } else {
      this.selected = null;
      this._selectedColl = null;
    }
    this.selectedItem = null;
  },
  isSelected: function isSelected(item) {
    if (this.multi) {
      return this._selectedColl.getKey(item) !== undefined;
    } else {
      return this.selected == item;
    }
  },
  deselect: function deselect(item) {
    if (this.multi) {
      if (this.isSelected(item)) {
        var skey = this._selectedColl.getKey(item);
        this.arrayDelete('selected', item);
        this.unlinkPaths('selected.' + skey);
      }
    } else {
      this.selected = null;
      this.selectedItem = null;
      this.unlinkPaths('selected');
      this.unlinkPaths('selectedItem');
    }
  },
  select: function select(item) {
    var icol = Polymer.Collection.get(this.items);
    var key = icol.getKey(item);
    if (this.multi) {
      if (this.isSelected(item)) {
        if (this.toggle) {
          this.deselect(item);
        }
      } else {
        this.push('selected', item);
        var skey = this._selectedColl.getKey(item);
        this.linkPaths('selected.' + skey, 'items.' + key);
      }
    } else {
      if (this.toggle && item == this.selected) {
        this.deselect();
      } else {
        this.selected = item;
        this.selectedItem = item;
        this.linkPaths('selected', 'items.' + key);
        this.linkPaths('selectedItem', 'items.' + key);
      }
    }
  }
});Polymer({
  is: 'dom-if',
  extends: 'template',
  _template: null,
  properties: {
    'if': {
      type: Boolean,
      value: false,
      observer: '_queueRender'
    },
    restamp: {
      type: Boolean,
      value: false,
      observer: '_queueRender'
    },
    notifyDomChange: { type: Boolean }
  },
  behaviors: [Polymer.Templatizer],
  _queueRender: function _queueRender() {
    this._debounceTemplate(this._render);
  },
  detached: function detached() {
    var parentNode = this.parentNode;
    if (parentNode && parentNode.localName == this.is) {
      parentNode = Polymer.dom(parentNode).parentNode;
    }
    if (!parentNode || parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE && (!Polymer.Settings.hasShadow || !(parentNode instanceof ShadowRoot))) {
      this._teardownInstance();
    }
  },
  attached: function attached() {
    if (this.if && this.ctor) {
      this.async(this._ensureInstance);
    }
  },
  render: function render() {
    this._flushTemplates();
  },
  _render: function _render() {
    if (this.if) {
      if (!this.ctor) {
        this.templatize(this);
      }
      this._ensureInstance();
      this._showHideChildren();
    } else if (this.restamp) {
      this._teardownInstance();
    }
    if (!this.restamp && this._instance) {
      this._showHideChildren();
    }
    if (this.if != this._lastIf) {
      if (!Polymer.Settings.suppressTemplateNotifications || this.notifyDomChange) {
        this.fire('dom-change');
      }
      this._lastIf = this.if;
    }
  },
  _ensureInstance: function _ensureInstance() {
    var refNode;
    var parentNode = Polymer.dom(this).parentNode;
    if (parentNode && parentNode.localName == this.is) {
      refNode = parentNode;
      parentNode = Polymer.dom(parentNode).parentNode;
    } else {
      refNode = this;
    }
    if (parentNode) {
      if (!this._instance) {
        this._instance = this.stamp();
        var root = this._instance.root;
        Polymer.dom(parentNode).insertBefore(root, refNode);
      } else {
        var c$ = this._instance._children;
        if (c$ && c$.length) {
          var lastChild = Polymer.dom(refNode).previousSibling;
          if (lastChild !== c$[c$.length - 1]) {
            for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
              Polymer.dom(parentNode).insertBefore(n, refNode);
            }
          }
        }
      }
    }
  },
  _teardownInstance: function _teardownInstance() {
    if (this._instance) {
      var c$ = this._instance._children;
      if (c$ && c$.length) {
        var parent = Polymer.dom(Polymer.dom(c$[0]).parentNode);
        for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
          parent.removeChild(n);
        }
      }
      this._instance = null;
    }
  },
  _showHideChildren: function _showHideChildren() {
    var hidden = this.__hideTemplateChildren__ || !this.if;
    if (this._instance) {
      this._instance._showHideChildren(hidden);
    }
  },
  _forwardParentProp: function _forwardParentProp(prop, value) {
    if (this._instance) {
      this._instance.__setProperty(prop, value, true);
    }
  },
  _forwardParentPath: function _forwardParentPath(path, value) {
    if (this._instance) {
      this._instance._notifyPath(path, value, true);
    }
  }
});Polymer({
  is: 'dom-bind',
  properties: { notifyDomChange: { type: Boolean } },
  extends: 'template',
  _template: null,
  created: function created() {
    var self = this;
    Polymer.RenderStatus.whenReady(function () {
      if (document.readyState == 'loading') {
        document.addEventListener('DOMContentLoaded', function () {
          self._markImportsReady();
        });
      } else {
        self._markImportsReady();
      }
    });
  },
  _ensureReady: function _ensureReady() {
    if (!this._readied) {
      this._readySelf();
    }
  },
  _markImportsReady: function _markImportsReady() {
    this._importsReady = true;
    this._ensureReady();
  },
  _registerFeatures: function _registerFeatures() {
    this._prepConstructor();
  },
  _insertChildren: function _insertChildren() {
    var refNode;
    var parentNode = Polymer.dom(this).parentNode;
    if (parentNode.localName == this.is) {
      refNode = parentNode;
      parentNode = Polymer.dom(parentNode).parentNode;
    } else {
      refNode = this;
    }
    Polymer.dom(parentNode).insertBefore(this.root, refNode);
  },
  _removeChildren: function _removeChildren() {
    if (this._children) {
      for (var i = 0; i < this._children.length; i++) {
        this.root.appendChild(this._children[i]);
      }
    }
  },
  _initFeatures: function _initFeatures() {},
  _scopeElementClass: function _scopeElementClass(element, selector) {
    if (this.dataHost) {
      return this.dataHost._scopeElementClass(element, selector);
    } else {
      return selector;
    }
  },
  _configureInstanceProperties: function _configureInstanceProperties() {},
  _prepConfigure: function _prepConfigure() {
    var config = {};
    for (var prop in this._propertyEffects) {
      config[prop] = this[prop];
    }
    var setupConfigure = this._setupConfigure;
    this._setupConfigure = function () {
      setupConfigure.call(this, config);
    };
  },
  attached: function attached() {
    if (this._importsReady) {
      this.render();
    }
  },
  detached: function detached() {
    this._removeChildren();
  },
  render: function render() {
    this._ensureReady();
    if (!this._children) {
      this._template = this;
      this._prepAnnotations();
      this._prepEffects();
      this._prepBehaviors();
      this._prepConfigure();
      this._prepBindings();
      this._prepPropertyInfo();
      Polymer.Base._initFeatures.call(this);
      this._children = Polymer.TreeApi.arrayCopyChildNodes(this.root);
    }
    this._insertChildren();
    if (!Polymer.Settings.suppressTemplateNotifications || this.notifyDomChange) {
      this.fire('dom-change');
    }
  }
});</script><style>[hidden]{display:none !important;}</style><style is="custom-style">:root{--layout:{display:-ms-flexbox;display:-webkit-flex;display:flex;};--layout-inline:{display:-ms-inline-flexbox;display:-webkit-inline-flex;display:inline-flex;};--layout-horizontal:{@apply (--layout);-ms-flex-direction:row;-webkit-flex-direction:row;flex-direction:row;};--layout-horizontal-reverse:{@apply (--layout);-ms-flex-direction:row-reverse;-webkit-flex-direction:row-reverse;flex-direction:row-reverse;};--layout-vertical:{@apply (--layout);-ms-flex-direction:column;-webkit-flex-direction:column;flex-direction:column;};--layout-vertical-reverse:{@apply (--layout);-ms-flex-direction:column-reverse;-webkit-flex-direction:column-reverse;flex-direction:column-reverse;};--layout-wrap:{-ms-flex-wrap:wrap;-webkit-flex-wrap:wrap;flex-wrap:wrap;};--layout-no-wrap:{-ms-flex-wrap:nowrap;-webkit-flex-wrap:nowrap;flex-wrap:nowrap;};--layout-wrap-reverse:{-ms-flex-wrap:wrap-reverse;-webkit-flex-wrap:wrap-reverse;flex-wrap:wrap-reverse;};--layout-flex-auto:{-ms-flex:1 1 auto;-webkit-flex:1 1 auto;flex:1 1 auto;};--layout-flex-none:{-ms-flex:none;-webkit-flex:none;flex:none;};--layout-flex:{-ms-flex:1 1 0.000000001px;-webkit-flex:1;flex:1;-webkit-flex-basis:0.000000001px;flex-basis:0.000000001px;};--layout-flex-2:{-ms-flex:2;-webkit-flex:2;flex:2;};--layout-flex-3:{-ms-flex:3;-webkit-flex:3;flex:3;};--layout-flex-4:{-ms-flex:4;-webkit-flex:4;flex:4;};--layout-flex-5:{-ms-flex:5;-webkit-flex:5;flex:5;};--layout-flex-6:{-ms-flex:6;-webkit-flex:6;flex:6;};--layout-flex-7:{-ms-flex:7;-webkit-flex:7;flex:7;};--layout-flex-8:{-ms-flex:8;-webkit-flex:8;flex:8;};--layout-flex-9:{-ms-flex:9;-webkit-flex:9;flex:9;};--layout-flex-10:{-ms-flex:10;-webkit-flex:10;flex:10;};--layout-flex-11:{-ms-flex:11;-webkit-flex:11;flex:11;};--layout-flex-12:{-ms-flex:12;-webkit-flex:12;flex:12;};--layout-start:{-ms-flex-align:start;-webkit-align-items:flex-start;align-items:flex-start;};--layout-center:{-ms-flex-align:center;-webkit-align-items:center;align-items:center;};--layout-end:{-ms-flex-align:end;-webkit-align-items:flex-end;align-items:flex-end;};--layout-baseline:{-ms-flex-align:baseline;-webkit-align-items:baseline;align-items:baseline;};--layout-start-justified:{-ms-flex-pack:start;-webkit-justify-content:flex-start;justify-content:flex-start;};--layout-center-justified:{-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;};--layout-end-justified:{-ms-flex-pack:end;-webkit-justify-content:flex-end;justify-content:flex-end;};--layout-around-justified:{-ms-flex-pack:distribute;-webkit-justify-content:space-around;justify-content:space-around;};--layout-justified:{-ms-flex-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;};--layout-center-center:{@apply (--layout-center);@apply (--layout-center-justified);};--layout-self-start:{-ms-align-self:flex-start;-webkit-align-self:flex-start;align-self:flex-start;};--layout-self-center:{-ms-align-self:center;-webkit-align-self:center;align-self:center;};--layout-self-end:{-ms-align-self:flex-end;-webkit-align-self:flex-end;align-self:flex-end;};--layout-self-stretch:{-ms-align-self:stretch;-webkit-align-self:stretch;align-self:stretch;};--layout-self-baseline:{-ms-align-self:baseline;-webkit-align-self:baseline;align-self:baseline;};--layout-start-aligned:{-ms-flex-line-pack:start;-ms-align-content:flex-start;-webkit-align-content:flex-start;align-content:flex-start;};--layout-end-aligned:{-ms-flex-line-pack:end;-ms-align-content:flex-end;-webkit-align-content:flex-end;align-content:flex-end;};--layout-center-aligned:{-ms-flex-line-pack:center;-ms-align-content:center;-webkit-align-content:center;align-content:center;};--layout-between-aligned:{-ms-flex-line-pack:justify;-ms-align-content:space-between;-webkit-align-content:space-between;align-content:space-between;};--layout-around-aligned:{-ms-flex-line-pack:distribute;-ms-align-content:space-around;-webkit-align-content:space-around;align-content:space-around;};--layout-block:{display:block;};--layout-invisible:{visibility:hidden !important;};--layout-relative:{position:relative;};--layout-fit:{position:absolute;top:0;right:0;bottom:0;left:0;};--layout-scroll:{-webkit-overflow-scrolling:touch;overflow:auto;};--layout-fullbleed:{margin:0;height:100vh;};--layout-fixed-top:{position:fixed;top:0;left:0;right:0;};--layout-fixed-right:{position:fixed;top:0;right:0;bottom:0;};--layout-fixed-bottom:{position:fixed;right:0;bottom:0;left:0;};--layout-fixed-left:{position:fixed;top:0;bottom:0;left:0;};}</style><script>

(function () {

  // monostate data
  var metaDatas = {};
  var metaArrays = {};
  var singleton = null;

  Polymer.IronMeta = Polymer({

    is: 'iron-meta',

    properties: {

      /**
       * The type of meta-data.  All meta-data of the same type is stored
       * together.
       */
      type: {
        type: String,
        value: 'default',
        observer: '_typeChanged'
      },

      /**
       * The key used to store `value` under the `type` namespace.
       */
      key: {
        type: String,
        observer: '_keyChanged'
      },

      /**
       * The meta-data to store or retrieve.
       */
      value: {
        type: Object,
        notify: true,
        observer: '_valueChanged'
      },

      /**
       * If true, `value` is set to the iron-meta instance itself.
       */
      self: {
        type: Boolean,
        observer: '_selfChanged'
      },

      /**
       * Array of all meta-data values for the given type.
       */
      list: {
        type: Array,
        notify: true
      }

    },

    hostAttributes: {
      hidden: true
    },

    /**
     * Only runs if someone invokes the factory/constructor directly
     * e.g. `new Polymer.IronMeta()`
     *
     * @param {{type: (string|undefined), key: (string|undefined), value}=} config
     */
    factoryImpl: function factoryImpl(config) {
      if (config) {
        for (var n in config) {
          switch (n) {
            case 'type':
            case 'key':
            case 'value':
              this[n] = config[n];
              break;
          }
        }
      }
    },

    created: function created() {
      // TODO(sjmiles): good for debugging?
      this._metaDatas = metaDatas;
      this._metaArrays = metaArrays;
    },

    _keyChanged: function _keyChanged(key, old) {
      this._resetRegistration(old);
    },

    _valueChanged: function _valueChanged(value) {
      this._resetRegistration(this.key);
    },

    _selfChanged: function _selfChanged(self) {
      if (self) {
        this.value = this;
      }
    },

    _typeChanged: function _typeChanged(type) {
      this._unregisterKey(this.key);
      if (!metaDatas[type]) {
        metaDatas[type] = {};
      }
      this._metaData = metaDatas[type];
      if (!metaArrays[type]) {
        metaArrays[type] = [];
      }
      this.list = metaArrays[type];
      this._registerKeyValue(this.key, this.value);
    },

    /**
     * Retrieves meta data value by key.
     *
     * @method byKey
     * @param {string} key The key of the meta-data to be returned.
     * @return {*}
     */
    byKey: function byKey(key) {
      return this._metaData && this._metaData[key];
    },

    _resetRegistration: function _resetRegistration(oldKey) {
      this._unregisterKey(oldKey);
      this._registerKeyValue(this.key, this.value);
    },

    _unregisterKey: function _unregisterKey(key) {
      this._unregister(key, this._metaData, this.list);
    },

    _registerKeyValue: function _registerKeyValue(key, value) {
      this._register(key, value, this._metaData, this.list);
    },

    _register: function _register(key, value, data, list) {
      if (key && data && value !== undefined) {
        data[key] = value;
        list.push(value);
      }
    },

    _unregister: function _unregister(key, data, list) {
      if (key && data) {
        if (key in data) {
          var value = data[key];
          delete data[key];
          this.arrayDelete(list, value);
        }
      }
    }

  });

  Polymer.IronMeta.getIronMeta = function getIronMeta() {
    if (singleton === null) {
      singleton = new Polymer.IronMeta();
    }
    return singleton;
  };

  /**
  `iron-meta-query` can be used to access infomation stored in `iron-meta`.
   Examples:
   If I create an instance like this:
       <iron-meta key="info" value="foo/bar"></iron-meta>
   Note that value="foo/bar" is the metadata I've defined. I could define more
  attributes or use child nodes to define additional metadata.
   Now I can access that element (and it's metadata) from any `iron-meta-query` instance:
        var value = new Polymer.IronMetaQuery({key: 'info'}).value;
   @group Polymer Iron Elements
  @element iron-meta-query
  */
  Polymer.IronMetaQuery = Polymer({

    is: 'iron-meta-query',

    properties: {

      /**
       * The type of meta-data.  All meta-data of the same type is stored
       * together.
       */
      type: {
        type: String,
        value: 'default',
        observer: '_typeChanged'
      },

      /**
       * Specifies a key to use for retrieving `value` from the `type`
       * namespace.
       */
      key: {
        type: String,
        observer: '_keyChanged'
      },

      /**
       * The meta-data to store or retrieve.
       */
      value: {
        type: Object,
        notify: true,
        readOnly: true
      },

      /**
       * Array of all meta-data values for the given type.
       */
      list: {
        type: Array,
        notify: true
      }

    },

    /**
     * Actually a factory method, not a true constructor. Only runs if
     * someone invokes it directly (via `new Polymer.IronMeta()`);
     *
     * @param {{type: (string|undefined), key: (string|undefined)}=} config
     */
    factoryImpl: function factoryImpl(config) {
      if (config) {
        for (var n in config) {
          switch (n) {
            case 'type':
            case 'key':
              this[n] = config[n];
              break;
          }
        }
      }
    },

    created: function created() {
      // TODO(sjmiles): good for debugging?
      this._metaDatas = metaDatas;
      this._metaArrays = metaArrays;
    },

    _keyChanged: function _keyChanged(key) {
      this._setValue(this._metaData && this._metaData[key]);
    },

    _typeChanged: function _typeChanged(type) {
      this._metaData = metaDatas[type];
      this.list = metaArrays[type];
      if (this.key) {
        this._keyChanged(this.key);
      }
    },

    /**
     * Retrieves meta data value by key.
     * @param {string} key The key of the meta-data to be returned.
     * @return {*}
     */
    byKey: function byKey(key) {
      return this._metaData && this._metaData[key];
    }

  });
})();</script><dom-module id="iron-icon" assetpath="../bower_components/iron-icon/"><template><style>:host{@apply (--layout-inline);@apply (--layout-center-center);position:relative;vertical-align:middle;fill:var(--iron-icon-fill-color, currentcolor);stroke:var(--iron-icon-stroke-color, none);width:var(--iron-icon-width, 24px);height:var(--iron-icon-height, 24px);@apply (--iron-icon);}</style></template><script>

Polymer({

  is: 'iron-icon',

  properties: {

    /**
     * The name of the icon to use. The name should be of the form:
     * `iconset_name:icon_name`.
     */
    icon: {
      type: String
    },

    /**
     * The name of the theme to used, if one is specified by the
     * iconset.
     */
    theme: {
      type: String
    },

    /**
     * If using iron-icon without an iconset, you can set the src to be
     * the URL of an individual icon image file. Note that this will take
     * precedence over a given icon attribute.
     */
    src: {
      type: String
    },

    /**
     * @type {!Polymer.IronMeta}
     */
    _meta: {
      value: Polymer.Base.create('iron-meta', { type: 'iconset' })
    }

  },

  observers: ['_updateIcon(_meta, isAttached)', '_updateIcon(theme, isAttached)', '_srcChanged(src, isAttached)', '_iconChanged(icon, isAttached)'],

  _DEFAULT_ICONSET: 'icons',

  _iconChanged: function _iconChanged(icon) {
    var parts = (icon || '').split(':');
    this._iconName = parts.pop();
    this._iconsetName = parts.pop() || this._DEFAULT_ICONSET;
    this._updateIcon();
  },

  _srcChanged: function _srcChanged(src) {
    this._updateIcon();
  },

  _usesIconset: function _usesIconset() {
    return this.icon || !this.src;
  },

  /** @suppress {visibility} */
  _updateIcon: function _updateIcon() {
    if (this._usesIconset()) {
      if (this._img && this._img.parentNode) {
        Polymer.dom(this.root).removeChild(this._img);
      }
      if (this._iconName === "") {
        if (this._iconset) {
          this._iconset.removeIcon(this);
        }
      } else if (this._iconsetName && this._meta) {
        this._iconset = /** @type {?Polymer.Iconset} */this._meta.byKey(this._iconsetName);
        if (this._iconset) {
          this._iconset.applyIcon(this, this._iconName, this.theme);
          this.unlisten(window, 'iron-iconset-added', '_updateIcon');
        } else {
          this.listen(window, 'iron-iconset-added', '_updateIcon');
        }
      }
    } else {
      if (this._iconset) {
        this._iconset.removeIcon(this);
      }
      if (!this._img) {
        this._img = document.createElement('img');
        this._img.style.width = '100%';
        this._img.style.height = '100%';
        this._img.draggable = false;
      }
      this._img.src = this.src;
      Polymer.dom(this.root).appendChild(this._img);
    }
  }

});</script></dom-module><script>

/**
 * @param {!Function} selectCallback
 * @constructor
 */
Polymer.IronSelection = function (selectCallback) {
  this.selection = [];
  this.selectCallback = selectCallback;
};

Polymer.IronSelection.prototype = {

  /**
   * Retrieves the selected item(s).
   *
   * @method get
   * @returns Returns the selected item(s). If the multi property is true,
   * `get` will return an array, otherwise it will return
   * the selected item or undefined if there is no selection.
   */
  get: function get() {
    return this.multi ? this.selection.slice() : this.selection[0];
  },

  /**
   * Clears all the selection except the ones indicated.
   *
   * @method clear
   * @param {Array} excludes items to be excluded.
   */
  clear: function clear(excludes) {
    this.selection.slice().forEach(function (item) {
      if (!excludes || excludes.indexOf(item) < 0) {
        this.setItemSelected(item, false);
      }
    }, this);
  },

  /**
   * Indicates if a given item is selected.
   *
   * @method isSelected
   * @param {*} item The item whose selection state should be checked.
   * @returns Returns true if `item` is selected.
   */
  isSelected: function isSelected(item) {
    return this.selection.indexOf(item) >= 0;
  },

  /**
   * Sets the selection state for a given item to either selected or deselected.
   *
   * @method setItemSelected
   * @param {*} item The item to select.
   * @param {boolean} isSelected True for selected, false for deselected.
   */
  setItemSelected: function setItemSelected(item, isSelected) {
    if (item != null) {
      if (isSelected !== this.isSelected(item)) {
        // proceed to update selection only if requested state differs from current
        if (isSelected) {
          this.selection.push(item);
        } else {
          var i = this.selection.indexOf(item);
          if (i >= 0) {
            this.selection.splice(i, 1);
          }
        }
        if (this.selectCallback) {
          this.selectCallback(item, isSelected);
        }
      }
    }
  },

  /**
   * Sets the selection state for a given item. If the `multi` property
   * is true, then the selected state of `item` will be toggled; otherwise
   * the `item` will be selected.
   *
   * @method select
   * @param {*} item The item to select.
   */
  select: function select(item) {
    if (this.multi) {
      this.toggle(item);
    } else if (this.get() !== item) {
      this.setItemSelected(this.get(), false);
      this.setItemSelected(item, true);
    }
  },

  /**
   * Toggles the selection state for `item`.
   *
   * @method toggle
   * @param {*} item The item to toggle.
   */
  toggle: function toggle(item) {
    this.setItemSelected(item, !this.isSelected(item));
  }

};</script><script>

/** @polymerBehavior */
Polymer.IronSelectableBehavior = {

  /**
   * Fired when iron-selector is activated (selected or deselected).
   * It is fired before the selected items are changed.
   * Cancel the event to abort selection.
   *
   * @event iron-activate
   */

  /**
   * Fired when an item is selected
   *
   * @event iron-select
   */

  /**
   * Fired when an item is deselected
   *
   * @event iron-deselect
   */

  /**
   * Fired when the list of selectable items changes (e.g., items are
   * added or removed). The detail of the event is a mutation record that
   * describes what changed.
   *
   * @event iron-items-changed
   */

  properties: {

    /**
     * If you want to use an attribute value or property of an element for
     * `selected` instead of the index, set this to the name of the attribute
     * or property. Hyphenated values are converted to camel case when used to
     * look up the property of a selectable element. Camel cased values are
     * *not* converted to hyphenated values for attribute lookup. It's
     * recommended that you provide the hyphenated form of the name so that
     * selection works in both cases. (Use `attr-or-property-name` instead of
     * `attrOrPropertyName`.)
     */
    attrForSelected: {
      type: String,
      value: null
    },

    /**
     * Gets or sets the selected element. The default is to use the index of the item.
     * @type {string|number}
     */
    selected: {
      type: String,
      notify: true
    },

    /**
     * Returns the currently selected item.
     *
     * @type {?Object}
     */
    selectedItem: {
      type: Object,
      readOnly: true,
      notify: true
    },

    /**
     * The event that fires from items when they are selected. Selectable
     * will listen for this event from items and update the selection state.
     * Set to empty string to listen to no events.
     */
    activateEvent: {
      type: String,
      value: 'tap',
      observer: '_activateEventChanged'
    },

    /**
     * This is a CSS selector string.  If this is set, only items that match the CSS selector
     * are selectable.
     */
    selectable: String,

    /**
     * The class to set on elements when selected.
     */
    selectedClass: {
      type: String,
      value: 'iron-selected'
    },

    /**
     * The attribute to set on elements when selected.
     */
    selectedAttribute: {
      type: String,
      value: null
    },

    /**
     * Default fallback if the selection based on selected with `attrForSelected`
     * is not found.
     */
    fallbackSelection: {
      type: String,
      value: null
    },

    /**
     * The list of items from which a selection can be made.
     */
    items: {
      type: Array,
      readOnly: true,
      notify: true,
      value: function value() {
        return [];
      }
    },

    /**
     * The set of excluded elements where the key is the `localName`
     * of the element that will be ignored from the item list.
     *
     * @default {template: 1}
     */
    _excludedLocalNames: {
      type: Object,
      value: function value() {
        return {
          'template': 1
        };
      }
    }
  },

  observers: ['_updateAttrForSelected(attrForSelected)', '_updateSelected(selected)', '_checkFallback(fallbackSelection)'],

  created: function created() {
    this._bindFilterItem = this._filterItem.bind(this);
    this._selection = new Polymer.IronSelection(this._applySelection.bind(this));
  },

  attached: function attached() {
    this._observer = this._observeItems(this);
    this._updateItems();
    if (!this._shouldUpdateSelection) {
      this._updateSelected();
    }
    this._addListener(this.activateEvent);
  },

  detached: function detached() {
    if (this._observer) {
      Polymer.dom(this).unobserveNodes(this._observer);
    }
    this._removeListener(this.activateEvent);
  },

  /**
   * Returns the index of the given item.
   *
   * @method indexOf
   * @param {Object} item
   * @returns Returns the index of the item
   */
  indexOf: function indexOf(item) {
    return this.items.indexOf(item);
  },

  /**
   * Selects the given value.
   *
   * @method select
   * @param {string|number} value the value to select.
   */
  select: function select(value) {
    this.selected = value;
  },

  /**
   * Selects the previous item.
   *
   * @method selectPrevious
   */
  selectPrevious: function selectPrevious() {
    var length = this.items.length;
    var index = (Number(this._valueToIndex(this.selected)) - 1 + length) % length;
    this.selected = this._indexToValue(index);
  },

  /**
   * Selects the next item.
   *
   * @method selectNext
   */
  selectNext: function selectNext() {
    var index = (Number(this._valueToIndex(this.selected)) + 1) % this.items.length;
    this.selected = this._indexToValue(index);
  },

  /**
   * Selects the item at the given index.
   *
   * @method selectIndex
   */
  selectIndex: function selectIndex(index) {
    this.select(this._indexToValue(index));
  },

  /**
   * Force a synchronous update of the `items` property.
   *
   * NOTE: Consider listening for the `iron-items-changed` event to respond to
   * updates to the set of selectable items after updates to the DOM list and
   * selection state have been made.
   *
   * WARNING: If you are using this method, you should probably consider an
   * alternate approach. Synchronously querying for items is potentially
   * slow for many use cases. The `items` property will update asynchronously
   * on its own to reflect selectable items in the DOM.
   */
  forceSynchronousItemUpdate: function forceSynchronousItemUpdate() {
    this._updateItems();
  },

  get _shouldUpdateSelection() {
    return this.selected != null;
  },

  _checkFallback: function _checkFallback() {
    if (this._shouldUpdateSelection) {
      this._updateSelected();
    }
  },

  _addListener: function _addListener(eventName) {
    this.listen(this, eventName, '_activateHandler');
  },

  _removeListener: function _removeListener(eventName) {
    this.unlisten(this, eventName, '_activateHandler');
  },

  _activateEventChanged: function _activateEventChanged(eventName, old) {
    this._removeListener(old);
    this._addListener(eventName);
  },

  _updateItems: function _updateItems() {
    var nodes = Polymer.dom(this).queryDistributedElements(this.selectable || '*');
    nodes = Array.prototype.filter.call(nodes, this._bindFilterItem);
    this._setItems(nodes);
  },

  _updateAttrForSelected: function _updateAttrForSelected() {
    if (this._shouldUpdateSelection) {
      this.selected = this._indexToValue(this.indexOf(this.selectedItem));
    }
  },

  _updateSelected: function _updateSelected() {
    this._selectSelected(this.selected);
  },

  _selectSelected: function _selectSelected(selected) {
    this._selection.select(this._valueToItem(this.selected));
    // Check for items, since this array is populated only when attached
    // Since Number(0) is falsy, explicitly check for undefined
    if (this.fallbackSelection && this.items.length && this._selection.get() === undefined) {
      this.selected = this.fallbackSelection;
    }
  },

  _filterItem: function _filterItem(node) {
    return !this._excludedLocalNames[node.localName];
  },

  _valueToItem: function _valueToItem(value) {
    return value == null ? null : this.items[this._valueToIndex(value)];
  },

  _valueToIndex: function _valueToIndex(value) {
    if (this.attrForSelected) {
      for (var i = 0, item; item = this.items[i]; i++) {
        if (this._valueForItem(item) == value) {
          return i;
        }
      }
    } else {
      return Number(value);
    }
  },

  _indexToValue: function _indexToValue(index) {
    if (this.attrForSelected) {
      var item = this.items[index];
      if (item) {
        return this._valueForItem(item);
      }
    } else {
      return index;
    }
  },

  _valueForItem: function _valueForItem(item) {
    var propValue = item[Polymer.CaseMap.dashToCamelCase(this.attrForSelected)];
    return propValue != undefined ? propValue : item.getAttribute(this.attrForSelected);
  },

  _applySelection: function _applySelection(item, isSelected) {
    if (this.selectedClass) {
      this.toggleClass(this.selectedClass, isSelected, item);
    }
    if (this.selectedAttribute) {
      this.toggleAttribute(this.selectedAttribute, isSelected, item);
    }
    this._selectionChange();
    this.fire('iron-' + (isSelected ? 'select' : 'deselect'), { item: item });
  },

  _selectionChange: function _selectionChange() {
    this._setSelectedItem(this._selection.get());
  },

  // observe items change under the given node.
  _observeItems: function _observeItems(node) {
    return Polymer.dom(node).observeNodes(function (mutation) {
      this._updateItems();

      if (this._shouldUpdateSelection) {
        this._updateSelected();
      }

      // Let other interested parties know about the change so that
      // we don't have to recreate mutation observers everywhere.
      this.fire('iron-items-changed', mutation, {
        bubbles: false,
        cancelable: false
      });
    });
  },

  _activateHandler: function _activateHandler(e) {
    var t = e.target;
    var items = this.items;
    while (t && t != this) {
      var i = items.indexOf(t);
      if (i >= 0) {
        var value = this._indexToValue(i);
        this._itemActivate(value, t);
        return;
      }
      t = t.parentNode;
    }
  },

  _itemActivate: function _itemActivate(value, item) {
    if (!this.fire('iron-activate', { selected: value, item: item }, { cancelable: true }).defaultPrevented) {
      this.select(value);
    }
  }

};</script><script>
/** @polymerBehavior Polymer.IronMultiSelectableBehavior */
Polymer.IronMultiSelectableBehaviorImpl = {
  properties: {

    /**
     * If true, multiple selections are allowed.
     */
    multi: {
      type: Boolean,
      value: false,
      observer: 'multiChanged'
    },

    /**
     * Gets or sets the selected elements. This is used instead of `selected` when `multi`
     * is true.
     */
    selectedValues: {
      type: Array,
      notify: true
    },

    /**
     * Returns an array of currently selected items.
     */
    selectedItems: {
      type: Array,
      readOnly: true,
      notify: true
    }

  },

  observers: ['_updateSelected(selectedValues.splices)'],

  /**
   * Selects the given value. If the `multi` property is true, then the selected state of the
   * `value` will be toggled; otherwise the `value` will be selected.
   *
   * @method select
   * @param {string|number} value the value to select.
   */
  select: function select(value) {
    if (this.multi) {
      if (this.selectedValues) {
        this._toggleSelected(value);
      } else {
        this.selectedValues = [value];
      }
    } else {
      this.selected = value;
    }
  },

  multiChanged: function multiChanged(multi) {
    this._selection.multi = multi;
  },

  get _shouldUpdateSelection() {
    return this.selected != null || this.selectedValues != null && this.selectedValues.length;
  },

  _updateAttrForSelected: function _updateAttrForSelected() {
    if (!this.multi) {
      Polymer.IronSelectableBehavior._updateAttrForSelected.apply(this);
    } else if (this._shouldUpdateSelection) {
      this.selectedValues = this.selectedItems.map(function (selectedItem) {
        return this._indexToValue(this.indexOf(selectedItem));
      }, this).filter(function (unfilteredValue) {
        return unfilteredValue != null;
      }, this);
    }
  },

  _updateSelected: function _updateSelected() {
    if (this.multi) {
      this._selectMulti(this.selectedValues);
    } else {
      this._selectSelected(this.selected);
    }
  },

  _selectMulti: function _selectMulti(values) {
    if (values) {
      var selectedItems = this._valuesToItems(values);
      // clear all but the current selected items
      this._selection.clear(selectedItems);
      // select only those not selected yet
      for (var i = 0; i < selectedItems.length; i++) {
        this._selection.setItemSelected(selectedItems[i], true);
      }
      // Check for items, since this array is populated only when attached
      if (this.fallbackSelection && this.items.length && !this._selection.get().length) {
        var fallback = this._valueToItem(this.fallbackSelection);
        if (fallback) {
          this.selectedValues = [this.fallbackSelection];
        }
      }
    } else {
      this._selection.clear();
    }
  },

  _selectionChange: function _selectionChange() {
    var s = this._selection.get();
    if (this.multi) {
      this._setSelectedItems(s);
    } else {
      this._setSelectedItems([s]);
      this._setSelectedItem(s);
    }
  },

  _toggleSelected: function _toggleSelected(value) {
    var i = this.selectedValues.indexOf(value);
    var unselected = i < 0;
    if (unselected) {
      this.push('selectedValues', value);
    } else {
      this.splice('selectedValues', i, 1);
    }
  },

  _valuesToItems: function _valuesToItems(values) {
    return values == null ? null : values.map(function (value) {
      return this._valueToItem(value);
    }, this);
  }
};

/** @polymerBehavior */
Polymer.IronMultiSelectableBehavior = [Polymer.IronSelectableBehavior, Polymer.IronMultiSelectableBehaviorImpl];</script><script>
(function () {
  'use strict';

  /**
   * Chrome uses an older version of DOM Level 3 Keyboard Events
   *
   * Most keys are labeled as text, but some are Unicode codepoints.
   * Values taken from: http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/keyset.html#KeySet-Set
   */

  var KEY_IDENTIFIER = {
    'U+0008': 'backspace',
    'U+0009': 'tab',
    'U+001B': 'esc',
    'U+0020': 'space',
    'U+007F': 'del'
  };

  /**
   * Special table for KeyboardEvent.keyCode.
   * KeyboardEvent.keyIdentifier is better, and KeyBoardEvent.key is even better
   * than that.
   *
   * Values from: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent.keyCode#Value_of_keyCode
   */
  var KEY_CODE = {
    8: 'backspace',
    9: 'tab',
    13: 'enter',
    27: 'esc',
    33: 'pageup',
    34: 'pagedown',
    35: 'end',
    36: 'home',
    32: 'space',
    37: 'left',
    38: 'up',
    39: 'right',
    40: 'down',
    46: 'del',
    106: '*'
  };

  /**
   * MODIFIER_KEYS maps the short name for modifier keys used in a key
   * combo string to the property name that references those same keys
   * in a KeyboardEvent instance.
   */
  var MODIFIER_KEYS = {
    'shift': 'shiftKey',
    'ctrl': 'ctrlKey',
    'alt': 'altKey',
    'meta': 'metaKey'
  };

  /**
   * KeyboardEvent.key is mostly represented by printable character made by
   * the keyboard, with unprintable keys labeled nicely.
   *
   * However, on OS X, Alt+char can make a Unicode character that follows an
   * Apple-specific mapping. In this case, we fall back to .keyCode.
   */
  var KEY_CHAR = /[a-z0-9*]/;

  /**
   * Matches a keyIdentifier string.
   */
  var IDENT_CHAR = /U\+/;

  /**
   * Matches arrow keys in Gecko 27.0+
   */
  var ARROW_KEY = /^arrow/;

  /**
   * Matches space keys everywhere (notably including IE10's exceptional name
   * `spacebar`).
   */
  var SPACE_KEY = /^space(bar)?/;

  /**
   * Matches ESC key.
   *
   * Value from: http://w3c.github.io/uievents-key/#key-Escape
   */
  var ESC_KEY = /^escape$/;

  /**
   * Transforms the key.
   * @param {string} key The KeyBoardEvent.key
   * @param {Boolean} [noSpecialChars] Limits the transformation to
   * alpha-numeric characters.
   */
  function transformKey(key, noSpecialChars) {
    var validKey = '';
    if (key) {
      var lKey = key.toLowerCase();
      if (lKey === ' ' || SPACE_KEY.test(lKey)) {
        validKey = 'space';
      } else if (ESC_KEY.test(lKey)) {
        validKey = 'esc';
      } else if (lKey.length == 1) {
        if (!noSpecialChars || KEY_CHAR.test(lKey)) {
          validKey = lKey;
        }
      } else if (ARROW_KEY.test(lKey)) {
        validKey = lKey.replace('arrow', '');
      } else if (lKey == 'multiply') {
        // numpad '*' can map to Multiply on IE/Windows
        validKey = '*';
      } else {
        validKey = lKey;
      }
    }
    return validKey;
  }

  function transformKeyIdentifier(keyIdent) {
    var validKey = '';
    if (keyIdent) {
      if (keyIdent in KEY_IDENTIFIER) {
        validKey = KEY_IDENTIFIER[keyIdent];
      } else if (IDENT_CHAR.test(keyIdent)) {
        keyIdent = parseInt(keyIdent.replace('U+', '0x'), 16);
        validKey = String.fromCharCode(keyIdent).toLowerCase();
      } else {
        validKey = keyIdent.toLowerCase();
      }
    }
    return validKey;
  }

  function transformKeyCode(keyCode) {
    var validKey = '';
    if (Number(keyCode)) {
      if (keyCode >= 65 && keyCode <= 90) {
        // ascii a-z
        // lowercase is 32 offset from uppercase
        validKey = String.fromCharCode(32 + keyCode);
      } else if (keyCode >= 112 && keyCode <= 123) {
        // function keys f1-f12
        validKey = 'f' + (keyCode - 112);
      } else if (keyCode >= 48 && keyCode <= 57) {
        // top 0-9 keys
        validKey = String(keyCode - 48);
      } else if (keyCode >= 96 && keyCode <= 105) {
        // num pad 0-9
        validKey = String(keyCode - 96);
      } else {
        validKey = KEY_CODE[keyCode];
      }
    }
    return validKey;
  }

  /**
    * Calculates the normalized key for a KeyboardEvent.
    * @param {KeyboardEvent} keyEvent
    * @param {Boolean} [noSpecialChars] Set to true to limit keyEvent.key
    * transformation to alpha-numeric chars. This is useful with key
    * combinations like shift + 2, which on FF for MacOS produces
    * keyEvent.key = @
    * To get 2 returned, set noSpecialChars = true
    * To get @ returned, set noSpecialChars = false
   */
  function normalizedKeyForEvent(keyEvent, noSpecialChars) {
    // Fall back from .key, to .detail.key for artifical keyboard events,
    // and then to deprecated .keyIdentifier and .keyCode.
    if (keyEvent.key) {
      return transformKey(keyEvent.key, noSpecialChars);
    }
    if (keyEvent.detail && keyEvent.detail.key) {
      return transformKey(keyEvent.detail.key, noSpecialChars);
    }
    return transformKeyIdentifier(keyEvent.keyIdentifier) || transformKeyCode(keyEvent.keyCode) || '';
  }

  function keyComboMatchesEvent(keyCombo, event) {
    // For combos with modifiers we support only alpha-numeric keys
    var keyEvent = normalizedKeyForEvent(event, keyCombo.hasModifiers);
    return keyEvent === keyCombo.key && (!keyCombo.hasModifiers || !!event.shiftKey === !!keyCombo.shiftKey && !!event.ctrlKey === !!keyCombo.ctrlKey && !!event.altKey === !!keyCombo.altKey && !!event.metaKey === !!keyCombo.metaKey);
  }

  function parseKeyComboString(keyComboString) {
    if (keyComboString.length === 1) {
      return {
        combo: keyComboString,
        key: keyComboString,
        event: 'keydown'
      };
    }
    return keyComboString.split('+').reduce(function (parsedKeyCombo, keyComboPart) {
      var eventParts = keyComboPart.split(':');
      var keyName = eventParts[0];
      var event = eventParts[1];

      if (keyName in MODIFIER_KEYS) {
        parsedKeyCombo[MODIFIER_KEYS[keyName]] = true;
        parsedKeyCombo.hasModifiers = true;
      } else {
        parsedKeyCombo.key = keyName;
        parsedKeyCombo.event = event || 'keydown';
      }

      return parsedKeyCombo;
    }, {
      combo: keyComboString.split(':').shift()
    });
  }

  function parseEventString(eventString) {
    return eventString.trim().split(' ').map(function (keyComboString) {
      return parseKeyComboString(keyComboString);
    });
  }

  /**
   * `Polymer.IronA11yKeysBehavior` provides a normalized interface for processing
   * keyboard commands that pertain to [WAI-ARIA best practices](http://www.w3.org/TR/wai-aria-practices/#kbd_general_binding).
   * The element takes care of browser differences with respect to Keyboard events
   * and uses an expressive syntax to filter key presses.
   *
   * Use the `keyBindings` prototype property to express what combination of keys
   * will trigger the callback. A key binding has the format
   * `"KEY+MODIFIER:EVENT": "callback"` (`"KEY": "callback"` or
   * `"KEY:EVENT": "callback"` are valid as well). Some examples:
   *
   *      keyBindings: {
   *        'space': '_onKeydown', // same as 'space:keydown'
   *        'shift+tab': '_onKeydown',
   *        'enter:keypress': '_onKeypress',
   *        'esc:keyup': '_onKeyup'
   *      }
   *
   * The callback will receive with an event containing the following information in `event.detail`:
   *
   *      _onKeydown: function(event) {
   *        console.log(event.detail.combo); // KEY+MODIFIER, e.g. "shift+tab"
   *        console.log(event.detail.key); // KEY only, e.g. "tab"
   *        console.log(event.detail.event); // EVENT, e.g. "keydown"
   *        console.log(event.detail.keyboardEvent); // the original KeyboardEvent
   *      }
   *
   * Use the `keyEventTarget` attribute to set up event handlers on a specific
   * node.
   *
   * See the [demo source code](https://github.com/PolymerElements/iron-a11y-keys-behavior/blob/master/demo/x-key-aware.html)
   * for an example.
   *
   * @demo demo/index.html
   * @polymerBehavior
   */
  Polymer.IronA11yKeysBehavior = {
    properties: {
      /**
       * The EventTarget that will be firing relevant KeyboardEvents. Set it to
       * `null` to disable the listeners.
       * @type {?EventTarget}
       */
      keyEventTarget: {
        type: Object,
        value: function value() {
          return this;
        }
      },

      /**
       * If true, this property will cause the implementing element to
       * automatically stop propagation on any handled KeyboardEvents.
       */
      stopKeyboardEventPropagation: {
        type: Boolean,
        value: false
      },

      _boundKeyHandlers: {
        type: Array,
        value: function value() {
          return [];
        }
      },

      // We use this due to a limitation in IE10 where instances will have
      // own properties of everything on the "prototype".
      _imperativeKeyBindings: {
        type: Object,
        value: function value() {
          return {};
        }
      }
    },

    observers: ['_resetKeyEventListeners(keyEventTarget, _boundKeyHandlers)'],

    /**
     * To be used to express what combination of keys  will trigger the relative
     * callback. e.g. `keyBindings: { 'esc': '_onEscPressed'}`
     * @type {!Object}
     */
    keyBindings: {},

    registered: function registered() {
      this._prepKeyBindings();
    },

    attached: function attached() {
      this._listenKeyEventListeners();
    },

    detached: function detached() {
      this._unlistenKeyEventListeners();
    },

    /**
     * Can be used to imperatively add a key binding to the implementing
     * element. This is the imperative equivalent of declaring a keybinding
     * in the `keyBindings` prototype property.
     */
    addOwnKeyBinding: function addOwnKeyBinding(eventString, handlerName) {
      this._imperativeKeyBindings[eventString] = handlerName;
      this._prepKeyBindings();
      this._resetKeyEventListeners();
    },

    /**
     * When called, will remove all imperatively-added key bindings.
     */
    removeOwnKeyBindings: function removeOwnKeyBindings() {
      this._imperativeKeyBindings = {};
      this._prepKeyBindings();
      this._resetKeyEventListeners();
    },

    /**
     * Returns true if a keyboard event matches `eventString`.
     *
     * @param {KeyboardEvent} event
     * @param {string} eventString
     * @return {boolean}
     */
    keyboardEventMatchesKeys: function keyboardEventMatchesKeys(event, eventString) {
      var keyCombos = parseEventString(eventString);
      for (var i = 0; i < keyCombos.length; ++i) {
        if (keyComboMatchesEvent(keyCombos[i], event)) {
          return true;
        }
      }
      return false;
    },

    _collectKeyBindings: function _collectKeyBindings() {
      var keyBindings = this.behaviors.map(function (behavior) {
        return behavior.keyBindings;
      });

      if (keyBindings.indexOf(this.keyBindings) === -1) {
        keyBindings.push(this.keyBindings);
      }

      return keyBindings;
    },

    _prepKeyBindings: function _prepKeyBindings() {
      this._keyBindings = {};

      this._collectKeyBindings().forEach(function (keyBindings) {
        for (var eventString in keyBindings) {
          this._addKeyBinding(eventString, keyBindings[eventString]);
        }
      }, this);

      for (var eventString in this._imperativeKeyBindings) {
        this._addKeyBinding(eventString, this._imperativeKeyBindings[eventString]);
      }

      // Give precedence to combos with modifiers to be checked first.
      for (var eventName in this._keyBindings) {
        this._keyBindings[eventName].sort(function (kb1, kb2) {
          var b1 = kb1[0].hasModifiers;
          var b2 = kb2[0].hasModifiers;
          return b1 === b2 ? 0 : b1 ? -1 : 1;
        });
      }
    },

    _addKeyBinding: function _addKeyBinding(eventString, handlerName) {
      parseEventString(eventString).forEach(function (keyCombo) {
        this._keyBindings[keyCombo.event] = this._keyBindings[keyCombo.event] || [];

        this._keyBindings[keyCombo.event].push([keyCombo, handlerName]);
      }, this);
    },

    _resetKeyEventListeners: function _resetKeyEventListeners() {
      this._unlistenKeyEventListeners();

      if (this.isAttached) {
        this._listenKeyEventListeners();
      }
    },

    _listenKeyEventListeners: function _listenKeyEventListeners() {
      if (!this.keyEventTarget) {
        return;
      }
      Object.keys(this._keyBindings).forEach(function (eventName) {
        var keyBindings = this._keyBindings[eventName];
        var boundKeyHandler = this._onKeyBindingEvent.bind(this, keyBindings);

        this._boundKeyHandlers.push([this.keyEventTarget, eventName, boundKeyHandler]);

        this.keyEventTarget.addEventListener(eventName, boundKeyHandler);
      }, this);
    },

    _unlistenKeyEventListeners: function _unlistenKeyEventListeners() {
      var keyHandlerTuple;
      var keyEventTarget;
      var eventName;
      var boundKeyHandler;

      while (this._boundKeyHandlers.length) {
        // My kingdom for block-scope binding and destructuring assignment..
        keyHandlerTuple = this._boundKeyHandlers.pop();
        keyEventTarget = keyHandlerTuple[0];
        eventName = keyHandlerTuple[1];
        boundKeyHandler = keyHandlerTuple[2];

        keyEventTarget.removeEventListener(eventName, boundKeyHandler);
      }
    },

    _onKeyBindingEvent: function _onKeyBindingEvent(keyBindings, event) {
      if (this.stopKeyboardEventPropagation) {
        event.stopPropagation();
      }

      // if event has been already prevented, don't do anything
      if (event.defaultPrevented) {
        return;
      }

      for (var i = 0; i < keyBindings.length; i++) {
        var keyCombo = keyBindings[i][0];
        var handlerName = keyBindings[i][1];
        if (keyComboMatchesEvent(keyCombo, event)) {
          this._triggerKeyHandler(keyCombo, handlerName, event);
          // exit the loop if eventDefault was prevented
          if (event.defaultPrevented) {
            return;
          }
        }
      }
    },

    _triggerKeyHandler: function _triggerKeyHandler(keyCombo, handlerName, keyboardEvent) {
      var detail = Object.create(keyCombo);
      detail.keyboardEvent = keyboardEvent;
      var event = new CustomEvent(keyCombo.event, {
        detail: detail,
        cancelable: true
      });
      this[handlerName].call(this, event);
      if (event.defaultPrevented) {
        keyboardEvent.preventDefault();
      }
    }
  };
})();</script><script>

/**
 * `Polymer.IronMenuBehavior` implements accessible menu behavior.
 *
 * @demo demo/index.html
 * @polymerBehavior Polymer.IronMenuBehavior
 */
Polymer.IronMenuBehaviorImpl = {

  properties: {

    /**
     * Returns the currently focused item.
     * @type {?Object}
     */
    focusedItem: {
      observer: '_focusedItemChanged',
      readOnly: true,
      type: Object
    },

    /**
     * The attribute to use on menu items to look up the item title. Typing the first
     * letter of an item when the menu is open focuses that item. If unset, `textContent`
     * will be used.
     */
    attrForItemTitle: {
      type: String
    },

    disabled: {
      type: Boolean,
      value: false,
      observer: '_disabledChanged'
    }
  },

  _SEARCH_RESET_TIMEOUT_MS: 1000,

  _previousTabIndex: 0,

  hostAttributes: {
    'role': 'menu'
  },

  observers: ['_updateMultiselectable(multi)'],

  listeners: {
    'focus': '_onFocus',
    'keydown': '_onKeydown',
    'iron-items-changed': '_onIronItemsChanged'
  },

  keyBindings: {
    'up': '_onUpKey',
    'down': '_onDownKey',
    'esc': '_onEscKey',
    'shift+tab:keydown': '_onShiftTabDown'
  },

  attached: function attached() {
    this._resetTabindices();
  },

  /**
   * Selects the given value. If the `multi` property is true, then the selected state of the
   * `value` will be toggled; otherwise the `value` will be selected.
   *
   * @param {string|number} value the value to select.
   */
  select: function select(value) {
    // Cancel automatically focusing a default item if the menu received focus
    // through a user action selecting a particular item.
    if (this._defaultFocusAsync) {
      this.cancelAsync(this._defaultFocusAsync);
      this._defaultFocusAsync = null;
    }
    var item = this._valueToItem(value);
    if (item && item.hasAttribute('disabled')) return;
    this._setFocusedItem(item);
    Polymer.IronMultiSelectableBehaviorImpl.select.apply(this, arguments);
  },

  /**
   * Resets all tabindex attributes to the appropriate value based on the
   * current selection state. The appropriate value is `0` (focusable) for
   * the default selected item, and `-1` (not keyboard focusable) for all
   * other items.
   */
  _resetTabindices: function _resetTabindices() {
    var selectedItem = this.multi ? this.selectedItems && this.selectedItems[0] : this.selectedItem;

    this.items.forEach(function (item) {
      item.setAttribute('tabindex', item === selectedItem ? '0' : '-1');
    }, this);
  },

  /**
   * Sets appropriate ARIA based on whether or not the menu is meant to be
   * multi-selectable.
   *
   * @param {boolean} multi True if the menu should be multi-selectable.
   */
  _updateMultiselectable: function _updateMultiselectable(multi) {
    if (multi) {
      this.setAttribute('aria-multiselectable', 'true');
    } else {
      this.removeAttribute('aria-multiselectable');
    }
  },

  /**
   * Given a KeyboardEvent, this method will focus the appropriate item in the
   * menu (if there is a relevant item, and it is possible to focus it).
   *
   * @param {KeyboardEvent} event A KeyboardEvent.
   */
  _focusWithKeyboardEvent: function _focusWithKeyboardEvent(event) {
    this.cancelDebouncer('_clearSearchText');

    var searchText = this._searchText || '';
    var key = event.key && event.key.length == 1 ? event.key : String.fromCharCode(event.keyCode);
    searchText += key.toLocaleLowerCase();

    var searchLength = searchText.length;

    for (var i = 0, item; item = this.items[i]; i++) {
      if (item.hasAttribute('disabled')) {
        continue;
      }

      var attr = this.attrForItemTitle || 'textContent';
      var title = (item[attr] || item.getAttribute(attr) || '').trim();

      if (title.length < searchLength) {
        continue;
      }

      if (title.slice(0, searchLength).toLocaleLowerCase() == searchText) {
        this._setFocusedItem(item);
        break;
      }
    }

    this._searchText = searchText;
    this.debounce('_clearSearchText', this._clearSearchText, this._SEARCH_RESET_TIMEOUT_MS);
  },

  _clearSearchText: function _clearSearchText() {
    this._searchText = '';
  },

  /**
   * Focuses the previous item (relative to the currently focused item) in the
   * menu, disabled items will be skipped.
   * Loop until length + 1 to handle case of single item in menu.
   */
  _focusPrevious: function _focusPrevious() {
    var length = this.items.length;
    var curFocusIndex = Number(this.indexOf(this.focusedItem));

    for (var i = 1; i < length + 1; i++) {
      var item = this.items[(curFocusIndex - i + length) % length];
      if (!item.hasAttribute('disabled')) {
        var owner = Polymer.dom(item).getOwnerRoot() || document;
        this._setFocusedItem(item);

        // Focus might not have worked, if the element was hidden or not
        // focusable. In that case, try again.
        if (Polymer.dom(owner).activeElement == item) {
          return;
        }
      }
    }
  },

  /**
   * Focuses the next item (relative to the currently focused item) in the
   * menu, disabled items will be skipped.
   * Loop until length + 1 to handle case of single item in menu.
   */
  _focusNext: function _focusNext() {
    var length = this.items.length;
    var curFocusIndex = Number(this.indexOf(this.focusedItem));

    for (var i = 1; i < length + 1; i++) {
      var item = this.items[(curFocusIndex + i) % length];
      if (!item.hasAttribute('disabled')) {
        var owner = Polymer.dom(item).getOwnerRoot() || document;
        this._setFocusedItem(item);

        // Focus might not have worked, if the element was hidden or not
        // focusable. In that case, try again.
        if (Polymer.dom(owner).activeElement == item) {
          return;
        }
      }
    }
  },

  /**
   * Mutates items in the menu based on provided selection details, so that
   * all items correctly reflect selection state.
   *
   * @param {Element} item An item in the menu.
   * @param {boolean} isSelected True if the item should be shown in a
   * selected state, otherwise false.
   */
  _applySelection: function _applySelection(item, isSelected) {
    if (isSelected) {
      item.setAttribute('aria-selected', 'true');
    } else {
      item.removeAttribute('aria-selected');
    }
    Polymer.IronSelectableBehavior._applySelection.apply(this, arguments);
  },

  /**
   * Discretely updates tabindex values among menu items as the focused item
   * changes.
   *
   * @param {Element} focusedItem The element that is currently focused.
   * @param {?Element} old The last element that was considered focused, if
   * applicable.
   */
  _focusedItemChanged: function _focusedItemChanged(focusedItem, old) {
    old && old.setAttribute('tabindex', '-1');
    if (focusedItem && !focusedItem.hasAttribute('disabled') && !this.disabled) {
      focusedItem.setAttribute('tabindex', '0');
      focusedItem.focus();
    }
  },

  /**
   * A handler that responds to mutation changes related to the list of items
   * in the menu.
   *
   * @param {CustomEvent} event An event containing mutation records as its
   * detail.
   */
  _onIronItemsChanged: function _onIronItemsChanged(event) {
    if (event.detail.addedNodes.length) {
      this._resetTabindices();
    }
  },

  /**
   * Handler that is called when a shift+tab keypress is detected by the menu.
   *
   * @param {CustomEvent} event A key combination event.
   */
  _onShiftTabDown: function _onShiftTabDown(event) {
    var oldTabIndex = this.getAttribute('tabindex');

    Polymer.IronMenuBehaviorImpl._shiftTabPressed = true;

    this._setFocusedItem(null);

    this.setAttribute('tabindex', '-1');

    this.async(function () {
      this.setAttribute('tabindex', oldTabIndex);
      Polymer.IronMenuBehaviorImpl._shiftTabPressed = false;
      // NOTE(cdata): polymer/polymer#1305
    }, 1);
  },

  /**
   * Handler that is called when the menu receives focus.
   *
   * @param {FocusEvent} event A focus event.
   */
  _onFocus: function _onFocus(event) {
    if (Polymer.IronMenuBehaviorImpl._shiftTabPressed) {
      // do not focus the menu itself
      return;
    }

    // Do not focus the selected tab if the deepest target is part of the
    // menu element's local DOM and is focusable.
    var rootTarget = /** @type {?HTMLElement} */Polymer.dom(event).rootTarget;
    if (rootTarget !== this && typeof rootTarget.tabIndex !== "undefined" && !this.isLightDescendant(rootTarget)) {
      return;
    }

    // clear the cached focus item
    this._defaultFocusAsync = this.async(function () {
      // focus the selected item when the menu receives focus, or the first item
      // if no item is selected
      var selectedItem = this.multi ? this.selectedItems && this.selectedItems[0] : this.selectedItem;

      this._setFocusedItem(null);

      if (selectedItem) {
        this._setFocusedItem(selectedItem);
      } else if (this.items[0]) {
        // We find the first none-disabled item (if one exists)
        this._focusNext();
      }
    });
  },

  /**
   * Handler that is called when the up key is pressed.
   *
   * @param {CustomEvent} event A key combination event.
   */
  _onUpKey: function _onUpKey(event) {
    // up and down arrows moves the focus
    this._focusPrevious();
    event.detail.keyboardEvent.preventDefault();
  },

  /**
   * Handler that is called when the down key is pressed.
   *
   * @param {CustomEvent} event A key combination event.
   */
  _onDownKey: function _onDownKey(event) {
    this._focusNext();
    event.detail.keyboardEvent.preventDefault();
  },

  /**
   * Handler that is called when the esc key is pressed.
   *
   * @param {CustomEvent} event A key combination event.
   */
  _onEscKey: function _onEscKey(event) {
    // esc blurs the control
    this.focusedItem.blur();
  },

  /**
   * Handler that is called when a keydown event is detected.
   *
   * @param {KeyboardEvent} event A keyboard event.
   */
  _onKeydown: function _onKeydown(event) {
    if (!this.keyboardEventMatchesKeys(event, 'up down esc')) {
      // all other keys focus the menu item starting with that character
      this._focusWithKeyboardEvent(event);
    }
    event.stopPropagation();
  },

  // override _activateHandler
  _activateHandler: function _activateHandler(event) {
    Polymer.IronSelectableBehavior._activateHandler.call(this, event);
    event.stopPropagation();
  },

  /**
   * Updates this element's tab index when it's enabled/disabled.
   * @param {boolean} disabled
   */
  _disabledChanged: function _disabledChanged(disabled) {
    if (disabled) {
      this._previousTabIndex = this.hasAttribute('tabindex') ? this.tabIndex : 0;
      this.removeAttribute('tabindex'); // No tabindex means not tab-able or select-able.
    } else if (!this.hasAttribute('tabindex')) {
      this.setAttribute('tabindex', this._previousTabIndex);
    }
  }
};

Polymer.IronMenuBehaviorImpl._shiftTabPressed = false;

/** @polymerBehavior Polymer.IronMenuBehavior */
Polymer.IronMenuBehavior = [Polymer.IronMultiSelectableBehavior, Polymer.IronA11yKeysBehavior, Polymer.IronMenuBehaviorImpl];</script><script>

/**
 * `Polymer.IronMenubarBehavior` implements accessible menubar behavior.
 *
 * @polymerBehavior Polymer.IronMenubarBehavior
 */
Polymer.IronMenubarBehaviorImpl = {

  hostAttributes: {
    'role': 'menubar'
  },

  keyBindings: {
    'left': '_onLeftKey',
    'right': '_onRightKey'
  },

  _onUpKey: function _onUpKey(event) {
    this.focusedItem.click();
    event.detail.keyboardEvent.preventDefault();
  },

  _onDownKey: function _onDownKey(event) {
    this.focusedItem.click();
    event.detail.keyboardEvent.preventDefault();
  },

  get _isRTL() {
    return window.getComputedStyle(this)['direction'] === 'rtl';
  },

  _onLeftKey: function _onLeftKey(event) {
    if (this._isRTL) {
      this._focusNext();
    } else {
      this._focusPrevious();
    }
    event.detail.keyboardEvent.preventDefault();
  },

  _onRightKey: function _onRightKey(event) {
    if (this._isRTL) {
      this._focusPrevious();
    } else {
      this._focusNext();
    }
    event.detail.keyboardEvent.preventDefault();
  },

  _onKeydown: function _onKeydown(event) {
    if (this.keyboardEventMatchesKeys(event, 'up down left right esc')) {
      return;
    }

    // all other keys focus the menu item starting with that character
    this._focusWithKeyboardEvent(event);
  }

};

/** @polymerBehavior Polymer.IronMenubarBehavior */
Polymer.IronMenubarBehavior = [Polymer.IronMenuBehavior, Polymer.IronMenubarBehaviorImpl];</script><script>
/**
 * `IronResizableBehavior` is a behavior that can be used in Polymer elements to
 * coordinate the flow of resize events between "resizers" (elements that control the
 * size or hidden state of their children) and "resizables" (elements that need to be
 * notified when they are resized or un-hidden by their parents in order to take
 * action on their new measurements).
 *
 * Elements that perform measurement should add the `IronResizableBehavior` behavior to
 * their element definition and listen for the `iron-resize` event on themselves.
 * This event will be fired when they become showing after having been hidden,
 * when they are resized explicitly by another resizable, or when the window has been
 * resized.
 *
 * Note, the `iron-resize` event is non-bubbling.
 *
 * @polymerBehavior Polymer.IronResizableBehavior
 * @demo demo/index.html
 **/
Polymer.IronResizableBehavior = {
  properties: {
    /**
     * The closest ancestor element that implements `IronResizableBehavior`.
     */
    _parentResizable: {
      type: Object,
      observer: '_parentResizableChanged'
    },

    /**
     * True if this element is currently notifying its descendant elements of
     * resize.
     */
    _notifyingDescendant: {
      type: Boolean,
      value: false
    }
  },

  listeners: {
    'iron-request-resize-notifications': '_onIronRequestResizeNotifications'
  },

  created: function created() {
    // We don't really need property effects on these, and also we want them
    // to be created before the `_parentResizable` observer fires:
    this._interestedResizables = [];
    this._boundNotifyResize = this.notifyResize.bind(this);
  },

  attached: function attached() {
    this.fire('iron-request-resize-notifications', null, {
      node: this,
      bubbles: true,
      cancelable: true
    });

    if (!this._parentResizable) {
      window.addEventListener('resize', this._boundNotifyResize);
      this.notifyResize();
    }
  },

  detached: function detached() {
    if (this._parentResizable) {
      this._parentResizable.stopResizeNotificationsFor(this);
    } else {
      window.removeEventListener('resize', this._boundNotifyResize);
    }

    this._parentResizable = null;
  },

  /**
   * Can be called to manually notify a resizable and its descendant
   * resizables of a resize change.
   */
  notifyResize: function notifyResize() {
    if (!this.isAttached) {
      return;
    }

    this._interestedResizables.forEach(function (resizable) {
      if (this.resizerShouldNotify(resizable)) {
        this._notifyDescendant(resizable);
      }
    }, this);

    this._fireResize();
  },

  /**
   * Used to assign the closest resizable ancestor to this resizable
   * if the ancestor detects a request for notifications.
   */
  assignParentResizable: function assignParentResizable(parentResizable) {
    this._parentResizable = parentResizable;
  },

  /**
   * Used to remove a resizable descendant from the list of descendants
   * that should be notified of a resize change.
   */
  stopResizeNotificationsFor: function stopResizeNotificationsFor(target) {
    var index = this._interestedResizables.indexOf(target);

    if (index > -1) {
      this._interestedResizables.splice(index, 1);
      this.unlisten(target, 'iron-resize', '_onDescendantIronResize');
    }
  },

  /**
   * This method can be overridden to filter nested elements that should or
   * should not be notified by the current element. Return true if an element
   * should be notified, or false if it should not be notified.
   *
   * @param {HTMLElement} element A candidate descendant element that
   * implements `IronResizableBehavior`.
   * @return {boolean} True if the `element` should be notified of resize.
   */
  resizerShouldNotify: function resizerShouldNotify(element) {
    return true;
  },

  _onDescendantIronResize: function _onDescendantIronResize(event) {
    if (this._notifyingDescendant) {
      event.stopPropagation();
      return;
    }

    // NOTE(cdata): In ShadowDOM, event retargeting makes echoing of the
    // otherwise non-bubbling event "just work." We do it manually here for
    // the case where Polymer is not using shadow roots for whatever reason:
    if (!Polymer.Settings.useShadow) {
      this._fireResize();
    }
  },

  _fireResize: function _fireResize() {
    this.fire('iron-resize', null, {
      node: this,
      bubbles: false
    });
  },

  _onIronRequestResizeNotifications: function _onIronRequestResizeNotifications(event) {
    var target = event.path ? event.path[0] : event.target;

    if (target === this) {
      return;
    }

    if (this._interestedResizables.indexOf(target) === -1) {
      this._interestedResizables.push(target);
      this.listen(target, 'iron-resize', '_onDescendantIronResize');
    }

    target.assignParentResizable(this);
    this._notifyDescendant(target);

    event.stopPropagation();
  },

  _parentResizableChanged: function _parentResizableChanged(parentResizable) {
    if (parentResizable) {
      window.removeEventListener('resize', this._boundNotifyResize);
    }
  },

  _notifyDescendant: function _notifyDescendant(descendant) {
    // NOTE(cdata): In IE10, attached is fired on children first, so it's
    // important not to notify them if the parent is not attached yet (or
    // else they will get redundantly notified when the parent attaches).
    if (!this.isAttached) {
      return;
    }

    this._notifyingDescendant = true;
    descendant.notifyResize();
    this._notifyingDescendant = false;
  }
};</script><script>

/**
 * @demo demo/index.html
 * @polymerBehavior
 */
Polymer.IronControlState = {

  properties: {

    /**
     * If true, the element currently has focus.
     */
    focused: {
      type: Boolean,
      value: false,
      notify: true,
      readOnly: true,
      reflectToAttribute: true
    },

    /**
     * If true, the user cannot interact with this element.
     */
    disabled: {
      type: Boolean,
      value: false,
      notify: true,
      observer: '_disabledChanged',
      reflectToAttribute: true
    },

    _oldTabIndex: {
      type: Number
    },

    _boundFocusBlurHandler: {
      type: Function,
      value: function value() {
        return this._focusBlurHandler.bind(this);
      }
    }

  },

  observers: ['_changedControlState(focused, disabled)'],

  ready: function ready() {
    this.addEventListener('focus', this._boundFocusBlurHandler, true);
    this.addEventListener('blur', this._boundFocusBlurHandler, true);
  },

  _focusBlurHandler: function _focusBlurHandler(event) {
    // NOTE(cdata):  if we are in ShadowDOM land, `event.target` will
    // eventually become `this` due to retargeting; if we are not in
    // ShadowDOM land, `event.target` will eventually become `this` due
    // to the second conditional which fires a synthetic event (that is also
    // handled). In either case, we can disregard `event.path`.

    if (event.target === this) {
      this._setFocused(event.type === 'focus');
    } else if (!this.shadowRoot) {
      var target = /** @type {Node} */Polymer.dom(event).localTarget;
      if (!this.isLightDescendant(target)) {
        this.fire(event.type, { sourceEvent: event }, {
          node: this,
          bubbles: event.bubbles,
          cancelable: event.cancelable
        });
      }
    }
  },

  _disabledChanged: function _disabledChanged(disabled, old) {
    this.setAttribute('aria-disabled', disabled ? 'true' : 'false');
    this.style.pointerEvents = disabled ? 'none' : '';
    if (disabled) {
      this._oldTabIndex = this.tabIndex;
      this._setFocused(false);
      this.tabIndex = -1;
      this.blur();
    } else if (this._oldTabIndex !== undefined) {
      this.tabIndex = this._oldTabIndex;
    }
  },

  _changedControlState: function _changedControlState() {
    // _controlStateChanged is abstract, follow-on behaviors may implement it
    if (this._controlStateChanged) {
      this._controlStateChanged();
    }
  }

};</script><script>

/**
 * @demo demo/index.html
 * @polymerBehavior Polymer.IronButtonState
 */
Polymer.IronButtonStateImpl = {

  properties: {

    /**
     * If true, the user is currently holding down the button.
     */
    pressed: {
      type: Boolean,
      readOnly: true,
      value: false,
      reflectToAttribute: true,
      observer: '_pressedChanged'
    },

    /**
     * If true, the button toggles the active state with each tap or press
     * of the spacebar.
     */
    toggles: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    },

    /**
     * If true, the button is a toggle and is currently in the active state.
     */
    active: {
      type: Boolean,
      value: false,
      notify: true,
      reflectToAttribute: true
    },

    /**
     * True if the element is currently being pressed by a "pointer," which
     * is loosely defined as mouse or touch input (but specifically excluding
     * keyboard input).
     */
    pointerDown: {
      type: Boolean,
      readOnly: true,
      value: false
    },

    /**
     * True if the input device that caused the element to receive focus
     * was a keyboard.
     */
    receivedFocusFromKeyboard: {
      type: Boolean,
      readOnly: true
    },

    /**
     * The aria attribute to be set if the button is a toggle and in the
     * active state.
     */
    ariaActiveAttribute: {
      type: String,
      value: 'aria-pressed',
      observer: '_ariaActiveAttributeChanged'
    }
  },

  listeners: {
    down: '_downHandler',
    up: '_upHandler',
    tap: '_tapHandler'
  },

  observers: ['_focusChanged(focused)', '_activeChanged(active, ariaActiveAttribute)'],

  keyBindings: {
    'enter:keydown': '_asyncClick',
    'space:keydown': '_spaceKeyDownHandler',
    'space:keyup': '_spaceKeyUpHandler'
  },

  _mouseEventRe: /^mouse/,

  _tapHandler: function _tapHandler() {
    if (this.toggles) {
      // a tap is needed to toggle the active state
      this._userActivate(!this.active);
    } else {
      this.active = false;
    }
  },

  _focusChanged: function _focusChanged(focused) {
    this._detectKeyboardFocus(focused);

    if (!focused) {
      this._setPressed(false);
    }
  },

  _detectKeyboardFocus: function _detectKeyboardFocus(focused) {
    this._setReceivedFocusFromKeyboard(!this.pointerDown && focused);
  },

  // to emulate native checkbox, (de-)activations from a user interaction fire
  // 'change' events
  _userActivate: function _userActivate(active) {
    if (this.active !== active) {
      this.active = active;
      this.fire('change');
    }
  },

  _downHandler: function _downHandler(event) {
    this._setPointerDown(true);
    this._setPressed(true);
    this._setReceivedFocusFromKeyboard(false);
  },

  _upHandler: function _upHandler() {
    this._setPointerDown(false);
    this._setPressed(false);
  },

  /**
   * @param {!KeyboardEvent} event .
   */
  _spaceKeyDownHandler: function _spaceKeyDownHandler(event) {
    var keyboardEvent = event.detail.keyboardEvent;
    var target = Polymer.dom(keyboardEvent).localTarget;

    // Ignore the event if this is coming from a focused light child, since that
    // element will deal with it.
    if (this.isLightDescendant( /** @type {Node} */target)) return;

    keyboardEvent.preventDefault();
    keyboardEvent.stopImmediatePropagation();
    this._setPressed(true);
  },

  /**
   * @param {!KeyboardEvent} event .
   */
  _spaceKeyUpHandler: function _spaceKeyUpHandler(event) {
    var keyboardEvent = event.detail.keyboardEvent;
    var target = Polymer.dom(keyboardEvent).localTarget;

    // Ignore the event if this is coming from a focused light child, since that
    // element will deal with it.
    if (this.isLightDescendant( /** @type {Node} */target)) return;

    if (this.pressed) {
      this._asyncClick();
    }
    this._setPressed(false);
  },

  // trigger click asynchronously, the asynchrony is useful to allow one
  // event handler to unwind before triggering another event
  _asyncClick: function _asyncClick() {
    this.async(function () {
      this.click();
    }, 1);
  },

  // any of these changes are considered a change to button state

  _pressedChanged: function _pressedChanged(pressed) {
    this._changedButtonState();
  },

  _ariaActiveAttributeChanged: function _ariaActiveAttributeChanged(value, oldValue) {
    if (oldValue && oldValue != value && this.hasAttribute(oldValue)) {
      this.removeAttribute(oldValue);
    }
  },

  _activeChanged: function _activeChanged(active, ariaActiveAttribute) {
    if (this.toggles) {
      this.setAttribute(this.ariaActiveAttribute, active ? 'true' : 'false');
    } else {
      this.removeAttribute(this.ariaActiveAttribute);
    }
    this._changedButtonState();
  },

  _controlStateChanged: function _controlStateChanged() {
    if (this.disabled) {
      this._setPressed(false);
    } else {
      this._changedButtonState();
    }
  },

  // provide hook for follow-on behaviors to react to button-state

  _changedButtonState: function _changedButtonState() {
    if (this._buttonStateChanged) {
      this._buttonStateChanged(); // abstract
    }
  }

};

/** @polymerBehavior */
Polymer.IronButtonState = [Polymer.IronA11yKeysBehavior, Polymer.IronButtonStateImpl];</script><dom-module id="paper-ripple" assetpath="../bower_components/paper-ripple/"><template><style>:host{display:block;position:absolute;border-radius:inherit;overflow:hidden;top:0;left:0;right:0;bottom:0;pointer-events:none;}:host([animating]){-webkit-transform:translate(0, 0);transform:translate3d(0, 0, 0);}#background,
      #waves,
      .wave-container,
      .wave{pointer-events:none;position:absolute;top:0;left:0;width:100%;height:100%;}#background,
      .wave{opacity:0;}#waves,
      .wave{overflow:hidden;}.wave-container,
      .wave{border-radius:50%;}:host(.circle) #background,
      :host(.circle) #waves{border-radius:50%;}:host(.circle) .wave-container{overflow:hidden;}</style><div id="background"></div><div id="waves"></div></template></dom-module><script>
(function () {
  var Utility = {
    distance: function distance(x1, y1, x2, y2) {
      var xDelta = x1 - x2;
      var yDelta = y1 - y2;

      return Math.sqrt(xDelta * xDelta + yDelta * yDelta);
    },

    now: window.performance && window.performance.now ? window.performance.now.bind(window.performance) : Date.now
  };

  /**
   * @param {HTMLElement} element
   * @constructor
   */
  function ElementMetrics(element) {
    this.element = element;
    this.width = this.boundingRect.width;
    this.height = this.boundingRect.height;

    this.size = Math.max(this.width, this.height);
  }

  ElementMetrics.prototype = {
    get boundingRect() {
      return this.element.getBoundingClientRect();
    },

    furthestCornerDistanceFrom: function furthestCornerDistanceFrom(x, y) {
      var topLeft = Utility.distance(x, y, 0, 0);
      var topRight = Utility.distance(x, y, this.width, 0);
      var bottomLeft = Utility.distance(x, y, 0, this.height);
      var bottomRight = Utility.distance(x, y, this.width, this.height);

      return Math.max(topLeft, topRight, bottomLeft, bottomRight);
    }
  };

  /**
   * @param {HTMLElement} element
   * @constructor
   */
  function Ripple(element) {
    this.element = element;
    this.color = window.getComputedStyle(element).color;

    this.wave = document.createElement('div');
    this.waveContainer = document.createElement('div');
    this.wave.style.backgroundColor = this.color;
    this.wave.classList.add('wave');
    this.waveContainer.classList.add('wave-container');
    Polymer.dom(this.waveContainer).appendChild(this.wave);

    this.resetInteractionState();
  }

  Ripple.MAX_RADIUS = 300;

  Ripple.prototype = {
    get recenters() {
      return this.element.recenters;
    },

    get center() {
      return this.element.center;
    },

    get mouseDownElapsed() {
      var elapsed;

      if (!this.mouseDownStart) {
        return 0;
      }

      elapsed = Utility.now() - this.mouseDownStart;

      if (this.mouseUpStart) {
        elapsed -= this.mouseUpElapsed;
      }

      return elapsed;
    },

    get mouseUpElapsed() {
      return this.mouseUpStart ? Utility.now() - this.mouseUpStart : 0;
    },

    get mouseDownElapsedSeconds() {
      return this.mouseDownElapsed / 1000;
    },

    get mouseUpElapsedSeconds() {
      return this.mouseUpElapsed / 1000;
    },

    get mouseInteractionSeconds() {
      return this.mouseDownElapsedSeconds + this.mouseUpElapsedSeconds;
    },

    get initialOpacity() {
      return this.element.initialOpacity;
    },

    get opacityDecayVelocity() {
      return this.element.opacityDecayVelocity;
    },

    get radius() {
      var width2 = this.containerMetrics.width * this.containerMetrics.width;
      var height2 = this.containerMetrics.height * this.containerMetrics.height;
      var waveRadius = Math.min(Math.sqrt(width2 + height2), Ripple.MAX_RADIUS) * 1.1 + 5;

      var duration = 1.1 - 0.2 * (waveRadius / Ripple.MAX_RADIUS);
      var timeNow = this.mouseInteractionSeconds / duration;
      var size = waveRadius * (1 - Math.pow(80, -timeNow));

      return Math.abs(size);
    },

    get opacity() {
      if (!this.mouseUpStart) {
        return this.initialOpacity;
      }

      return Math.max(0, this.initialOpacity - this.mouseUpElapsedSeconds * this.opacityDecayVelocity);
    },

    get outerOpacity() {
      // Linear increase in background opacity, capped at the opacity
      // of the wavefront (waveOpacity).
      var outerOpacity = this.mouseUpElapsedSeconds * 0.3;
      var waveOpacity = this.opacity;

      return Math.max(0, Math.min(outerOpacity, waveOpacity));
    },

    get isOpacityFullyDecayed() {
      return this.opacity < 0.01 && this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
    },

    get isRestingAtMaxRadius() {
      return this.opacity >= this.initialOpacity && this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
    },

    get isAnimationComplete() {
      return this.mouseUpStart ? this.isOpacityFullyDecayed : this.isRestingAtMaxRadius;
    },

    get translationFraction() {
      return Math.min(1, this.radius / this.containerMetrics.size * 2 / Math.sqrt(2));
    },

    get xNow() {
      if (this.xEnd) {
        return this.xStart + this.translationFraction * (this.xEnd - this.xStart);
      }

      return this.xStart;
    },

    get yNow() {
      if (this.yEnd) {
        return this.yStart + this.translationFraction * (this.yEnd - this.yStart);
      }

      return this.yStart;
    },

    get isMouseDown() {
      return this.mouseDownStart && !this.mouseUpStart;
    },

    resetInteractionState: function resetInteractionState() {
      this.maxRadius = 0;
      this.mouseDownStart = 0;
      this.mouseUpStart = 0;

      this.xStart = 0;
      this.yStart = 0;
      this.xEnd = 0;
      this.yEnd = 0;
      this.slideDistance = 0;

      this.containerMetrics = new ElementMetrics(this.element);
    },

    draw: function draw() {
      var scale;
      var translateString;
      var dx;
      var dy;

      this.wave.style.opacity = this.opacity;

      scale = this.radius / (this.containerMetrics.size / 2);
      dx = this.xNow - this.containerMetrics.width / 2;
      dy = this.yNow - this.containerMetrics.height / 2;

      // 2d transform for safari because of border-radius and overflow:hidden clipping bug.
      // https://bugs.webkit.org/show_bug.cgi?id=98538
      this.waveContainer.style.webkitTransform = 'translate(' + dx + 'px, ' + dy + 'px)';
      this.waveContainer.style.transform = 'translate3d(' + dx + 'px, ' + dy + 'px, 0)';
      this.wave.style.webkitTransform = 'scale(' + scale + ',' + scale + ')';
      this.wave.style.transform = 'scale3d(' + scale + ',' + scale + ',1)';
    },

    /** @param {Event=} event */
    downAction: function downAction(event) {
      var xCenter = this.containerMetrics.width / 2;
      var yCenter = this.containerMetrics.height / 2;

      this.resetInteractionState();
      this.mouseDownStart = Utility.now();

      if (this.center) {
        this.xStart = xCenter;
        this.yStart = yCenter;
        this.slideDistance = Utility.distance(this.xStart, this.yStart, this.xEnd, this.yEnd);
      } else {
        this.xStart = event ? event.detail.x - this.containerMetrics.boundingRect.left : this.containerMetrics.width / 2;
        this.yStart = event ? event.detail.y - this.containerMetrics.boundingRect.top : this.containerMetrics.height / 2;
      }

      if (this.recenters) {
        this.xEnd = xCenter;
        this.yEnd = yCenter;
        this.slideDistance = Utility.distance(this.xStart, this.yStart, this.xEnd, this.yEnd);
      }

      this.maxRadius = this.containerMetrics.furthestCornerDistanceFrom(this.xStart, this.yStart);

      this.waveContainer.style.top = (this.containerMetrics.height - this.containerMetrics.size) / 2 + 'px';
      this.waveContainer.style.left = (this.containerMetrics.width - this.containerMetrics.size) / 2 + 'px';

      this.waveContainer.style.width = this.containerMetrics.size + 'px';
      this.waveContainer.style.height = this.containerMetrics.size + 'px';
    },

    /** @param {Event=} event */
    upAction: function upAction(event) {
      if (!this.isMouseDown) {
        return;
      }

      this.mouseUpStart = Utility.now();
    },

    remove: function remove() {
      Polymer.dom(this.waveContainer.parentNode).removeChild(this.waveContainer);
    }
  };

  Polymer({
    is: 'paper-ripple',

    behaviors: [Polymer.IronA11yKeysBehavior],

    properties: {
      /**
       * The initial opacity set on the wave.
       *
       * @attribute initialOpacity
       * @type number
       * @default 0.25
       */
      initialOpacity: {
        type: Number,
        value: 0.25
      },

      /**
       * How fast (opacity per second) the wave fades out.
       *
       * @attribute opacityDecayVelocity
       * @type number
       * @default 0.8
       */
      opacityDecayVelocity: {
        type: Number,
        value: 0.8
      },

      /**
       * If true, ripples will exhibit a gravitational pull towards
       * the center of their container as they fade away.
       *
       * @attribute recenters
       * @type boolean
       * @default false
       */
      recenters: {
        type: Boolean,
        value: false
      },

      /**
       * If true, ripples will center inside its container
       *
       * @attribute recenters
       * @type boolean
       * @default false
       */
      center: {
        type: Boolean,
        value: false
      },

      /**
       * A list of the visual ripples.
       *
       * @attribute ripples
       * @type Array
       * @default []
       */
      ripples: {
        type: Array,
        value: function value() {
          return [];
        }
      },

      /**
       * True when there are visible ripples animating within the
       * element.
       */
      animating: {
        type: Boolean,
        readOnly: true,
        reflectToAttribute: true,
        value: false
      },

      /**
       * If true, the ripple will remain in the "down" state until `holdDown`
       * is set to false again.
       */
      holdDown: {
        type: Boolean,
        value: false,
        observer: '_holdDownChanged'
      },

      /**
       * If true, the ripple will not generate a ripple effect
       * via pointer interaction.
       * Calling ripple's imperative api like `simulatedRipple` will
       * still generate the ripple effect.
       */
      noink: {
        type: Boolean,
        value: false
      },

      _animating: {
        type: Boolean
      },

      _boundAnimate: {
        type: Function,
        value: function value() {
          return this.animate.bind(this);
        }
      }
    },

    get target() {
      return this.keyEventTarget;
    },

    keyBindings: {
      'enter:keydown': '_onEnterKeydown',
      'space:keydown': '_onSpaceKeydown',
      'space:keyup': '_onSpaceKeyup'
    },

    attached: function attached() {
      // Set up a11yKeysBehavior to listen to key events on the target,
      // so that space and enter activate the ripple even if the target doesn't
      // handle key events. The key handlers deal with `noink` themselves.
      if (this.parentNode.nodeType == 11) {
        // DOCUMENT_FRAGMENT_NODE
        this.keyEventTarget = Polymer.dom(this).getOwnerRoot().host;
      } else {
        this.keyEventTarget = this.parentNode;
      }
      var keyEventTarget = /** @type {!EventTarget} */this.keyEventTarget;
      this.listen(keyEventTarget, 'up', 'uiUpAction');
      this.listen(keyEventTarget, 'down', 'uiDownAction');
    },

    detached: function detached() {
      this.unlisten(this.keyEventTarget, 'up', 'uiUpAction');
      this.unlisten(this.keyEventTarget, 'down', 'uiDownAction');
      this.keyEventTarget = null;
    },

    get shouldKeepAnimating() {
      for (var index = 0; index < this.ripples.length; ++index) {
        if (!this.ripples[index].isAnimationComplete) {
          return true;
        }
      }

      return false;
    },

    simulatedRipple: function simulatedRipple() {
      this.downAction(null);

      // Please see polymer/polymer#1305
      this.async(function () {
        this.upAction();
      }, 1);
    },

    /**
     * Provokes a ripple down effect via a UI event,
     * respecting the `noink` property.
     * @param {Event=} event
     */
    uiDownAction: function uiDownAction(event) {
      if (!this.noink) {
        this.downAction(event);
      }
    },

    /**
     * Provokes a ripple down effect via a UI event,
     * *not* respecting the `noink` property.
     * @param {Event=} event
     */
    downAction: function downAction(event) {
      if (this.holdDown && this.ripples.length > 0) {
        return;
      }

      var ripple = this.addRipple();

      ripple.downAction(event);

      if (!this._animating) {
        this._animating = true;
        this.animate();
      }
    },

    /**
     * Provokes a ripple up effect via a UI event,
     * respecting the `noink` property.
     * @param {Event=} event
     */
    uiUpAction: function uiUpAction(event) {
      if (!this.noink) {
        this.upAction(event);
      }
    },

    /**
     * Provokes a ripple up effect via a UI event,
     * *not* respecting the `noink` property.
     * @param {Event=} event
     */
    upAction: function upAction(event) {
      if (this.holdDown) {
        return;
      }

      this.ripples.forEach(function (ripple) {
        ripple.upAction(event);
      });

      this._animating = true;
      this.animate();
    },

    onAnimationComplete: function onAnimationComplete() {
      this._animating = false;
      this.$.background.style.backgroundColor = null;
      this.fire('transitionend');
    },

    addRipple: function addRipple() {
      var ripple = new Ripple(this);

      Polymer.dom(this.$.waves).appendChild(ripple.waveContainer);
      this.$.background.style.backgroundColor = ripple.color;
      this.ripples.push(ripple);

      this._setAnimating(true);

      return ripple;
    },

    removeRipple: function removeRipple(ripple) {
      var rippleIndex = this.ripples.indexOf(ripple);

      if (rippleIndex < 0) {
        return;
      }

      this.ripples.splice(rippleIndex, 1);

      ripple.remove();

      if (!this.ripples.length) {
        this._setAnimating(false);
      }
    },

    /**
     * This conflicts with Element#antimate().
     * https://developer.mozilla.org/en-US/docs/Web/API/Element/animate
     * @suppress {checkTypes}
     */
    animate: function animate() {
      if (!this._animating) {
        return;
      }
      var index;
      var ripple;

      for (index = 0; index < this.ripples.length; ++index) {
        ripple = this.ripples[index];

        ripple.draw();

        this.$.background.style.opacity = ripple.outerOpacity;

        if (ripple.isOpacityFullyDecayed && !ripple.isRestingAtMaxRadius) {
          this.removeRipple(ripple);
        }
      }

      if (!this.shouldKeepAnimating && this.ripples.length === 0) {
        this.onAnimationComplete();
      } else {
        window.requestAnimationFrame(this._boundAnimate);
      }
    },

    _onEnterKeydown: function _onEnterKeydown() {
      this.uiDownAction();
      this.async(this.uiUpAction, 1);
    },

    _onSpaceKeydown: function _onSpaceKeydown() {
      this.uiDownAction();
    },

    _onSpaceKeyup: function _onSpaceKeyup() {
      this.uiUpAction();
    },

    // note: holdDown does not respect noink since it can be a focus based
    // effect.
    _holdDownChanged: function _holdDownChanged(newVal, oldVal) {
      if (oldVal === undefined) {
        return;
      }
      if (newVal) {
        this.downAction();
      } else {
        this.upAction();
      }
    }

    /**
    Fired when the animation finishes.
    This is useful if you want to wait until
    the ripple animation finishes to perform some action.
     @event transitionend
    @param {{node: Object}} detail Contains the animated node.
    */
  });
})();</script><script>
/**
 * `Polymer.PaperRippleBehavior` dynamically implements a ripple
 * when the element has focus via pointer or keyboard.
 *
 * NOTE: This behavior is intended to be used in conjunction with and after
 * `Polymer.IronButtonState` and `Polymer.IronControlState`.
 *
 * @polymerBehavior Polymer.PaperRippleBehavior
 */
Polymer.PaperRippleBehavior = {
  properties: {
    /**
     * If true, the element will not produce a ripple effect when interacted
     * with via the pointer.
     */
    noink: {
      type: Boolean,
      observer: '_noinkChanged'
    },

    /**
     * @type {Element|undefined}
     */
    _rippleContainer: {
      type: Object
    }
  },

  /**
   * Ensures a `<paper-ripple>` element is available when the element is
   * focused.
   */
  _buttonStateChanged: function _buttonStateChanged() {
    if (this.focused) {
      this.ensureRipple();
    }
  },

  /**
   * In addition to the functionality provided in `IronButtonState`, ensures
   * a ripple effect is created when the element is in a `pressed` state.
   */
  _downHandler: function _downHandler(event) {
    Polymer.IronButtonStateImpl._downHandler.call(this, event);
    if (this.pressed) {
      this.ensureRipple(event);
    }
  },

  /**
   * Ensures this element contains a ripple effect. For startup efficiency
   * the ripple effect is dynamically on demand when needed.
   * @param {!Event=} optTriggeringEvent (optional) event that triggered the
   * ripple.
   */
  ensureRipple: function ensureRipple(optTriggeringEvent) {
    if (!this.hasRipple()) {
      this._ripple = this._createRipple();
      this._ripple.noink = this.noink;
      var rippleContainer = this._rippleContainer || this.root;
      if (rippleContainer) {
        Polymer.dom(rippleContainer).appendChild(this._ripple);
      }
      if (optTriggeringEvent) {
        // Check if the event happened inside of the ripple container
        // Fall back to host instead of the root because distributed text
        // nodes are not valid event targets
        var domContainer = Polymer.dom(this._rippleContainer || this);
        var target = Polymer.dom(optTriggeringEvent).rootTarget;
        if (domContainer.deepContains( /** @type {Node} */target)) {
          this._ripple.uiDownAction(optTriggeringEvent);
        }
      }
    }
  },

  /**
   * Returns the `<paper-ripple>` element used by this element to create
   * ripple effects. The element's ripple is created on demand, when
   * necessary, and calling this method will force the
   * ripple to be created.
   */
  getRipple: function getRipple() {
    this.ensureRipple();
    return this._ripple;
  },

  /**
   * Returns true if this element currently contains a ripple effect.
   * @return {boolean}
   */
  hasRipple: function hasRipple() {
    return Boolean(this._ripple);
  },

  /**
   * Create the element's ripple effect via creating a `<paper-ripple>`.
   * Override this method to customize the ripple element.
   * @return {!PaperRippleElement} Returns a `<paper-ripple>` element.
   */
  _createRipple: function _createRipple() {
    return (/** @type {!PaperRippleElement} */document.createElement('paper-ripple')
    );
  },

  _noinkChanged: function _noinkChanged(noink) {
    if (this.hasRipple()) {
      this._ripple.noink = noink;
    }
  }
};</script><script>
/**
 * `Polymer.PaperInkyFocusBehavior` implements a ripple when the element has keyboard focus.
 *
 * @polymerBehavior Polymer.PaperInkyFocusBehavior
 */
Polymer.PaperInkyFocusBehaviorImpl = {
  observers: ['_focusedChanged(receivedFocusFromKeyboard)'],

  _focusedChanged: function _focusedChanged(receivedFocusFromKeyboard) {
    if (receivedFocusFromKeyboard) {
      this.ensureRipple();
    }
    if (this.hasRipple()) {
      this._ripple.holdDown = receivedFocusFromKeyboard;
    }
  },

  _createRipple: function _createRipple() {
    var ripple = Polymer.PaperRippleBehavior._createRipple();
    ripple.id = 'ink';
    ripple.setAttribute('center', '');
    ripple.classList.add('circle');
    return ripple;
  }
};

/** @polymerBehavior Polymer.PaperInkyFocusBehavior */
Polymer.PaperInkyFocusBehavior = [Polymer.IronButtonState, Polymer.IronControlState, Polymer.PaperRippleBehavior, Polymer.PaperInkyFocusBehaviorImpl];</script><style is="custom-style">:root{--google-red-100:#f4c7c3;--google-red-300:#e67c73;--google-red-500:#db4437;--google-red-700:#c53929;--google-blue-100:#c6dafc;--google-blue-300:#7baaf7;--google-blue-500:#4285f4;--google-blue-700:#3367d6;--google-green-100:#b7e1cd;--google-green-300:#57bb8a;--google-green-500:#0f9d58;--google-green-700:#0b8043;--google-yellow-100:#fce8b2;--google-yellow-300:#f7cb4d;--google-yellow-500:#f4b400;--google-yellow-700:#f09300;--google-grey-100:#f5f5f5;--google-grey-300:#e0e0e0;--google-grey-500:#9e9e9e;--google-grey-700:#616161;--paper-red-50:#ffebee;--paper-red-100:#ffcdd2;--paper-red-200:#ef9a9a;--paper-red-300:#e57373;--paper-red-400:#ef5350;--paper-red-500:#f44336;--paper-red-600:#e53935;--paper-red-700:#d32f2f;--paper-red-800:#c62828;--paper-red-900:#b71c1c;--paper-red-a100:#ff8a80;--paper-red-a200:#ff5252;--paper-red-a400:#ff1744;--paper-red-a700:#d50000;--paper-pink-50:#fce4ec;--paper-pink-100:#f8bbd0;--paper-pink-200:#f48fb1;--paper-pink-300:#f06292;--paper-pink-400:#ec407a;--paper-pink-500:#e91e63;--paper-pink-600:#d81b60;--paper-pink-700:#c2185b;--paper-pink-800:#ad1457;--paper-pink-900:#880e4f;--paper-pink-a100:#ff80ab;--paper-pink-a200:#ff4081;--paper-pink-a400:#f50057;--paper-pink-a700:#c51162;--paper-purple-50:#f3e5f5;--paper-purple-100:#e1bee7;--paper-purple-200:#ce93d8;--paper-purple-300:#ba68c8;--paper-purple-400:#ab47bc;--paper-purple-500:#9c27b0;--paper-purple-600:#8e24aa;--paper-purple-700:#7b1fa2;--paper-purple-800:#6a1b9a;--paper-purple-900:#4a148c;--paper-purple-a100:#ea80fc;--paper-purple-a200:#e040fb;--paper-purple-a400:#d500f9;--paper-purple-a700:#aa00ff;--paper-deep-purple-50:#ede7f6;--paper-deep-purple-100:#d1c4e9;--paper-deep-purple-200:#b39ddb;--paper-deep-purple-300:#9575cd;--paper-deep-purple-400:#7e57c2;--paper-deep-purple-500:#673ab7;--paper-deep-purple-600:#5e35b1;--paper-deep-purple-700:#512da8;--paper-deep-purple-800:#4527a0;--paper-deep-purple-900:#311b92;--paper-deep-purple-a100:#b388ff;--paper-deep-purple-a200:#7c4dff;--paper-deep-purple-a400:#651fff;--paper-deep-purple-a700:#6200ea;--paper-indigo-50:#e8eaf6;--paper-indigo-100:#c5cae9;--paper-indigo-200:#9fa8da;--paper-indigo-300:#7986cb;--paper-indigo-400:#5c6bc0;--paper-indigo-500:#3f51b5;--paper-indigo-600:#3949ab;--paper-indigo-700:#303f9f;--paper-indigo-800:#283593;--paper-indigo-900:#1a237e;--paper-indigo-a100:#8c9eff;--paper-indigo-a200:#536dfe;--paper-indigo-a400:#3d5afe;--paper-indigo-a700:#304ffe;--paper-blue-50:#e3f2fd;--paper-blue-100:#bbdefb;--paper-blue-200:#90caf9;--paper-blue-300:#64b5f6;--paper-blue-400:#42a5f5;--paper-blue-500:#2196f3;--paper-blue-600:#1e88e5;--paper-blue-700:#1976d2;--paper-blue-800:#1565c0;--paper-blue-900:#0d47a1;--paper-blue-a100:#82b1ff;--paper-blue-a200:#448aff;--paper-blue-a400:#2979ff;--paper-blue-a700:#2962ff;--paper-light-blue-50:#e1f5fe;--paper-light-blue-100:#b3e5fc;--paper-light-blue-200:#81d4fa;--paper-light-blue-300:#4fc3f7;--paper-light-blue-400:#29b6f6;--paper-light-blue-500:#03a9f4;--paper-light-blue-600:#039be5;--paper-light-blue-700:#0288d1;--paper-light-blue-800:#0277bd;--paper-light-blue-900:#01579b;--paper-light-blue-a100:#80d8ff;--paper-light-blue-a200:#40c4ff;--paper-light-blue-a400:#00b0ff;--paper-light-blue-a700:#0091ea;--paper-cyan-50:#e0f7fa;--paper-cyan-100:#b2ebf2;--paper-cyan-200:#80deea;--paper-cyan-300:#4dd0e1;--paper-cyan-400:#26c6da;--paper-cyan-500:#00bcd4;--paper-cyan-600:#00acc1;--paper-cyan-700:#0097a7;--paper-cyan-800:#00838f;--paper-cyan-900:#006064;--paper-cyan-a100:#84ffff;--paper-cyan-a200:#18ffff;--paper-cyan-a400:#00e5ff;--paper-cyan-a700:#00b8d4;--paper-teal-50:#e0f2f1;--paper-teal-100:#b2dfdb;--paper-teal-200:#80cbc4;--paper-teal-300:#4db6ac;--paper-teal-400:#26a69a;--paper-teal-500:#009688;--paper-teal-600:#00897b;--paper-teal-700:#00796b;--paper-teal-800:#00695c;--paper-teal-900:#004d40;--paper-teal-a100:#a7ffeb;--paper-teal-a200:#64ffda;--paper-teal-a400:#1de9b6;--paper-teal-a700:#00bfa5;--paper-green-50:#e8f5e9;--paper-green-100:#c8e6c9;--paper-green-200:#a5d6a7;--paper-green-300:#81c784;--paper-green-400:#66bb6a;--paper-green-500:#4caf50;--paper-green-600:#43a047;--paper-green-700:#388e3c;--paper-green-800:#2e7d32;--paper-green-900:#1b5e20;--paper-green-a100:#b9f6ca;--paper-green-a200:#69f0ae;--paper-green-a400:#00e676;--paper-green-a700:#00c853;--paper-light-green-50:#f1f8e9;--paper-light-green-100:#dcedc8;--paper-light-green-200:#c5e1a5;--paper-light-green-300:#aed581;--paper-light-green-400:#9ccc65;--paper-light-green-500:#8bc34a;--paper-light-green-600:#7cb342;--paper-light-green-700:#689f38;--paper-light-green-800:#558b2f;--paper-light-green-900:#33691e;--paper-light-green-a100:#ccff90;--paper-light-green-a200:#b2ff59;--paper-light-green-a400:#76ff03;--paper-light-green-a700:#64dd17;--paper-lime-50:#f9fbe7;--paper-lime-100:#f0f4c3;--paper-lime-200:#e6ee9c;--paper-lime-300:#dce775;--paper-lime-400:#d4e157;--paper-lime-500:#cddc39;--paper-lime-600:#c0ca33;--paper-lime-700:#afb42b;--paper-lime-800:#9e9d24;--paper-lime-900:#827717;--paper-lime-a100:#f4ff81;--paper-lime-a200:#eeff41;--paper-lime-a400:#c6ff00;--paper-lime-a700:#aeea00;--paper-yellow-50:#fffde7;--paper-yellow-100:#fff9c4;--paper-yellow-200:#fff59d;--paper-yellow-300:#fff176;--paper-yellow-400:#ffee58;--paper-yellow-500:#ffeb3b;--paper-yellow-600:#fdd835;--paper-yellow-700:#fbc02d;--paper-yellow-800:#f9a825;--paper-yellow-900:#f57f17;--paper-yellow-a100:#ffff8d;--paper-yellow-a200:#ffff00;--paper-yellow-a400:#ffea00;--paper-yellow-a700:#ffd600;--paper-amber-50:#fff8e1;--paper-amber-100:#ffecb3;--paper-amber-200:#ffe082;--paper-amber-300:#ffd54f;--paper-amber-400:#ffca28;--paper-amber-500:#ffc107;--paper-amber-600:#ffb300;--paper-amber-700:#ffa000;--paper-amber-800:#ff8f00;--paper-amber-900:#ff6f00;--paper-amber-a100:#ffe57f;--paper-amber-a200:#ffd740;--paper-amber-a400:#ffc400;--paper-amber-a700:#ffab00;--paper-orange-50:#fff3e0;--paper-orange-100:#ffe0b2;--paper-orange-200:#ffcc80;--paper-orange-300:#ffb74d;--paper-orange-400:#ffa726;--paper-orange-500:#ff9800;--paper-orange-600:#fb8c00;--paper-orange-700:#f57c00;--paper-orange-800:#ef6c00;--paper-orange-900:#e65100;--paper-orange-a100:#ffd180;--paper-orange-a200:#ffab40;--paper-orange-a400:#ff9100;--paper-orange-a700:#ff6500;--paper-deep-orange-50:#fbe9e7;--paper-deep-orange-100:#ffccbc;--paper-deep-orange-200:#ffab91;--paper-deep-orange-300:#ff8a65;--paper-deep-orange-400:#ff7043;--paper-deep-orange-500:#ff5722;--paper-deep-orange-600:#f4511e;--paper-deep-orange-700:#e64a19;--paper-deep-orange-800:#d84315;--paper-deep-orange-900:#bf360c;--paper-deep-orange-a100:#ff9e80;--paper-deep-orange-a200:#ff6e40;--paper-deep-orange-a400:#ff3d00;--paper-deep-orange-a700:#dd2c00;--paper-brown-50:#efebe9;--paper-brown-100:#d7ccc8;--paper-brown-200:#bcaaa4;--paper-brown-300:#a1887f;--paper-brown-400:#8d6e63;--paper-brown-500:#795548;--paper-brown-600:#6d4c41;--paper-brown-700:#5d4037;--paper-brown-800:#4e342e;--paper-brown-900:#3e2723;--paper-grey-50:#fafafa;--paper-grey-100:#f5f5f5;--paper-grey-200:#eeeeee;--paper-grey-300:#e0e0e0;--paper-grey-400:#bdbdbd;--paper-grey-500:#9e9e9e;--paper-grey-600:#757575;--paper-grey-700:#616161;--paper-grey-800:#424242;--paper-grey-900:#212121;--paper-blue-grey-50:#eceff1;--paper-blue-grey-100:#cfd8dc;--paper-blue-grey-200:#b0bec5;--paper-blue-grey-300:#90a4ae;--paper-blue-grey-400:#78909c;--paper-blue-grey-500:#607d8b;--paper-blue-grey-600:#546e7a;--paper-blue-grey-700:#455a64;--paper-blue-grey-800:#37474f;--paper-blue-grey-900:#263238;--dark-divider-opacity:0.12;--dark-disabled-opacity:0.38;--dark-secondary-opacity:0.54;--dark-primary-opacity:0.87;--light-divider-opacity:0.12;--light-disabled-opacity:0.3;--light-secondary-opacity:0.7;--light-primary-opacity:1.0;}</style><style is="custom-style">:root{--primary-text-color:var(--light-theme-text-color);--primary-background-color:var(--light-theme-background-color);--secondary-text-color:var(--light-theme-secondary-color);--disabled-text-color:var(--light-theme-disabled-color);--divider-color:var(--light-theme-divider-color);--error-color:var(--paper-deep-orange-a700);--primary-color:var(--paper-indigo-500);--light-primary-color:var(--paper-indigo-100);--dark-primary-color:var(--paper-indigo-700);--accent-color:var(--paper-pink-a200);--light-accent-color:var(--paper-pink-a100);--dark-accent-color:var(--paper-pink-a400);--light-theme-background-color:#ffffff;--light-theme-base-color:#000000;--light-theme-text-color:var(--paper-grey-900);--light-theme-secondary-color:#737373;--light-theme-disabled-color:#9b9b9b;--light-theme-divider-color:#dbdbdb;--dark-theme-background-color:var(--paper-grey-900);--dark-theme-base-color:#ffffff;--dark-theme-text-color:#ffffff;--dark-theme-secondary-color:#bcbcbc;--dark-theme-disabled-color:#646464;--dark-theme-divider-color:#3c3c3c;--text-primary-color:var(--dark-theme-text-color);--default-primary-color:var(--primary-color);}</style><dom-module id="paper-icon-button" assetpath="../bower_components/paper-icon-button/"><template strip-whitespace=""><style>:host{display:inline-block;position:relative;padding:8px;outline:none;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;z-index:0;line-height:1;width:40px;height:40px;box-sizing:border-box !important;@apply (--paper-icon-button);}:host #ink{color:var(--paper-icon-button-ink-color, --primary-text-color);opacity:0.6;}:host([disabled]){color:var(--paper-icon-button-disabled-text, --disabled-text-color);pointer-events:none;cursor:auto;@apply (--paper-icon-button-disabled);}:host(:hover){@apply (--paper-icon-button-hover);}iron-icon{--iron-icon-width:100%;--iron-icon-height:100%;}</style><iron-icon id="icon" src="[[src]]" icon="[[icon]]" alt$="[[alt]]"></iron-icon></template><script>
Polymer({
  is: 'paper-icon-button',

  hostAttributes: {
    role: 'button',
    tabindex: '0'
  },

  behaviors: [Polymer.PaperInkyFocusBehavior],

  properties: {
    /**
     * The URL of an image for the icon. If the src property is specified,
     * the icon property should not be.
     */
    src: {
      type: String
    },

    /**
     * Specifies the icon name or index in the set of icons available in
     * the icon's icon set. If the icon property is specified,
     * the src property should not be.
     */
    icon: {
      type: String
    },

    /**
     * Specifies the alternate text for the button, for accessibility.
     */
    alt: {
      type: String,
      observer: "_altChanged"
    }
  },

  _altChanged: function _altChanged(newValue, oldValue) {
    var label = this.getAttribute('aria-label');

    // Don't stomp over a user-set aria-label.
    if (!label || oldValue == label) {
      this.setAttribute('aria-label', newValue);
    }
  }
});</script></dom-module><script>
/**
 * The `iron-iconset-svg` element allows users to define their own icon sets
 * that contain svg icons. The svg icon elements should be children of the
 * `iron-iconset-svg` element. Multiple icons should be given distinct id's.
 *
 * Using svg elements to create icons has a few advantages over traditional
 * bitmap graphics like jpg or png. Icons that use svg are vector based so
 * they are resolution independent and should look good on any device. They
 * are stylable via css. Icons can be themed, colorized, and even animated.
 *
 * Example:
 *
 *     <iron-iconset-svg name="my-svg-icons" size="24">
 *       <svg>
 *         <defs>
 *           <g id="shape">
 *             <rect x="12" y="0" width="12" height="24" />
 *             <circle cx="12" cy="12" r="12" />
 *           </g>
 *         </defs>
 *       </svg>
 *     </iron-iconset-svg>
 *
 * This will automatically register the icon set "my-svg-icons" to the iconset
 * database.  To use these icons from within another element, make a
 * `iron-iconset` element and call the `byId` method
 * to retrieve a given iconset. To apply a particular icon inside an
 * element use the `applyIcon` method. For example:
 *
 *     iconset.applyIcon(iconNode, 'car');
 *
 * @element iron-iconset-svg
 * @demo demo/index.html
 * @implements {Polymer.Iconset}
 */
Polymer({
  is: 'iron-iconset-svg',

  properties: {

    /**
     * The name of the iconset.
     */
    name: {
      type: String,
      observer: '_nameChanged'
    },

    /**
     * The size of an individual icon. Note that icons must be square.
     */
    size: {
      type: Number,
      value: 24
    },

    /**
     * Set to true to enable mirroring of icons where specified when they are
     * stamped. Icons that should be mirrored should be decorated with a
     * `mirror-in-rtl` attribute.
     *
     * NOTE: For performance reasons, direction will be resolved once per
     * document per iconset, so moving icons in and out of RTL subtrees will
     * not cause their mirrored state to change.
     */
    rtlMirroring: {
      type: Boolean,
      value: false
    }
  },

  attached: function attached() {
    this.style.display = 'none';
  },

  /**
   * Construct an array of all icon names in this iconset.
   *
   * @return {!Array} Array of icon names.
   */
  getIconNames: function getIconNames() {
    this._icons = this._createIconMap();
    return Object.keys(this._icons).map(function (n) {
      return this.name + ':' + n;
    }, this);
  },

  /**
   * Applies an icon to the given element.
   *
   * An svg icon is prepended to the element's shadowRoot if it exists,
   * otherwise to the element itself.
   *
   * If RTL mirroring is enabled, and the icon is marked to be mirrored in
   * RTL, the element will be tested (once and only once ever for each
   * iconset) to determine the direction of the subtree the element is in.
   * This direction will apply to all future icon applications, although only
   * icons marked to be mirrored will be affected.
   *
   * @method applyIcon
   * @param {Element} element Element to which the icon is applied.
   * @param {string} iconName Name of the icon to apply.
   * @return {?Element} The svg element which renders the icon.
   */
  applyIcon: function applyIcon(element, iconName) {
    // insert svg element into shadow root, if it exists
    element = element.root || element;
    // Remove old svg element
    this.removeIcon(element);
    // install new svg element
    var svg = this._cloneIcon(iconName, this.rtlMirroring && this._targetIsRTL(element));
    if (svg) {
      var pde = Polymer.dom(element);
      pde.insertBefore(svg, pde.childNodes[0]);
      return element._svgIcon = svg;
    }
    return null;
  },

  /**
   * Remove an icon from the given element by undoing the changes effected
   * by `applyIcon`.
   *
   * @param {Element} element The element from which the icon is removed.
   */
  removeIcon: function removeIcon(element) {
    // Remove old svg element
    element = element.root || element;
    if (element._svgIcon) {
      Polymer.dom(element).removeChild(element._svgIcon);
      element._svgIcon = null;
    }
  },

  /**
   * Measures and memoizes the direction of the element. Note that this
   * measurement is only done once and the result is memoized for future
   * invocations.
   */
  _targetIsRTL: function _targetIsRTL(target) {
    if (this.__targetIsRTL == null) {
      if (target && target.nodeType !== Node.ELEMENT_NODE) {
        target = target.host;
      }

      this.__targetIsRTL = target && window.getComputedStyle(target)['direction'] === 'rtl';
    }

    return this.__targetIsRTL;
  },

  /**
   *
   * When name is changed, register iconset metadata
   *
   */
  _nameChanged: function _nameChanged() {
    new Polymer.IronMeta({ type: 'iconset', key: this.name, value: this });
    this.async(function () {
      this.fire('iron-iconset-added', this, { node: window });
    });
  },

  /**
   * Create a map of child SVG elements by id.
   *
   * @return {!Object} Map of id's to SVG elements.
   */
  _createIconMap: function _createIconMap() {
    // Objects chained to Object.prototype (`{}`) have members. Specifically,
    // on FF there is a `watch` method that confuses the icon map, so we
    // need to use a null-based object here.
    var icons = Object.create(null);
    Polymer.dom(this).querySelectorAll('[id]').forEach(function (icon) {
      icons[icon.id] = icon;
    });
    return icons;
  },

  /**
   * Produce installable clone of the SVG element matching `id` in this
   * iconset, or `undefined` if there is no matching element.
   *
   * @return {Element} Returns an installable clone of the SVG element
   * matching `id`.
   */
  _cloneIcon: function _cloneIcon(id, mirrorAllowed) {
    // create the icon map on-demand, since the iconset itself has no discrete
    // signal to know when it's children are fully parsed
    this._icons = this._icons || this._createIconMap();
    return this._prepareSvgClone(this._icons[id], this.size, mirrorAllowed);
  },

  /**
   * @param {Element} sourceSvg
   * @param {number} size
   * @param {Boolean} mirrorAllowed
   * @return {Element}
   */
  _prepareSvgClone: function _prepareSvgClone(sourceSvg, size, mirrorAllowed) {
    if (sourceSvg) {
      var content = sourceSvg.cloneNode(true),
          svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg'),
          viewBox = content.getAttribute('viewBox') || '0 0 ' + size + ' ' + size,
          cssText = 'pointer-events: none; display: block; width: 100%; height: 100%;';

      if (mirrorAllowed && content.hasAttribute('mirror-in-rtl')) {
        cssText += '-webkit-transform:scale(-1,1);transform:scale(-1,1);';
      }

      svg.setAttribute('viewBox', viewBox);
      svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
      // TODO(dfreedm): `pointer-events: none` works around https://crbug.com/370136
      // TODO(sjmiles): inline style may not be ideal, but avoids requiring a shadow-root
      svg.style.cssText = cssText;
      svg.appendChild(content).removeAttribute('id');
      return svg;
    }
    return null;
  }

});</script><iron-iconset-svg name="paper-tabs" size="24"><svg><defs><g id="chevron-left"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path></g><g id="chevron-right"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"></path></g></defs></svg></iron-iconset-svg><dom-module id="paper-tab" assetpath="../bower_components/paper-tabs/"><template><style>:host{@apply (--layout-inline);@apply (--layout-center);@apply (--layout-center-justified);@apply (--layout-flex-auto);position:relative;padding:0 12px;overflow:hidden;cursor:pointer;vertical-align:middle;@apply (--paper-font-common-base);@apply (--paper-tab);}:host(:focus){outline:none;}:host([link]){padding:0;}.tab-content{height:100%;transform:translateZ(0);-webkit-transform:translateZ(0);transition:opacity 0.1s cubic-bezier(0.4, 0.0, 1, 1);@apply (--layout-horizontal);@apply (--layout-center-center);@apply (--layout-flex-auto);@apply (--paper-tab-content);}:host(:not(.iron-selected)) > .tab-content{opacity:0.8;@apply (--paper-tab-content-unselected);}:host(:focus) .tab-content{opacity:1;font-weight:700;}paper-ripple{color:var(--paper-tab-ink, --paper-yellow-a100);}.tab-content > ::content > a{@apply (--layout-flex-auto);height:100%;}</style><div class="tab-content"><content></content></div></template><script>
Polymer({
  is: 'paper-tab',

  behaviors: [Polymer.IronControlState, Polymer.IronButtonState, Polymer.PaperRippleBehavior],

  properties: {

    /**
     * If true, the tab will forward keyboard clicks (enter/space) to
     * the first anchor element found in its descendants
     */
    link: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    }

  },

  hostAttributes: {
    role: 'tab'
  },

  listeners: {
    down: '_updateNoink',
    tap: '_onTap'
  },

  attached: function attached() {
    this._updateNoink();
  },

  get _parentNoink() {
    var parent = Polymer.dom(this).parentNode;
    return !!parent && !!parent.noink;
  },

  _updateNoink: function _updateNoink() {
    this.noink = !!this.noink || !!this._parentNoink;
  },

  _onTap: function _onTap(event) {
    if (this.link) {
      var anchor = this.queryEffectiveChildren('a');

      if (!anchor) {
        return;
      }

      // Don't get stuck in a loop delegating
      // the listener from the child anchor
      if (event.target === anchor) {
        return;
      }

      anchor.click();
    }
  }

});</script></dom-module><dom-module id="paper-tabs" assetpath="../bower_components/paper-tabs/"><template><style>:host{@apply (--layout);@apply (--layout-center);height:48px;font-size:14px;font-weight:500;overflow:hidden;-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;user-select:none;-webkit-tap-highlight-color:rgba(0, 0, 0, 0);-webkit-tap-highlight-color:transparent;@apply (--paper-tabs);}:host-context([dir=rtl]){@apply (--layout-horizontal-reverse);}#tabsContainer{position:relative;height:100%;white-space:nowrap;overflow:hidden;@apply (--layout-flex-auto);@apply (--paper-tabs-container);}#tabsContent{height:100%;-moz-flex-basis:auto;-ms-flex-basis:auto;flex-basis:auto;@apply (--paper-tabs-content);}#tabsContent.scrollable{position:absolute;white-space:nowrap;}#tabsContent:not(.scrollable),
      #tabsContent.scrollable.fit-container{@apply (--layout-horizontal);}#tabsContent.scrollable.fit-container{min-width:100%;}#tabsContent.scrollable.fit-container > ::content > *{-ms-flex:1 0 auto;-webkit-flex:1 0 auto;flex:1 0 auto;}.hidden{display:none;}.not-visible{opacity:0;cursor:default;}paper-icon-button{width:48px;height:48px;padding:12px;margin:0 4px;}#selectionBar{position:absolute;height:0;bottom:0;left:0;right:0;border-bottom:2px solid var(--paper-tabs-selection-bar-color, --paper-yellow-a100);-webkit-transform:scale(0);transform:scale(0);-webkit-transform-origin:left center;transform-origin:left center;transition:-webkit-transform;transition:transform;@apply (--paper-tabs-selection-bar);}#selectionBar.align-bottom{top:0;bottom:auto;}#selectionBar.expand{transition-duration:0.15s;transition-timing-function:cubic-bezier(0.4, 0.0, 1, 1);}#selectionBar.contract{transition-duration:0.18s;transition-timing-function:cubic-bezier(0.0, 0.0, 0.2, 1);}#tabsContent > ::content > *:not(#selectionBar){height:100%;}</style><paper-icon-button icon="paper-tabs:chevron-left" class$="[[_computeScrollButtonClass(_leftHidden, scrollable, hideScrollButtons)]]" on-up="_onScrollButtonUp" on-down="_onLeftScrollButtonDown" tabindex="-1"></paper-icon-button><div id="tabsContainer" on-track="_scroll" on-down="_down"><div id="tabsContent" class$="[[_computeTabsContentClass(scrollable, fitContainer)]]"><div id="selectionBar" class$="[[_computeSelectionBarClass(noBar, alignBottom)]]" on-transitionend="_onBarTransitionEnd"></div><content select="*"></content></div></div><paper-icon-button icon="paper-tabs:chevron-right" class$="[[_computeScrollButtonClass(_rightHidden, scrollable, hideScrollButtons)]]" on-up="_onScrollButtonUp" on-down="_onRightScrollButtonDown" tabindex="-1"></paper-icon-button></template><script>
Polymer({
  is: 'paper-tabs',

  behaviors: [Polymer.IronResizableBehavior, Polymer.IronMenubarBehavior],

  properties: {
    /**
     * If true, ink ripple effect is disabled. When this property is changed,
     * all descendant `<paper-tab>` elements have their `noink` property
     * changed to the new value as well.
     */
    noink: {
      type: Boolean,
      value: false,
      observer: '_noinkChanged'
    },

    /**
     * If true, the bottom bar to indicate the selected tab will not be shown.
     */
    noBar: {
      type: Boolean,
      value: false
    },

    /**
     * If true, the slide effect for the bottom bar is disabled.
     */
    noSlide: {
      type: Boolean,
      value: false
    },

    /**
     * If true, tabs are scrollable and the tab width is based on the label width.
     */
    scrollable: {
      type: Boolean,
      value: false
    },

    /**
     * If true, tabs expand to fit their container. This currently only applies when
     * scrollable is true.
     */
    fitContainer: {
      type: Boolean,
      value: false
    },

    /**
     * If true, dragging on the tabs to scroll is disabled.
     */
    disableDrag: {
      type: Boolean,
      value: false
    },

    /**
     * If true, scroll buttons (left/right arrow) will be hidden for scrollable tabs.
     */
    hideScrollButtons: {
      type: Boolean,
      value: false
    },

    /**
     * If true, the tabs are aligned to bottom (the selection bar appears at the top).
     */
    alignBottom: {
      type: Boolean,
      value: false
    },

    selectable: {
      type: String,
      value: 'paper-tab'
    },

    /**
     * If true, tabs are automatically selected when focused using the
     * keyboard.
     */
    autoselect: {
      type: Boolean,
      value: false
    },

    /**
     * The delay (in milliseconds) between when the user stops interacting
     * with the tabs through the keyboard and when the focused item is
     * automatically selected (if `autoselect` is true).
     */
    autoselectDelay: {
      type: Number,
      value: 0
    },

    _step: {
      type: Number,
      value: 10
    },

    _holdDelay: {
      type: Number,
      value: 1
    },

    _leftHidden: {
      type: Boolean,
      value: false
    },

    _rightHidden: {
      type: Boolean,
      value: false
    },

    _previousTab: {
      type: Object
    }
  },

  hostAttributes: {
    role: 'tablist'
  },

  listeners: {
    'iron-resize': '_onTabSizingChanged',
    'iron-items-changed': '_onTabSizingChanged',
    'iron-select': '_onIronSelect',
    'iron-deselect': '_onIronDeselect'
  },

  keyBindings: {
    'left:keyup right:keyup': '_onArrowKeyup'
  },

  created: function created() {
    this._holdJob = null;
    this._pendingActivationItem = undefined;
    this._pendingActivationTimeout = undefined;
    this._bindDelayedActivationHandler = this._delayedActivationHandler.bind(this);
    this.addEventListener('blur', this._onBlurCapture.bind(this), true);
  },

  ready: function ready() {
    this.setScrollDirection('y', this.$.tabsContainer);
  },

  detached: function detached() {
    this._cancelPendingActivation();
  },

  _noinkChanged: function _noinkChanged(noink) {
    var childTabs = Polymer.dom(this).querySelectorAll('paper-tab');
    childTabs.forEach(noink ? this._setNoinkAttribute : this._removeNoinkAttribute);
  },

  _setNoinkAttribute: function _setNoinkAttribute(element) {
    element.setAttribute('noink', '');
  },

  _removeNoinkAttribute: function _removeNoinkAttribute(element) {
    element.removeAttribute('noink');
  },

  _computeScrollButtonClass: function _computeScrollButtonClass(hideThisButton, scrollable, hideScrollButtons) {
    if (!scrollable || hideScrollButtons) {
      return 'hidden';
    }

    if (hideThisButton) {
      return 'not-visible';
    }

    return '';
  },

  _computeTabsContentClass: function _computeTabsContentClass(scrollable, fitContainer) {
    return scrollable ? 'scrollable' + (fitContainer ? ' fit-container' : '') : ' fit-container';
  },

  _computeSelectionBarClass: function _computeSelectionBarClass(noBar, alignBottom) {
    if (noBar) {
      return 'hidden';
    } else if (alignBottom) {
      return 'align-bottom';
    }

    return '';
  },

  // TODO(cdata): Add `track` response back in when gesture lands.

  _onTabSizingChanged: function _onTabSizingChanged() {
    this.debounce('_onTabSizingChanged', function () {
      this._scroll();
      this._tabChanged(this.selectedItem);
    }, 10);
  },

  _onIronSelect: function _onIronSelect(event) {
    this._tabChanged(event.detail.item, this._previousTab);
    this._previousTab = event.detail.item;
    this.cancelDebouncer('tab-changed');
  },

  _onIronDeselect: function _onIronDeselect(event) {
    this.debounce('tab-changed', function () {
      this._tabChanged(null, this._previousTab);
      this._previousTab = null;
      // See polymer/polymer#1305
    }, 1);
  },

  _activateHandler: function _activateHandler() {
    // Cancel item activations scheduled by keyboard events when any other
    // action causes an item to be activated (e.g. clicks).
    this._cancelPendingActivation();

    Polymer.IronMenuBehaviorImpl._activateHandler.apply(this, arguments);
  },

  /**
   * Activates an item after a delay (in milliseconds).
   */
  _scheduleActivation: function _scheduleActivation(item, delay) {
    this._pendingActivationItem = item;
    this._pendingActivationTimeout = this.async(this._bindDelayedActivationHandler, delay);
  },

  /**
   * Activates the last item given to `_scheduleActivation`.
   */
  _delayedActivationHandler: function _delayedActivationHandler() {
    var item = this._pendingActivationItem;
    this._pendingActivationItem = undefined;
    this._pendingActivationTimeout = undefined;
    item.fire(this.activateEvent, null, {
      bubbles: true,
      cancelable: true
    });
  },

  /**
   * Cancels a previously scheduled item activation made with
   * `_scheduleActivation`.
   */
  _cancelPendingActivation: function _cancelPendingActivation() {
    if (this._pendingActivationTimeout !== undefined) {
      this.cancelAsync(this._pendingActivationTimeout);
      this._pendingActivationItem = undefined;
      this._pendingActivationTimeout = undefined;
    }
  },

  _onArrowKeyup: function _onArrowKeyup(event) {
    if (this.autoselect) {
      this._scheduleActivation(this.focusedItem, this.autoselectDelay);
    }
  },

  _onBlurCapture: function _onBlurCapture(event) {
    // Cancel a scheduled item activation (if any) when that item is
    // blurred.
    if (event.target === this._pendingActivationItem) {
      this._cancelPendingActivation();
    }
  },

  get _tabContainerScrollSize() {
    return Math.max(0, this.$.tabsContainer.scrollWidth - this.$.tabsContainer.offsetWidth);
  },

  _scroll: function _scroll(e, detail) {
    if (!this.scrollable) {
      return;
    }

    var ddx = detail && -detail.ddx || 0;
    this._affectScroll(ddx);
  },

  _down: function _down(e) {
    // go one beat async to defeat IronMenuBehavior
    // autorefocus-on-no-selection timeout
    this.async(function () {
      if (this._defaultFocusAsync) {
        this.cancelAsync(this._defaultFocusAsync);
        this._defaultFocusAsync = null;
      }
    }, 1);
  },

  _affectScroll: function _affectScroll(dx) {
    this.$.tabsContainer.scrollLeft += dx;

    var scrollLeft = this.$.tabsContainer.scrollLeft;

    this._leftHidden = scrollLeft === 0;
    this._rightHidden = scrollLeft === this._tabContainerScrollSize;
  },

  _onLeftScrollButtonDown: function _onLeftScrollButtonDown() {
    this._scrollToLeft();
    this._holdJob = setInterval(this._scrollToLeft.bind(this), this._holdDelay);
  },

  _onRightScrollButtonDown: function _onRightScrollButtonDown() {
    this._scrollToRight();
    this._holdJob = setInterval(this._scrollToRight.bind(this), this._holdDelay);
  },

  _onScrollButtonUp: function _onScrollButtonUp() {
    clearInterval(this._holdJob);
    this._holdJob = null;
  },

  _scrollToLeft: function _scrollToLeft() {
    this._affectScroll(-this._step);
  },

  _scrollToRight: function _scrollToRight() {
    this._affectScroll(this._step);
  },

  _tabChanged: function _tabChanged(tab, old) {
    if (!tab) {
      // Remove the bar without animation.
      this.$.selectionBar.classList.remove('expand');
      this.$.selectionBar.classList.remove('contract');
      this._positionBar(0, 0);
      return;
    }

    var r = this.$.tabsContent.getBoundingClientRect();
    var w = r.width;
    var tabRect = tab.getBoundingClientRect();
    var tabOffsetLeft = tabRect.left - r.left;

    this._pos = {
      width: this._calcPercent(tabRect.width, w),
      left: this._calcPercent(tabOffsetLeft, w)
    };

    if (this.noSlide || old == null) {
      // Position the bar without animation.
      this.$.selectionBar.classList.remove('expand');
      this.$.selectionBar.classList.remove('contract');
      this._positionBar(this._pos.width, this._pos.left);
      return;
    }

    var oldRect = old.getBoundingClientRect();
    var oldIndex = this.items.indexOf(old);
    var index = this.items.indexOf(tab);
    var m = 5;

    // bar animation: expand
    this.$.selectionBar.classList.add('expand');

    var moveRight = oldIndex < index;
    var isRTL = this._isRTL;
    if (isRTL) {
      moveRight = !moveRight;
    }

    if (moveRight) {
      this._positionBar(this._calcPercent(tabRect.left + tabRect.width - oldRect.left, w) - m, this._left);
    } else {
      this._positionBar(this._calcPercent(oldRect.left + oldRect.width - tabRect.left, w) - m, this._calcPercent(tabOffsetLeft, w) + m);
    }

    if (this.scrollable) {
      this._scrollToSelectedIfNeeded(tabRect.width, tabOffsetLeft);
    }
  },

  _scrollToSelectedIfNeeded: function _scrollToSelectedIfNeeded(tabWidth, tabOffsetLeft) {
    var l = tabOffsetLeft - this.$.tabsContainer.scrollLeft;
    if (l < 0) {
      this.$.tabsContainer.scrollLeft += l;
    } else {
      l += tabWidth - this.$.tabsContainer.offsetWidth;
      if (l > 0) {
        this.$.tabsContainer.scrollLeft += l;
      }
    }
  },

  _calcPercent: function _calcPercent(w, w0) {
    return 100 * w / w0;
  },

  _positionBar: function _positionBar(width, left) {
    width = width || 0;
    left = left || 0;

    this._width = width;
    this._left = left;
    this.transform('translateX(' + left + '%) scaleX(' + width / 100 + ')', this.$.selectionBar);
  },

  _onBarTransitionEnd: function _onBarTransitionEnd(e) {
    var cl = this.$.selectionBar.classList;
    // bar animation: expand -> contract
    if (cl.contains('expand')) {
      cl.remove('expand');
      cl.add('contract');
      this._positionBar(this._pos.width, this._pos.left);
      // bar animation done
    } else if (cl.contains('contract')) {
      cl.remove('contract');
    }
  }
});</script></dom-module><dom-module id="paper-listbox" assetpath="../bower_components/paper-listbox/"><template><style>:host{display:block;padding:8px 0;background:var(--paper-listbox-background-color, --primary-background-color);color:var(--paper-listbox-color, --primary-text-color);@apply (--paper-listbox);}</style><content></content></template><script>
(function () {
  Polymer({
    is: 'paper-listbox',

    behaviors: [Polymer.IronMenuBehavior],

    hostAttributes: {
      role: 'listbox'
    }
  });
})();</script></dom-module><script>
/** @polymerBehavior Polymer.PaperItemBehavior */
Polymer.PaperItemBehaviorImpl = {
  hostAttributes: {
    role: 'option',
    tabindex: '0'
  }
};

/** @polymerBehavior */
Polymer.PaperItemBehavior = [Polymer.IronButtonState, Polymer.IronControlState, Polymer.PaperItemBehaviorImpl];</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,700|Roboto:400,300,300italic,400italic,500,500italic,700,700italic" crossorigin="anonymous"><style is="custom-style">:root{--paper-font-common-base:{font-family:'Roboto', 'Noto', sans-serif;-webkit-font-smoothing:antialiased;};--paper-font-common-code:{font-family:'Roboto Mono', 'Consolas', 'Menlo', monospace;-webkit-font-smoothing:antialiased;};--paper-font-common-expensive-kerning:{text-rendering:optimizeLegibility;};--paper-font-common-nowrap:{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;};--paper-font-display4:{@apply (--paper-font-common-base);@apply (--paper-font-common-nowrap);font-size:112px;font-weight:300;letter-spacing:-.044em;line-height:120px;};--paper-font-display3:{@apply (--paper-font-common-base);@apply (--paper-font-common-nowrap);font-size:56px;font-weight:400;letter-spacing:-.026em;line-height:60px;};--paper-font-display2:{@apply (--paper-font-common-base);font-size:45px;font-weight:400;letter-spacing:-.018em;line-height:48px;};--paper-font-display1:{@apply (--paper-font-common-base);font-size:34px;font-weight:400;letter-spacing:-.01em;line-height:40px;};--paper-font-headline:{@apply (--paper-font-common-base);font-size:24px;font-weight:400;letter-spacing:-.012em;line-height:32px;};--paper-font-title:{@apply (--paper-font-common-base);@apply (--paper-font-common-nowrap);font-size:20px;font-weight:500;line-height:28px;};--paper-font-subhead:{@apply (--paper-font-common-base);font-size:16px;font-weight:400;line-height:24px;};--paper-font-body2:{@apply (--paper-font-common-base);font-size:14px;font-weight:500;line-height:24px;};--paper-font-body1:{@apply (--paper-font-common-base);font-size:14px;font-weight:400;line-height:20px;};--paper-font-caption:{@apply (--paper-font-common-base);@apply (--paper-font-common-nowrap);font-size:12px;font-weight:400;letter-spacing:0.011em;line-height:20px;};--paper-font-menu:{@apply (--paper-font-common-base);@apply (--paper-font-common-nowrap);font-size:13px;font-weight:500;line-height:24px;};--paper-font-button:{@apply (--paper-font-common-base);@apply (--paper-font-common-nowrap);font-size:14px;font-weight:500;letter-spacing:0.018em;line-height:24px;text-transform:uppercase;};--paper-font-code2:{@apply (--paper-font-common-code);font-size:14px;font-weight:700;line-height:20px;};--paper-font-code1:{@apply (--paper-font-common-code);font-size:14px;font-weight:500;line-height:20px;};}</style><dom-module id="paper-item-shared-styles" assetpath="../bower_components/paper-item/"><template><style>:host, .paper-item{display:block;position:relative;min-height:var(--paper-item-min-height, 48px);padding:0px 16px;}.paper-item{@apply (--paper-font-subhead);border:none;outline:none;background:white;width:100%;text-align:left;}:host([hidden]), .paper-item[hidden]{display:none !important;}:host(.iron-selected), .paper-item.iron-selected{font-weight:var(--paper-item-selected-weight, bold);@apply (--paper-item-selected);}:host([disabled]), .paper-item[disabled]{color:var(--paper-item-disabled-color, --disabled-text-color);@apply (--paper-item-disabled);}:host(:focus), .paper-item:focus{position:relative;outline:0;@apply (--paper-item-focused);}:host(:focus):before, .paper-item:focus:before{@apply (--layout-fit);background:currentColor;content:'';opacity:var(--dark-divider-opacity);pointer-events:none;@apply (--paper-item-focused-before);}</style></template></dom-module><dom-module id="paper-item" assetpath="../bower_components/paper-item/"><template><style include="paper-item-shared-styles"></style><style>:host{@apply (--layout-horizontal);@apply (--layout-center);@apply (--paper-font-subhead);@apply (--paper-item);}</style><content></content></template><script>
Polymer({
  is: 'paper-item',

  behaviors: [Polymer.PaperItemBehavior]
});</script></dom-module><dom-module id="iron-pages" assetpath="../bower_components/iron-pages/"><template><style>:host{display:block;}:host > ::content > :not(.iron-selected){display:none !important;}</style><content></content></template><script>
Polymer({

  is: 'iron-pages',

  behaviors: [Polymer.IronResizableBehavior, Polymer.IronSelectableBehavior],

  properties: {

    // as the selected page is the only one visible, activateEvent
    // is both non-sensical and problematic; e.g. in cases where a user
    // handler attempts to change the page and the activateEvent
    // handler immediately changes it back
    activateEvent: {
      type: String,
      value: null
    }

  },

  observers: ['_selectedPageChanged(selected)'],

  _selectedPageChanged: function _selectedPageChanged(selected, old) {
    this.async(this.notifyResize);
  }
});</script></dom-module><script>var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * marked - a markdown parser
 * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/chjj/marked
 */

;(function () {

  /**
   * Block-Level Grammar
   */

  var block = {
    newline: /^\n+/,
    code: /^( {4}[^\n]+\n*)+/,
    fences: noop,
    hr: /^( *[-*_]){3,} *(?:\n+|$)/,
    heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
    nptable: noop,
    lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
    blockquote: /^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,
    list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
    html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
    table: noop,
    paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
    text: /^[^\n]+/
  };

  block.bullet = /(?:[*+-]|\d+\.)/;
  block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
  block.item = replace(block.item, 'gm')(/bull/g, block.bullet)();

  block.list = replace(block.list)(/bull/g, block.bullet)('hr', '\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))')('def', '\\n+(?=' + block.def.source + ')')();

  block.blockquote = replace(block.blockquote)('def', block.def)();

  block._tag = '(?!(?:' + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code' + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo' + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b';

  block.html = replace(block.html)('comment', /\x3c!--[\s\S]*?--\x3e/)('closed', /<(tag)[\s\S]+?<\/\1>/)('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)(/tag/g, block._tag)();

  block.paragraph = replace(block.paragraph)('hr', block.hr)('heading', block.heading)('lheading', block.lheading)('blockquote', block.blockquote)('tag', '<' + block._tag)('def', block.def)();

  /**
   * Normal Block Grammar
   */

  block.normal = merge({}, block);

  /**
   * GFM Block Grammar
   */

  block.gfm = merge({}, block.normal, {
    fences: /^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\s*\1 *(?:\n+|$)/,
    paragraph: /^/,
    heading: /^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/
  });

  block.gfm.paragraph = replace(block.paragraph)('(?!', '(?!' + block.gfm.fences.source.replace('\\1', '\\2') + '|' + block.list.source.replace('\\1', '\\3') + '|')();

  /**
   * GFM + Tables Block Grammar
   */

  block.tables = merge({}, block.gfm, {
    nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
    table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
  });

  /**
   * Block Lexer
   */

  function Lexer(options) {
    this.tokens = [];
    this.tokens.links = {};
    this.options = options || marked.defaults;
    this.rules = block.normal;

    if (this.options.gfm) {
      if (this.options.tables) {
        this.rules = block.tables;
      } else {
        this.rules = block.gfm;
      }
    }
  }

  /**
   * Expose Block Rules
   */

  Lexer.rules = block;

  /**
   * Static Lex Method
   */

  Lexer.lex = function (src, options) {
    var lexer = new Lexer(options);
    return lexer.lex(src);
  };

  /**
   * Preprocessing
   */

  Lexer.prototype.lex = function (src) {
    src = src.replace(/\r\n|\r/g, '\n').replace(/\t/g, '    ').replace(/\u00a0/g, ' ').replace(/\u2424/g, '\n');

    return this.token(src, true);
  };

  /**
   * Lexing
   */

  Lexer.prototype.token = function (src, top, bq) {
    var src = src.replace(/^ +$/gm, ''),
        next,
        loose,
        cap,
        bull,
        b,
        item,
        space,
        i,
        l;

    while (src) {
      // newline
      if (cap = this.rules.newline.exec(src)) {
        src = src.substring(cap[0].length);
        if (cap[0].length > 1) {
          this.tokens.push({
            type: 'space'
          });
        }
      }

      // code
      if (cap = this.rules.code.exec(src)) {
        src = src.substring(cap[0].length);
        cap = cap[0].replace(/^ {4}/gm, '');
        this.tokens.push({
          type: 'code',
          text: !this.options.pedantic ? cap.replace(/\n+$/, '') : cap
        });
        continue;
      }

      // fences (gfm)
      if (cap = this.rules.fences.exec(src)) {
        src = src.substring(cap[0].length);
        this.tokens.push({
          type: 'code',
          lang: cap[2],
          text: cap[3] || ''
        });
        continue;
      }

      // heading
      if (cap = this.rules.heading.exec(src)) {
        src = src.substring(cap[0].length);
        this.tokens.push({
          type: 'heading',
          depth: cap[1].length,
          text: cap[2]
        });
        continue;
      }

      // table no leading pipe (gfm)
      if (top && (cap = this.rules.nptable.exec(src))) {
        src = src.substring(cap[0].length);

        item = {
          type: 'table',
          header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
          align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
          cells: cap[3].replace(/\n$/, '').split('\n')
        };

        for (i = 0; i < item.align.length; i++) {
          if (/^ *-+: *$/.test(item.align[i])) {
            item.align[i] = 'right';
          } else if (/^ *:-+: *$/.test(item.align[i])) {
            item.align[i] = 'center';
          } else if (/^ *:-+ *$/.test(item.align[i])) {
            item.align[i] = 'left';
          } else {
            item.align[i] = null;
          }
        }

        for (i = 0; i < item.cells.length; i++) {
          item.cells[i] = item.cells[i].split(/ *\| */);
        }

        this.tokens.push(item);

        continue;
      }

      // lheading
      if (cap = this.rules.lheading.exec(src)) {
        src = src.substring(cap[0].length);
        this.tokens.push({
          type: 'heading',
          depth: cap[2] === '=' ? 1 : 2,
          text: cap[1]
        });
        continue;
      }

      // hr
      if (cap = this.rules.hr.exec(src)) {
        src = src.substring(cap[0].length);
        this.tokens.push({
          type: 'hr'
        });
        continue;
      }

      // blockquote
      if (cap = this.rules.blockquote.exec(src)) {
        src = src.substring(cap[0].length);

        this.tokens.push({
          type: 'blockquote_start'
        });

        cap = cap[0].replace(/^ *> ?/gm, '');

        // Pass `top` to keep the current
        // "toplevel" state. This is exactly
        // how markdown.pl works.
        this.token(cap, top, true);

        this.tokens.push({
          type: 'blockquote_end'
        });

        continue;
      }

      // list
      if (cap = this.rules.list.exec(src)) {
        src = src.substring(cap[0].length);
        bull = cap[2];

        this.tokens.push({
          type: 'list_start',
          ordered: bull.length > 1
        });

        // Get each top-level item.
        cap = cap[0].match(this.rules.item);

        next = false;
        l = cap.length;
        i = 0;

        for (; i < l; i++) {
          item = cap[i];

          // Remove the list item's bullet
          // so it is seen as the next token.
          space = item.length;
          item = item.replace(/^ *([*+-]|\d+\.) +/, '');

          // Outdent whatever the
          // list item contains. Hacky.
          if (~item.indexOf('\n ')) {
            space -= item.length;
            item = !this.options.pedantic ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '') : item.replace(/^ {1,4}/gm, '');
          }

          // Determine whether the next list item belongs here.
          // Backpedal if it does not belong in this list.
          if (this.options.smartLists && i !== l - 1) {
            b = block.bullet.exec(cap[i + 1])[0];
            if (bull !== b && !(bull.length > 1 && b.length > 1)) {
              src = cap.slice(i + 1).join('\n') + src;
              i = l - 1;
            }
          }

          // Determine whether item is loose or not.
          // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
          // for discount behavior.
          loose = next || /\n\n(?!\s*$)/.test(item);
          if (i !== l - 1) {
            next = item.charAt(item.length - 1) === '\n';
            if (!loose) loose = next;
          }

          this.tokens.push({
            type: loose ? 'loose_item_start' : 'list_item_start'
          });

          // Recurse.
          this.token(item, false, bq);

          this.tokens.push({
            type: 'list_item_end'
          });
        }

        this.tokens.push({
          type: 'list_end'
        });

        continue;
      }

      // html
      if (cap = this.rules.html.exec(src)) {
        src = src.substring(cap[0].length);
        this.tokens.push({
          type: this.options.sanitize ? 'paragraph' : 'html',
          pre: !this.options.sanitizer && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
          text: cap[0]
        });
        continue;
      }

      // def
      if (!bq && top && (cap = this.rules.def.exec(src))) {
        src = src.substring(cap[0].length);
        this.tokens.links[cap[1].toLowerCase()] = {
          href: cap[2],
          title: cap[3]
        };
        continue;
      }

      // table (gfm)
      if (top && (cap = this.rules.table.exec(src))) {
        src = src.substring(cap[0].length);

        item = {
          type: 'table',
          header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
          align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
          cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
        };

        for (i = 0; i < item.align.length; i++) {
          if (/^ *-+: *$/.test(item.align[i])) {
            item.align[i] = 'right';
          } else if (/^ *:-+: *$/.test(item.align[i])) {
            item.align[i] = 'center';
          } else if (/^ *:-+ *$/.test(item.align[i])) {
            item.align[i] = 'left';
          } else {
            item.align[i] = null;
          }
        }

        for (i = 0; i < item.cells.length; i++) {
          item.cells[i] = item.cells[i].replace(/^ *\| *| *\| *$/g, '').split(/ *\| */);
        }

        this.tokens.push(item);

        continue;
      }

      // top-level paragraph
      if (top && (cap = this.rules.paragraph.exec(src))) {
        src = src.substring(cap[0].length);
        this.tokens.push({
          type: 'paragraph',
          text: cap[1].charAt(cap[1].length - 1) === '\n' ? cap[1].slice(0, -1) : cap[1]
        });
        continue;
      }

      // text
      if (cap = this.rules.text.exec(src)) {
        // Top-level should never reach here.
        src = src.substring(cap[0].length);
        this.tokens.push({
          type: 'text',
          text: cap[0]
        });
        continue;
      }

      if (src) {
        throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
      }
    }

    return this.tokens;
  };

  /**
   * Inline-Level Grammar
   */

  var inline = {
    escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
    autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
    url: noop,
    tag: /^\x3c!--[\s\S]*?--\x3e|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
    link: /^!?\[(inside)\]\(href\)/,
    reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
    nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
    strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
    em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
    code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
    br: /^ {2,}\n(?!\s*$)/,
    del: noop,
    text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
  };

  inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;
  inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;

  inline.link = replace(inline.link)('inside', inline._inside)('href', inline._href)();

  inline.reflink = replace(inline.reflink)('inside', inline._inside)();

  /**
   * Normal Inline Grammar
   */

  inline.normal = merge({}, inline);

  /**
   * Pedantic Inline Grammar
   */

  inline.pedantic = merge({}, inline.normal, {
    strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
    em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
  });

  /**
   * GFM Inline Grammar
   */

  inline.gfm = merge({}, inline.normal, {
    escape: replace(inline.escape)('])', '~|])')(),
    url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
    del: /^~~(?=\S)([\s\S]*?\S)~~/,
    text: replace(inline.text)(']|', '~]|')('|', '|https?://|')()
  });

  /**
   * GFM + Line Breaks Inline Grammar
   */

  inline.breaks = merge({}, inline.gfm, {
    br: replace(inline.br)('{2,}', '*')(),
    text: replace(inline.gfm.text)('{2,}', '*')()
  });

  /**
   * Inline Lexer & Compiler
   */

  function InlineLexer(links, options) {
    this.options = options || marked.defaults;
    this.links = links;
    this.rules = inline.normal;
    this.renderer = this.options.renderer || new Renderer();
    this.renderer.options = this.options;

    if (!this.links) {
      throw new Error('Tokens array requires a `links` property.');
    }

    if (this.options.gfm) {
      if (this.options.breaks) {
        this.rules = inline.breaks;
      } else {
        this.rules = inline.gfm;
      }
    } else if (this.options.pedantic) {
      this.rules = inline.pedantic;
    }
  }

  /**
   * Expose Inline Rules
   */

  InlineLexer.rules = inline;

  /**
   * Static Lexing/Compiling Method
   */

  InlineLexer.output = function (src, links, options) {
    var inline = new InlineLexer(links, options);
    return inline.output(src);
  };

  /**
   * Lexing/Compiling
   */

  InlineLexer.prototype.output = function (src) {
    var out = '',
        link,
        text,
        href,
        cap;

    while (src) {
      // escape
      if (cap = this.rules.escape.exec(src)) {
        src = src.substring(cap[0].length);
        out += cap[1];
        continue;
      }

      // autolink
      if (cap = this.rules.autolink.exec(src)) {
        src = src.substring(cap[0].length);
        if (cap[2] === '@') {
          text = cap[1].charAt(6) === ':' ? this.mangle(cap[1].substring(7)) : this.mangle(cap[1]);
          href = this.mangle('mailto:') + text;
        } else {
          text = escape(cap[1]);
          href = text;
        }
        out += this.renderer.link(href, null, text);
        continue;
      }

      // url (gfm)
      if (!this.inLink && (cap = this.rules.url.exec(src))) {
        src = src.substring(cap[0].length);
        text = escape(cap[1]);
        href = text;
        out += this.renderer.link(href, null, text);
        continue;
      }

      // tag
      if (cap = this.rules.tag.exec(src)) {
        if (!this.inLink && /^<a /i.test(cap[0])) {
          this.inLink = true;
        } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
          this.inLink = false;
        }
        src = src.substring(cap[0].length);
        out += this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
        continue;
      }

      // link
      if (cap = this.rules.link.exec(src)) {
        src = src.substring(cap[0].length);
        this.inLink = true;
        out += this.outputLink(cap, {
          href: cap[2],
          title: cap[3]
        });
        this.inLink = false;
        continue;
      }

      // reflink, nolink
      if ((cap = this.rules.reflink.exec(src)) || (cap = this.rules.nolink.exec(src))) {
        src = src.substring(cap[0].length);
        link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
        link = this.links[link.toLowerCase()];
        if (!link || !link.href) {
          out += cap[0].charAt(0);
          src = cap[0].substring(1) + src;
          continue;
        }
        this.inLink = true;
        out += this.outputLink(cap, link);
        this.inLink = false;
        continue;
      }

      // strong
      if (cap = this.rules.strong.exec(src)) {
        src = src.substring(cap[0].length);
        out += this.renderer.strong(this.output(cap[2] || cap[1]));
        continue;
      }

      // em
      if (cap = this.rules.em.exec(src)) {
        src = src.substring(cap[0].length);
        out += this.renderer.em(this.output(cap[2] || cap[1]));
        continue;
      }

      // code
      if (cap = this.rules.code.exec(src)) {
        src = src.substring(cap[0].length);
        out += this.renderer.codespan(escape(cap[2], true));
        continue;
      }

      // br
      if (cap = this.rules.br.exec(src)) {
        src = src.substring(cap[0].length);
        out += this.renderer.br();
        continue;
      }

      // del (gfm)
      if (cap = this.rules.del.exec(src)) {
        src = src.substring(cap[0].length);
        out += this.renderer.del(this.output(cap[1]));
        continue;
      }

      // text
      if (cap = this.rules.text.exec(src)) {
        src = src.substring(cap[0].length);
        out += this.renderer.text(escape(this.smartypants(cap[0])));
        continue;
      }

      if (src) {
        throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
      }
    }

    return out;
  };

  /**
   * Compile Link
   */

  InlineLexer.prototype.outputLink = function (cap, link) {
    var href = escape(link.href),
        title = link.title ? escape(link.title) : null;

    return cap[0].charAt(0) !== '!' ? this.renderer.link(href, title, this.output(cap[1])) : this.renderer.image(href, title, escape(cap[1]));
  };

  /**
   * Smartypants Transformations
   */

  InlineLexer.prototype.smartypants = function (text) {
    if (!this.options.smartypants) return text;
    return text
    // em-dashes
    .replace(/---/g, '\u2014')
    // en-dashes
    .replace(/--/g, '\u2013')
    // opening singles
    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
    // closing singles & apostrophes
    .replace(/'/g, '\u2019')
    // opening doubles
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201C')
    // closing doubles
    .replace(/"/g, '\u201D')
    // ellipses
    .replace(/\.{3}/g, '\u2026');
  };

  /**
   * Mangle Links
   */

  InlineLexer.prototype.mangle = function (text) {
    if (!this.options.mangle) return text;
    var out = '',
        l = text.length,
        i = 0,
        ch;

    for (; i < l; i++) {
      ch = text.charCodeAt(i);
      if (Math.random() > 0.5) {
        ch = 'x' + ch.toString(16);
      }
      out += '&#' + ch + ';';
    }

    return out;
  };

  /**
   * Renderer
   */

  function Renderer(options) {
    this.options = options || {};
  }

  Renderer.prototype.code = function (code, lang, escaped) {
    if (this.options.highlight) {
      var out = this.options.highlight(code, lang);
      if (out != null && out !== code) {
        escaped = true;
        code = out;
      }
    }

    if (!lang) {
      return '<pre><code>' + (escaped ? code : escape(code, true)) + '\n</code></pre>';
    }

    return '<pre><code class="' + this.options.langPrefix + escape(lang, true) + '">' + (escaped ? code : escape(code, true)) + '\n</code></pre>\n';
  };

  Renderer.prototype.blockquote = function (quote) {
    return '<blockquote>\n' + quote + '</blockquote>\n';
  };

  Renderer.prototype.html = function (html) {
    return html;
  };

  Renderer.prototype.heading = function (text, level, raw) {
    return '<h' + level + ' id="' + this.options.headerPrefix + raw.toLowerCase().replace(/[^\w]+/g, '-') + '">' + text + '</h' + level + '>\n';
  };

  Renderer.prototype.hr = function () {
    return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
  };

  Renderer.prototype.list = function (body, ordered) {
    var type = ordered ? 'ol' : 'ul';
    return '<' + type + '>\n' + body + '</' + type + '>\n';
  };

  Renderer.prototype.listitem = function (text) {
    return '<li>' + text + '</li>\n';
  };

  Renderer.prototype.paragraph = function (text) {
    return '<p>' + text + '</p>\n';
  };

  Renderer.prototype.table = function (header, body) {
    return '<table>\n' + '<thead>\n' + header + '</thead>\n' + '<tbody>\n' + body + '</tbody>\n' + '</table>\n';
  };

  Renderer.prototype.tablerow = function (content) {
    return '<tr>\n' + content + '</tr>\n';
  };

  Renderer.prototype.tablecell = function (content, flags) {
    var type = flags.header ? 'th' : 'td';
    var tag = flags.align ? '<' + type + ' style="text-align:' + flags.align + '">' : '<' + type + '>';
    return tag + content + '</' + type + '>\n';
  };

  // span level renderer
  Renderer.prototype.strong = function (text) {
    return '<strong>' + text + '</strong>';
  };

  Renderer.prototype.em = function (text) {
    return '<em>' + text + '</em>';
  };

  Renderer.prototype.codespan = function (text) {
    return '<code>' + text + '</code>';
  };

  Renderer.prototype.br = function () {
    return this.options.xhtml ? '<br/>' : '<br>';
  };

  Renderer.prototype.del = function (text) {
    return '<del>' + text + '</del>';
  };

  Renderer.prototype.link = function (href, title, text) {
    if (this.options.sanitize) {
      try {
        var prot = decodeURIComponent(unescape(href)).replace(/[^\w:]/g, '').toLowerCase();
      } catch (e) {
        return '';
      }
      if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0) {
        return '';
      }
    }
    var out = '<a href="' + href + '"';
    if (title) {
      out += ' title="' + title + '"';
    }
    out += '>' + text + '</a>';
    return out;
  };

  Renderer.prototype.image = function (href, title, text) {
    var out = '<img src="' + href + '" alt="' + text + '"';
    if (title) {
      out += ' title="' + title + '"';
    }
    out += this.options.xhtml ? '/>' : '>';
    return out;
  };

  Renderer.prototype.text = function (text) {
    return text;
  };

  /**
   * Parsing & Compiling
   */

  function Parser(options) {
    this.tokens = [];
    this.token = null;
    this.options = options || marked.defaults;
    this.options.renderer = this.options.renderer || new Renderer();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
  }

  /**
   * Static Parse Method
   */

  Parser.parse = function (src, options, renderer) {
    var parser = new Parser(options, renderer);
    return parser.parse(src);
  };

  /**
   * Parse Loop
   */

  Parser.prototype.parse = function (src) {
    this.inline = new InlineLexer(src.links, this.options, this.renderer);
    this.tokens = src.reverse();

    var out = '';
    while (this.next()) {
      out += this.tok();
    }

    return out;
  };

  /**
   * Next Token
   */

  Parser.prototype.next = function () {
    return this.token = this.tokens.pop();
  };

  /**
   * Preview Next Token
   */

  Parser.prototype.peek = function () {
    return this.tokens[this.tokens.length - 1] || 0;
  };

  /**
   * Parse Text Tokens
   */

  Parser.prototype.parseText = function () {
    var body = this.token.text;

    while (this.peek().type === 'text') {
      body += '\n' + this.next().text;
    }

    return this.inline.output(body);
  };

  /**
   * Parse Current Token
   */

  Parser.prototype.tok = function () {
    switch (this.token.type) {
      case 'space':
        {
          return '';
        }
      case 'hr':
        {
          return this.renderer.hr();
        }
      case 'heading':
        {
          return this.renderer.heading(this.inline.output(this.token.text), this.token.depth, this.token.text);
        }
      case 'code':
        {
          return this.renderer.code(this.token.text, this.token.lang, this.token.escaped);
        }
      case 'table':
        {
          var header = '',
              body = '',
              i,
              row,
              cell,
              flags,
              j;

          // header
          cell = '';
          for (i = 0; i < this.token.header.length; i++) {
            flags = { header: true, align: this.token.align[i] };
            cell += this.renderer.tablecell(this.inline.output(this.token.header[i]), { header: true, align: this.token.align[i] });
          }
          header += this.renderer.tablerow(cell);

          for (i = 0; i < this.token.cells.length; i++) {
            row = this.token.cells[i];

            cell = '';
            for (j = 0; j < row.length; j++) {
              cell += this.renderer.tablecell(this.inline.output(row[j]), { header: false, align: this.token.align[j] });
            }

            body += this.renderer.tablerow(cell);
          }
          return this.renderer.table(header, body);
        }
      case 'blockquote_start':
        {
          var body = '';

          while (this.next().type !== 'blockquote_end') {
            body += this.tok();
          }

          return this.renderer.blockquote(body);
        }
      case 'list_start':
        {
          var body = '',
              ordered = this.token.ordered;

          while (this.next().type !== 'list_end') {
            body += this.tok();
          }

          return this.renderer.list(body, ordered);
        }
      case 'list_item_start':
        {
          var body = '';

          while (this.next().type !== 'list_item_end') {
            body += this.token.type === 'text' ? this.parseText() : this.tok();
          }

          return this.renderer.listitem(body);
        }
      case 'loose_item_start':
        {
          var body = '';

          while (this.next().type !== 'list_item_end') {
            body += this.tok();
          }

          return this.renderer.listitem(body);
        }
      case 'html':
        {
          var html = !this.token.pre && !this.options.pedantic ? this.inline.output(this.token.text) : this.token.text;
          return this.renderer.html(html);
        }
      case 'paragraph':
        {
          return this.renderer.paragraph(this.inline.output(this.token.text));
        }
      case 'text':
        {
          return this.renderer.paragraph(this.parseText());
        }
    }
  };

  /**
   * Helpers
   */

  function escape(html, encode) {
    return html.replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
  }

  function unescape(html) {
    // explicitly match decimal, hex, and named HTML entities 
    return html.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/g, function (_, n) {
      n = n.toLowerCase();
      if (n === 'colon') return ':';
      if (n.charAt(0) === '#') {
        return n.charAt(1) === 'x' ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
      }
      return '';
    });
  }

  function replace(regex, opt) {
    regex = regex.source;
    opt = opt || '';
    return function self(name, val) {
      if (!name) return new RegExp(regex, opt);
      val = val.source || val;
      val = val.replace(/(^|[^\[])\^/g, '$1');
      regex = regex.replace(name, val);
      return self;
    };
  }

  function noop() {}
  noop.exec = noop;

  function merge(obj) {
    var i = 1,
        target,
        key;

    for (; i < arguments.length; i++) {
      target = arguments[i];
      for (key in target) {
        if (Object.prototype.hasOwnProperty.call(target, key)) {
          obj[key] = target[key];
        }
      }
    }

    return obj;
  }

  /**
   * Marked
   */

  function marked(src, opt, callback) {
    if (callback || typeof opt === 'function') {
      if (!callback) {
        callback = opt;
        opt = null;
      }

      opt = merge({}, marked.defaults, opt || {});

      var highlight = opt.highlight,
          tokens,
          pending,
          i = 0;

      try {
        tokens = Lexer.lex(src, opt);
      } catch (e) {
        return callback(e);
      }

      pending = tokens.length;

      var done = function done(err) {
        if (err) {
          opt.highlight = highlight;
          return callback(err);
        }

        var out;

        try {
          out = Parser.parse(tokens, opt);
        } catch (e) {
          err = e;
        }

        opt.highlight = highlight;

        return err ? callback(err) : callback(null, out);
      };

      if (!highlight || highlight.length < 3) {
        return done();
      }

      delete opt.highlight;

      if (!pending) return done();

      for (; i < tokens.length; i++) {
        (function (token) {
          if (token.type !== 'code') {
            return --pending || done();
          }
          return highlight(token.text, token.lang, function (err, code) {
            if (err) return done(err);
            if (code == null || code === token.text) {
              return --pending || done();
            }
            token.text = code;
            token.escaped = true;
            --pending || done();
          });
        })(tokens[i]);
      }

      return;
    }
    try {
      if (opt) opt = merge({}, marked.defaults, opt);
      return Parser.parse(Lexer.lex(src, opt), opt);
    } catch (e) {
      e.message += '\nPlease report this to https://github.com/chjj/marked.';
      if ((opt || marked.defaults).silent) {
        return '<p>An error occured:</p><pre>' + escape(e.message + '', true) + '</pre>';
      }
      throw e;
    }
  }

  /**
   * Options
   */

  marked.options = marked.setOptions = function (opt) {
    merge(marked.defaults, opt);
    return marked;
  };

  marked.defaults = {
    gfm: true,
    tables: true,
    breaks: false,
    pedantic: false,
    sanitize: false,
    sanitizer: null,
    mangle: true,
    smartLists: false,
    silent: false,
    highlight: null,
    langPrefix: 'lang-',
    smartypants: false,
    headerPrefix: '',
    renderer: new Renderer(),
    xhtml: false
  };

  /**
   * Expose
   */

  marked.Parser = Parser;
  marked.parser = Parser.parse;

  marked.Renderer = Renderer;

  marked.Lexer = Lexer;
  marked.lexer = Lexer.lex;

  marked.InlineLexer = InlineLexer;
  marked.inlineLexer = InlineLexer.output;

  marked.parse = marked;

  if (typeof module !== 'undefined' && (typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
    module.exports = marked;
  } else if (typeof define === 'function' && define.amd) {
    define(function () {
      return marked;
    });
  } else {
    this.marked = marked;
  }
}).call(function () {
  return this || (typeof window !== 'undefined' ? window : global);
}());</script><dom-module id="marked-element" assetpath="../bower_components/marked-element/"><template><style>:host{display:block;}.hidden{display:none !important;}</style><content select=".markdown-html"></content><div id="content" class="hidden"></div></template></dom-module><script>

'use strict';

Polymer({

  is: 'marked-element',

  properties: {

    /**
     * The markdown source that should be rendered by this element.
     */
    markdown: {
      observer: 'render',
      type: String,
      value: null
    },
    /**
     * Enable GFM line breaks (regular newlines instead of two spaces for breaks)
     */
    breaks: {
      observer: 'render',
      type: Boolean,
      value: false
    },
    /**
     * Conform to obscure parts of markdown.pl as much as possible. Don't fix any of the original markdown bugs or poor behavior.
     */
    pedantic: {
      observer: 'render',
      type: Boolean,
      value: false
    },
    /**
     * Function used to customize a renderer based on the [API specified in the Marked
     * library](https://github.com/chjj/marked#overriding-renderer-methods).
     * It takes one argument: a marked renderer object, which is mutated by the function.
     */
    renderer: {
      observer: 'render',
      type: Function,
      value: null
    },
    /**
     * Sanitize the output. Ignore any HTML that has been input.
     */
    sanitize: {
      observer: 'render',
      type: Boolean,
      value: false
    },
    /**
     * Use "smart" typographic punctuation for things like quotes and dashes.
     */
    smartypants: {
      observer: 'render',
      type: Boolean,
      value: false
    },
    /**
     * Callback function invoked by Marked after HTML has been rendered.
     * It must take two arguments: err and text and must return the resulting text.
     */
    callback: {
      observer: 'render',
      type: Function,
      value: null
    },
    /**
     * A reference to the XMLHttpRequest instance used to generate the
     * network request.
     *
     * @type {XMLHttpRequest}
     */
    xhr: {
      type: Object,
      notify: true,
      readOnly: true
    }
  },

  ready: function ready() {
    if (this.markdown) {
      return;
    }

    // Use the Markdown from the first `<script>` descendant whose MIME type starts with
    // "text/markdown". Script elements beyond the first are ignored.
    var markdownElement = Polymer.dom(this).querySelector('[type="text/markdown"]');
    if (!markdownElement) {
      return;
    }

    this.markdown = this._unindent(markdownElement.textContent);

    if (markdownElement.src) {
      this._request(markdownElement.src);
    }
  },

  /**
   * Renders `markdown` to HTML when the element is attached.
   *
   * This serves a dual purpose:
   *
   *  * Prevents unnecessary work (no need to render when not visible).
   *
   *  * `attached` fires top-down, so we can give ancestors a chance to
   *    register listeners for the `syntax-highlight` event _before_ we render
   *    any markdown.
   *
   */
  attached: function attached() {
    this._attached = true;
    this._outputElement = this.outputElement;
    this.render();
  },

  detached: function detached() {
    this._attached = false;
  },

  /**
   * Unindents the markdown source that will be rendered.
   */
  unindent: function unindent(text) {
    return this._unindent(text);
  },

  get outputElement() {
    var child = Polymer.dom(this).queryDistributedElements('.markdown-html')[0];

    if (child) return child;

    this.toggleClass('hidden', false, this.$.content);
    return this.$.content;
  },

  /**
   * The `marked-render-complete` event is fired once Markdown to HTML
   * conversion has finished, and the DOM has been populated via the resulting
   * HTML.
   *
   * @event marked-render-complete
   */

  /**
   * Renders `markdown` into this element's DOM.
   *
   * This is automatically called whenever the `markdown` property is changed.
   *
   * The only case where you should be calling this is if you are providing
   * markdown via `<script type="text/markdown">` after this element has been
   * constructed (or updating that markdown).
   */
  render: function render() {
    if (!this._attached) return;
    if (!this.markdown) {
      Polymer.dom(this._outputElement).innerHTML = '';
      return;
    }
    var renderer = new marked.Renderer();
    if (this.renderer) {
      this.renderer(renderer);
    }
    var opts = {
      renderer: renderer,
      highlight: this._highlight.bind(this),
      breaks: this.breaks,
      sanitize: this.sanitize,
      pedantic: this.pedantic,
      smartypants: this.smartypants
    };
    Polymer.dom(this._outputElement).innerHTML = marked(this.markdown, opts, this.callback);
    this.fire('marked-render-complete');
  },

  _highlight: function _highlight(code, lang) {
    var event = this.fire('syntax-highlight', { code: code, lang: lang });
    return event.detail.code || code;
  },

  _unindent: function _unindent(text) {
    if (!text) return text;
    var lines = text.replace(/\t/g, '  ').split('\n');
    var indent = lines.reduce(function (prev, line) {
      if (/^\s*$/.test(line)) return prev; // Completely ignore blank lines.

      var lineIndent = line.match(/^(\s*)/)[0].length;
      if (prev === null) return lineIndent;
      return lineIndent < prev ? lineIndent : prev;
    }, null);

    return lines.map(function (l) {
      return l.substr(indent);
    }).join('\n');
  },

  _request: function _request(url) {
    this._setXhr(new XMLHttpRequest());
    var xhr = this.xhr;

    if (xhr.readyState > 0) {
      return null;
    }

    xhr.addEventListener('error', this._handleError.bind(this));
    xhr.addEventListener('loadend', function (e) {
      var status = this.xhr.status || 0;
      // Note: if we are using the file:// protocol, the status code will be 0
      // for all outcomes (successful or otherwise).
      if (status === 0 || status >= 200 && status < 300) {
        this.markdown = e.target.response;
      } else {
        this._handleError(e);
      }
    }.bind(this));

    xhr.open('GET', url);
    xhr.setRequestHeader('Accept', 'text/markdown');
    xhr.send();
  },

  /**
   * Fired when an error is received while fetching remote markdown content.
   *
   * @event marked-request-error
   */
  _handleError: function _handleError(e) {
    var evt = this.fire('marked-request-error', e, { cancelable: true });
    if (!evt.defaultPrevented) {
      this.markdown = 'Failed loading markdown source';
    }
  }
});</script><script data-manual="">
/* **********************************************
     Begin prism-core.js
********************************************** */

var _self = typeof window !== 'undefined' ? window // if in browser
: typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope ? self // if in worker
: {} // if in node js
;

/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 * MIT license http://www.opensource.org/licenses/mit-license.php/
 * @author Lea Verou http://lea.verou.me
 */

var Prism = function () {

	// Private helper vars
	var lang = /\blang(?:uage)?-(\w+)\b/i;
	var uniqueId = 0;

	var _ = _self.Prism = {
		util: {
			encode: function encode(tokens) {
				if (tokens instanceof Token) {
					return new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);
				} else if (_.util.type(tokens) === 'Array') {
					return tokens.map(_.util.encode);
				} else {
					return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
				}
			},

			type: function type(o) {
				return Object.prototype.toString.call(o).match(/\[object (\w+)\]/)[1];
			},

			objId: function objId(obj) {
				if (!obj['__id']) {
					Object.defineProperty(obj, '__id', { value: ++uniqueId });
				}
				return obj['__id'];
			},

			// Deep clone a language definition (e.g. to extend it)
			clone: function clone(o) {
				var type = _.util.type(o);

				switch (type) {
					case 'Object':
						var clone = {};

						for (var key in o) {
							if (o.hasOwnProperty(key)) {
								clone[key] = _.util.clone(o[key]);
							}
						}

						return clone;

					case 'Array':
						// Check for existence for IE8
						return o.map && o.map(function (v) {
							return _.util.clone(v);
						});
				}

				return o;
			}
		},

		languages: {
			extend: function extend(id, redef) {
				var lang = _.util.clone(_.languages[id]);

				for (var key in redef) {
					lang[key] = redef[key];
				}

				return lang;
			},

			/**
    * Insert a token before another token in a language literal
    * As this needs to recreate the object (we cannot actually insert before keys in object literals),
    * we cannot just provide an object, we need anobject and a key.
    * @param inside The key (or language id) of the parent
    * @param before The key to insert before. If not provided, the function appends instead.
    * @param insert Object with the key/value pairs to insert
    * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.
    */
			insertBefore: function insertBefore(inside, before, insert, root) {
				root = root || _.languages;
				var grammar = root[inside];

				if (arguments.length == 2) {
					insert = arguments[1];

					for (var newToken in insert) {
						if (insert.hasOwnProperty(newToken)) {
							grammar[newToken] = insert[newToken];
						}
					}

					return grammar;
				}

				var ret = {};

				for (var token in grammar) {

					if (grammar.hasOwnProperty(token)) {

						if (token == before) {

							for (var newToken in insert) {

								if (insert.hasOwnProperty(newToken)) {
									ret[newToken] = insert[newToken];
								}
							}
						}

						ret[token] = grammar[token];
					}
				}

				// Update references in other language definitions
				_.languages.DFS(_.languages, function (key, value) {
					if (value === root[inside] && key != inside) {
						this[key] = ret;
					}
				});

				return root[inside] = ret;
			},

			// Traverse a language definition with Depth First Search
			DFS: function DFS(o, callback, type, visited) {
				visited = visited || {};
				for (var i in o) {
					if (o.hasOwnProperty(i)) {
						callback.call(o, i, o[i], type || i);

						if (_.util.type(o[i]) === 'Object' && !visited[_.util.objId(o[i])]) {
							visited[_.util.objId(o[i])] = true;
							_.languages.DFS(o[i], callback, null, visited);
						} else if (_.util.type(o[i]) === 'Array' && !visited[_.util.objId(o[i])]) {
							visited[_.util.objId(o[i])] = true;
							_.languages.DFS(o[i], callback, i, visited);
						}
					}
				}
			}
		},
		plugins: {},

		highlightAll: function highlightAll(async, callback) {
			var env = {
				callback: callback,
				selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
			};

			_.hooks.run("before-highlightall", env);

			var elements = env.elements || document.querySelectorAll(env.selector);

			for (var i = 0, element; element = elements[i++];) {
				_.highlightElement(element, async === true, env.callback);
			}
		},

		highlightElement: function highlightElement(element, async, callback) {
			// Find language
			var language,
			    grammar,
			    parent = element;

			while (parent && !lang.test(parent.className)) {
				parent = parent.parentNode;
			}

			if (parent) {
				language = (parent.className.match(lang) || [, ''])[1].toLowerCase();
				grammar = _.languages[language];
			}

			// Set language on the element, if not present
			element.className = element.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;

			// Set language on the parent, for styling
			parent = element.parentNode;

			if (/pre/i.test(parent.nodeName)) {
				parent.className = parent.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
			}

			var code = element.textContent;

			var env = {
				element: element,
				language: language,
				grammar: grammar,
				code: code
			};

			_.hooks.run('before-sanity-check', env);

			if (!env.code || !env.grammar) {
				if (env.code) {
					env.element.textContent = env.code;
				}
				_.hooks.run('complete', env);
				return;
			}

			_.hooks.run('before-highlight', env);

			if (async && _self.Worker) {
				var worker = new Worker(_.filename);

				worker.onmessage = function (evt) {
					env.highlightedCode = evt.data;

					_.hooks.run('before-insert', env);

					env.element.innerHTML = env.highlightedCode;

					callback && callback.call(env.element);
					_.hooks.run('after-highlight', env);
					_.hooks.run('complete', env);
				};

				worker.postMessage(JSON.stringify({
					language: env.language,
					code: env.code,
					immediateClose: true
				}));
			} else {
				env.highlightedCode = _.highlight(env.code, env.grammar, env.language);

				_.hooks.run('before-insert', env);

				env.element.innerHTML = env.highlightedCode;

				callback && callback.call(element);

				_.hooks.run('after-highlight', env);
				_.hooks.run('complete', env);
			}
		},

		highlight: function highlight(text, grammar, language) {
			var tokens = _.tokenize(text, grammar);
			return Token.stringify(_.util.encode(tokens), language);
		},

		tokenize: function tokenize(text, grammar, language) {
			var Token = _.Token;

			var strarr = [text];

			var rest = grammar.rest;

			if (rest) {
				for (var token in rest) {
					grammar[token] = rest[token];
				}

				delete grammar.rest;
			}

			tokenloop: for (var token in grammar) {
				if (!grammar.hasOwnProperty(token) || !grammar[token]) {
					continue;
				}

				var patterns = grammar[token];
				patterns = _.util.type(patterns) === "Array" ? patterns : [patterns];

				for (var j = 0; j < patterns.length; ++j) {
					var pattern = patterns[j],
					    inside = pattern.inside,
					    lookbehind = !!pattern.lookbehind,
					    greedy = !!pattern.greedy,
					    lookbehindLength = 0,
					    alias = pattern.alias;

					if (greedy && !pattern.pattern.global) {
						// Without the global flag, lastIndex won't work
						var flags = pattern.pattern.toString().match(/[imuy]*$/)[0];
						pattern.pattern = RegExp(pattern.pattern.source, flags + "g");
					}

					pattern = pattern.pattern || pattern;

					// Dont cache length as it changes during the loop
					for (var i = 0, pos = 0; i < strarr.length; pos += strarr[i].length, ++i) {

						var str = strarr[i];

						if (strarr.length > text.length) {
							// Something went terribly wrong, ABORT, ABORT!
							break tokenloop;
						}

						if (str instanceof Token) {
							continue;
						}

						pattern.lastIndex = 0;

						var match = pattern.exec(str),
						    delNum = 1;

						// Greedy patterns can override/remove up to two previously matched tokens
						if (!match && greedy && i != strarr.length - 1) {
							pattern.lastIndex = pos;
							match = pattern.exec(text);
							if (!match) {
								break;
							}

							var from = match.index + (lookbehind ? match[1].length : 0),
							    to = match.index + match[0].length,
							    k = i,
							    p = pos;

							for (var len = strarr.length; k < len && p < to; ++k) {
								p += strarr[k].length;
								// Move the index i to the element in strarr that is closest to from
								if (from >= p) {
									++i;
									pos = p;
								}
							}

							/*
        * If strarr[i] is a Token, then the match starts inside another Token, which is invalid
        * If strarr[k - 1] is greedy we are in conflict with another greedy pattern
        */
							if (strarr[i] instanceof Token || strarr[k - 1].greedy) {
								continue;
							}

							// Number of tokens to delete and replace with the new match
							delNum = k - i;
							str = text.slice(pos, p);
							match.index -= pos;
						}

						if (!match) {
							continue;
						}

						if (lookbehind) {
							lookbehindLength = match[1].length;
						}

						var from = match.index + lookbehindLength,
						    match = match[0].slice(lookbehindLength),
						    to = from + match.length,
						    before = str.slice(0, from),
						    after = str.slice(to);

						var args = [i, delNum];

						if (before) {
							args.push(before);
						}

						var wrapped = new Token(token, inside ? _.tokenize(match, inside) : match, alias, match, greedy);

						args.push(wrapped);

						if (after) {
							args.push(after);
						}

						Array.prototype.splice.apply(strarr, args);
					}
				}
			}

			return strarr;
		},

		hooks: {
			all: {},

			add: function add(name, callback) {
				var hooks = _.hooks.all;

				hooks[name] = hooks[name] || [];

				hooks[name].push(callback);
			},

			run: function run(name, env) {
				var callbacks = _.hooks.all[name];

				if (!callbacks || !callbacks.length) {
					return;
				}

				for (var i = 0, callback; callback = callbacks[i++];) {
					callback(env);
				}
			}
		}
	};

	var Token = _.Token = function (type, content, alias, matchedStr, greedy) {
		this.type = type;
		this.content = content;
		this.alias = alias;
		// Copy of the full string this token was created from
		this.length = (matchedStr || "").length | 0;
		this.greedy = !!greedy;
	};

	Token.stringify = function (o, language, parent) {
		if (typeof o == 'string') {
			return o;
		}

		if (_.util.type(o) === 'Array') {
			return o.map(function (element) {
				return Token.stringify(element, language, o);
			}).join('');
		}

		var env = {
			type: o.type,
			content: Token.stringify(o.content, language, parent),
			tag: 'span',
			classes: ['token', o.type],
			attributes: {},
			language: language,
			parent: parent
		};

		if (env.type == 'comment') {
			env.attributes['spellcheck'] = 'true';
		}

		if (o.alias) {
			var aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];
			Array.prototype.push.apply(env.classes, aliases);
		}

		_.hooks.run('wrap', env);

		var attributes = Object.keys(env.attributes).map(function (name) {
			return name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
		}).join(' ');

		return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + (attributes ? ' ' + attributes : '') + '>' + env.content + '</' + env.tag + '>';
	};

	if (!_self.document) {
		if (!_self.addEventListener) {
			// in Node.js
			return _self.Prism;
		}
		// In worker
		_self.addEventListener('message', function (evt) {
			var message = JSON.parse(evt.data),
			    lang = message.language,
			    code = message.code,
			    immediateClose = message.immediateClose;

			_self.postMessage(_.highlight(code, _.languages[lang], lang));
			if (immediateClose) {
				_self.close();
			}
		}, false);

		return _self.Prism;
	}

	//Get current script and highlight
	var script = document.currentScript || [].slice.call(document.getElementsByTagName("script")).pop();

	if (script) {
		_.filename = script.src;

		if (document.addEventListener && !script.hasAttribute('data-manual')) {
			if (document.readyState !== "loading") {
				if (window.requestAnimationFrame) {
					window.requestAnimationFrame(_.highlightAll);
				} else {
					window.setTimeout(_.highlightAll, 16);
				}
			} else {
				document.addEventListener('DOMContentLoaded', _.highlightAll);
			}
		}
	}

	return _self.Prism;
}();

if (typeof module !== 'undefined' && module.exports) {
	module.exports = Prism;
}

// hack for components to work correctly in node.js
if (typeof global !== 'undefined') {
	global.Prism = Prism;
}

/* **********************************************
     Begin prism-markup.js
********************************************** */

Prism.languages.markup = {
	'comment': /\x3c!--[\w\W]*?--\x3e/,
	'prolog': /<\?[\w\W]+?\?>/,
	'doctype': /<!DOCTYPE[\w\W]+?>/i,
	'cdata': /<!\[CDATA\[[\w\W]*?]]>/i,
	'tag': {
		pattern: /<\/?(?!\d)[^\s>\/=$<]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\\1|\\?(?!\1)[\w\W])*\1|[^\s'">=]+))?)*\s*\/?>/i,
		inside: {
			'tag': {
				pattern: /^<\/?[^\s>\/]+/i,
				inside: {
					'punctuation': /^<\/?/,
					'namespace': /^[^\s>\/:]+:/
				}
			},
			'attr-value': {
				pattern: /=(?:('|")[\w\W]*?(\1)|[^\s>]+)/i,
				inside: {
					'punctuation': /[=>"']/
				}
			},
			'punctuation': /\/?>/,
			'attr-name': {
				pattern: /[^\s>\/]+/,
				inside: {
					'namespace': /^[^\s>\/:]+:/
				}
			}

		}
	},
	'entity': /&#?[\da-z]{1,8};/i
};

// Plugin to make entity title show the real entity, idea by Roman Komarov
Prism.hooks.add('wrap', function (env) {

	if (env.type === 'entity') {
		env.attributes['title'] = env.content.replace(/&amp;/, '&');
	}
});

Prism.languages.xml = Prism.languages.markup;
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;

/* **********************************************
     Begin prism-css.js
********************************************** */

Prism.languages.css = {
	'comment': /\/\*[\w\W]*?\*\//,
	'atrule': {
		pattern: /@[\w-]+?.*?(;|(?=\s*\{))/i,
		inside: {
			'rule': /@[\w-]+/
			// See rest below
		}
	},
	'url': /url\((?:(["'])(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,
	'selector': /[^\{\}\s][^\{\};]*?(?=\s*\{)/,
	'string': {
		pattern: /("|')(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1/,
		greedy: true
	},
	'property': /(\b|\B)[\w-]+(?=\s*:)/i,
	'important': /\B!important\b/i,
	'function': /[-a-z0-9]+(?=\()/i,
	'punctuation': /[(){};:]/
};

Prism.languages.css['atrule'].inside.rest = Prism.util.clone(Prism.languages.css);

if (Prism.languages.markup) {
	Prism.languages.insertBefore('markup', 'tag', {
		'style': {
			pattern: /(<style[\w\W]*?>)[\w\W]*?(?=<\/style>)/i,
			lookbehind: true,
			inside: Prism.languages.css,
			alias: 'language-css'
		}
	});

	Prism.languages.insertBefore('inside', 'attr-value', {
		'style-attr': {
			pattern: /\s*style=("|').*?\1/i,
			inside: {
				'attr-name': {
					pattern: /^\s*style/i,
					inside: Prism.languages.markup.tag.inside
				},
				'punctuation': /^\s*=\s*['"]|['"]\s*$/,
				'attr-value': {
					pattern: /.+/i,
					inside: Prism.languages.css
				}
			},
			alias: 'language-css'
		}
	}, Prism.languages.markup.tag);
}

/* **********************************************
     Begin prism-clike.js
********************************************** */

Prism.languages.clike = {
	'comment': [{
		pattern: /(^|[^\\])\/\*[\w\W]*?\*\//,
		lookbehind: true
	}, {
		pattern: /(^|[^\\:])\/\/.*/,
		lookbehind: true
	}],
	'string': {
		pattern: /(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
		greedy: true
	},
	'class-name': {
		pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/i,
		lookbehind: true,
		inside: {
			punctuation: /(\.|\\)/
		}
	},
	'keyword': /\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
	'boolean': /\b(true|false)\b/,
	'function': /[a-z0-9_]+(?=\()/i,
	'number': /\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i,
	'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
	'punctuation': /[{}[\];(),.:]/
};

/* **********************************************
     Begin prism-javascript.js
********************************************** */

Prism.languages.javascript = Prism.languages.extend('clike', {
	'keyword': /\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\b/,
	'number': /\b-?(0x[\dA-Fa-f]+|0b[01]+|0o[0-7]+|\d*\.?\d+([Ee][+-]?\d+)?|NaN|Infinity)\b/,
	// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
	'function': /[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*(?=\()/i,
	'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*\*?|\/|~|\^|%|\.{3}/
});

Prism.languages.insertBefore('javascript', 'keyword', {
	'regex': {
		pattern: /(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\\\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})]))/,
		lookbehind: true,
		greedy: true
	}
});

Prism.languages.insertBefore('javascript', 'string', {
	'template-string': {
		pattern: /`(?:\\\\|\\?[^\\])*?`/,
		greedy: true,
		inside: {
			'interpolation': {
				pattern: /\$\{[^}]+\}/,
				inside: {
					'interpolation-punctuation': {
						pattern: /^\$\{|\}$/,
						alias: 'punctuation'
					},
					rest: Prism.languages.javascript
				}
			},
			'string': /[\s\S]+/
		}
	}
});

if (Prism.languages.markup) {
	Prism.languages.insertBefore('markup', 'tag', {
		'script': {
			pattern: /(<script[\w\W]*?>)[\w\W]*?(?=<\/script>)/i,
			lookbehind: true,
			inside: Prism.languages.javascript,
			alias: 'language-javascript'
		}
	});
}

Prism.languages.js = Prism.languages.javascript;

/* **********************************************
     Begin prism-file-highlight.js
********************************************** */

(function () {
	if (typeof self === 'undefined' || !self.Prism || !self.document || !document.querySelector) {
		return;
	}

	self.Prism.fileHighlight = function () {

		var Extensions = {
			'js': 'javascript',
			'py': 'python',
			'rb': 'ruby',
			'ps1': 'powershell',
			'psm1': 'powershell',
			'sh': 'bash',
			'bat': 'batch',
			'h': 'c',
			'tex': 'latex'
		};

		if (Array.prototype.forEach) {
			// Check to prevent error in IE8
			Array.prototype.slice.call(document.querySelectorAll('pre[data-src]')).forEach(function (pre) {
				var src = pre.getAttribute('data-src');

				var language,
				    parent = pre;
				var lang = /\blang(?:uage)?-(?!\*)(\w+)\b/i;
				while (parent && !lang.test(parent.className)) {
					parent = parent.parentNode;
				}

				if (parent) {
					language = (pre.className.match(lang) || [, ''])[1];
				}

				if (!language) {
					var extension = (src.match(/\.(\w+)$/) || [, ''])[1];
					language = Extensions[extension] || extension;
				}

				var code = document.createElement('code');
				code.className = 'language-' + language;

				pre.textContent = '';

				code.textContent = 'Loading';

				pre.appendChild(code);

				var xhr = new XMLHttpRequest();

				xhr.open('GET', src, true);

				xhr.onreadystatechange = function () {
					if (xhr.readyState == 4) {

						if (xhr.status < 400 && xhr.responseText) {
							code.textContent = xhr.responseText;

							Prism.highlightElement(code);
						} else if (xhr.status >= 400) {
							code.textContent = ' Error ' + xhr.status + ' while fetching file: ' + xhr.statusText;
						} else {
							code.textContent = ' Error: File does not exist or is empty';
						}
					}
				};

				xhr.send(null);
			});
		}
	};

	document.addEventListener('DOMContentLoaded', self.Prism.fileHighlight);
})();</script><style>code[class*="language-"],
pre[class*="language-"]{color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;}pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection{text-shadow:none;background:#b3d4fc;}pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection{text-shadow:none;background:#b3d4fc;}@media print{code[class*="language-"],
	pre[class*="language-"]{text-shadow:none;}}pre[class*="language-"]{padding:1em;margin:.5em 0;overflow:auto;}:not(pre) > code[class*="language-"],
pre[class*="language-"]{background:#f5f2f0;}:not(pre) > code[class*="language-"]{padding:.1em;border-radius:.3em;white-space:normal;}.token.comment,
.token.prolog,
.token.doctype,
.token.cdata{color:slategray;}.token.punctuation{color:#999;}.namespace{opacity:.7;}.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted{color:#905;}.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted{color:#690;}.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string{color:#a67f59;background:hsla(0, 0%, 100%, .5);}.token.atrule,
.token.attr-value,
.token.keyword{color:#07a;}.token.function{color:#DD4A68;}.token.regex,
.token.important,
.token.variable{color:#e90;}.token.important,
.token.bold{font-weight:bold;}.token.italic{font-style:italic;}.token.entity{cursor:help;}</style><script>
(function () {

  'use strict';

  var HIGHLIGHT_EVENT = 'syntax-highlight';

  Polymer({

    is: 'prism-highlighter',

    properties: {
      /**
       * Adds languages outside of the core Prism languages.
       *
       * Prism includes a few languages in the core library:
       *   - JavaScript
       *   - Markup
       *   - CSS
       *   - C-Like
       * Use this property to extend the core set with other Prism
       * components and custom languages.
       *
       * Example:
       *   ```
       *   <!-- with languages = {'custom': myCustomPrismLang}; -->
       *   <!-- or languages = Prism.languages; -->
       *   <prism-highlighter languages="[[languages]]"></prism-highlighter>
       *   ```
       *
       * @attribute languages
       * @type {!Object}
       */
      languages: {
        type: Object,
        value: function value() {
          return {};
        }
      }
    },

    ready: function ready() {
      this._handler = this._highlight.bind(this);
    },

    attached: function attached() {
      (this.parentElement || this.parentNode.host).addEventListener(HIGHLIGHT_EVENT, this._handler);
    },

    detached: function detached() {
      (this.parentElement || this.parentNode.host).removeEventListener(HIGHLIGHT_EVENT, this._handler);
    },

    /**
     * Handle the highlighting event, if we can.
     *
     * @param {!CustomEvent} event
     */
    _highlight: function _highlight(event) {
      if (!event.detail || !event.detail.code) {
        Polymer.Base._warn('Malformed', HIGHLIGHT_EVENT, 'event:', event.detail);
        return;
      }

      event.stopPropagation();

      var detail = event.detail;
      detail.code = Prism.highlight(detail.code, this._detectLang(detail.code, detail.lang));
    },

    /**
     * Picks a Prism formatter based on the `lang` hint and `code`.
     *
     * @param {string} code The source being highlighted.
     * @param {string=} lang A language hint (e.g. ````LANG`).
     * @return {!prism.Lang}
     */
    _detectLang: function _detectLang(code, lang) {
      if (!lang) {
        // Stupid simple detection if we have no lang, courtesy of:
        // https://github.com/robdodson/mark-down/blob/ac2eaa/mark-down.html#L93-101
        return code.match(/^\s*</) ? Prism.languages.markup : Prism.languages.javascript;
      }

      if (this.languages[lang]) {
        return this.languages[lang];
      } else if (Prism.languages[lang]) {
        return Prism.languages[lang];
      }
      switch (lang.substr(0, 2)) {
        case 'js':
        case 'es':
          return Prism.languages.javascript;
        case 'c':
          return Prism.languages.clike;
        default:
          // The assumption is that you're mostly documenting HTML when in HTML.
          return Prism.languages.markup;
      }
    }

  });
})();</script><dom-module id="rating-stars"><template><style>:host{display:block;}svg{fill:orange;}</style><template is="dom-if" if="[[isNumber(stars)]]"><template is="dom-repeat" items="[[repeat]]"><svg height="12" viewBox="0 0 24 24" width="12" xmlns="http://www.w3.org/2000/svg"><path d="M12.9 15.4l-4.9-2.6-4.9 2.6 0.9-5.4-4-3.9 5.5-0.8 2.4-5 2.4 5 5.5 0.8-3.8 3.9 0.9 5.4z"></path></svg></template></template><template is="dom-if" if="[[!isNumber(stars)]]">[[stars]]</template></template><script>
Polymer({
  is: 'rating-stars',
  properties: {
    stars: Number,
    repeat: {
      type: Array,
      computed: '_emptyArray(stars)'
    }
  },
  isNumber: function isNumber(num) {
    var isNum = !isNaN(num);
    return isNum;
  },
  _emptyArray: function _emptyArray(stars) {
    return new Array(stars);
  }
});</script></dom-module><script>

/**
 * `Polymer.IronScrollTargetBehavior` allows an element to respond to scroll events from a
 * designated scroll target.
 *
 * Elements that consume this behavior can override the `_scrollHandler`
 * method to add logic on the scroll event.
 *
 * @demo demo/scrolling-region.html Scrolling Region
 * @demo demo/document.html Document Element
 * @polymerBehavior
 */
Polymer.IronScrollTargetBehavior = {

  properties: {

    /**
     * Specifies the element that will handle the scroll event
     * on the behalf of the current element. This is typically a reference to an element,
     * but there are a few more posibilities:
     *
     * ### Elements id
     *
     *```html
     * <div id="scrollable-element" style="overflow: auto;">
     *  <x-element scroll-target="scrollable-element">
     *    <!-- Content-->
     *  </x-element>
     * </div>
     *```
     * In this case, the `scrollTarget` will point to the outer div element.
     *
     * ### Document scrolling
     *
     * For document scrolling, you can use the reserved word `document`:
     *
     *```html
     * <x-element scroll-target="document">
     *   <!-- Content -->
     * </x-element>
     *```
     *
     * ### Elements reference
     *
     *```js
     * appHeader.scrollTarget = document.querySelector('#scrollable-element');
     *```
     *
     * @type {Element}
     */
    scrollTarget: {
      type: Object,
      value: function value() {
        return this._defaultScrollTarget;
      }
    }
  },

  observers: ['_scrollTargetChanged(scrollTarget, isAttached)'],

  /**
   * True if the event listener should be installed.
   */
  _shouldHaveListener: true,

  _scrollTargetChanged: function _scrollTargetChanged(scrollTarget, isAttached) {
    var eventTarget;

    if (this._oldScrollTarget) {
      this._toggleScrollListener(false, this._oldScrollTarget);
      this._oldScrollTarget = null;
    }
    if (!isAttached) {
      return;
    }
    // Support element id references
    if (scrollTarget === 'document') {

      this.scrollTarget = this._doc;
    } else if (typeof scrollTarget === 'string') {

      this.scrollTarget = this.domHost ? this.domHost.$[scrollTarget] : Polymer.dom(this.ownerDocument).querySelector('#' + scrollTarget);
    } else if (this._isValidScrollTarget()) {

      this._boundScrollHandler = this._boundScrollHandler || this._scrollHandler.bind(this);
      this._oldScrollTarget = scrollTarget;
      this._toggleScrollListener(this._shouldHaveListener, scrollTarget);
    }
  },

  /**
   * Runs on every scroll event. Consumer of this behavior may override this method.
   *
   * @protected
   */
  _scrollHandler: function scrollHandler() {},

  /**
   * The default scroll target. Consumers of this behavior may want to customize
   * the default scroll target.
   *
   * @type {Element}
   */
  get _defaultScrollTarget() {
    return this._doc;
  },

  /**
   * Shortcut for the document element
   *
   * @type {Element}
   */
  get _doc() {
    return this.ownerDocument.documentElement;
  },

  /**
   * Gets the number of pixels that the content of an element is scrolled upward.
   *
   * @type {number}
   */
  get _scrollTop() {
    if (this._isValidScrollTarget()) {
      return this.scrollTarget === this._doc ? window.pageYOffset : this.scrollTarget.scrollTop;
    }
    return 0;
  },

  /**
   * Gets the number of pixels that the content of an element is scrolled to the left.
   *
   * @type {number}
   */
  get _scrollLeft() {
    if (this._isValidScrollTarget()) {
      return this.scrollTarget === this._doc ? window.pageXOffset : this.scrollTarget.scrollLeft;
    }
    return 0;
  },

  /**
   * Sets the number of pixels that the content of an element is scrolled upward.
   *
   * @type {number}
   */
  set _scrollTop(top) {
    if (this.scrollTarget === this._doc) {
      window.scrollTo(window.pageXOffset, top);
    } else if (this._isValidScrollTarget()) {
      this.scrollTarget.scrollTop = top;
    }
  },

  /**
   * Sets the number of pixels that the content of an element is scrolled to the left.
   *
   * @type {number}
   */
  set _scrollLeft(left) {
    if (this.scrollTarget === this._doc) {
      window.scrollTo(left, window.pageYOffset);
    } else if (this._isValidScrollTarget()) {
      this.scrollTarget.scrollLeft = left;
    }
  },

  /**
   * Scrolls the content to a particular place.
   *
   * @method scroll
   * @param {number} left The left position
   * @param {number} top The top position
   */
  scroll: function scroll(left, top) {
    if (this.scrollTarget === this._doc) {
      window.scrollTo(left, top);
    } else if (this._isValidScrollTarget()) {
      this.scrollTarget.scrollLeft = left;
      this.scrollTarget.scrollTop = top;
    }
  },

  /**
   * Gets the width of the scroll target.
   *
   * @type {number}
   */
  get _scrollTargetWidth() {
    if (this._isValidScrollTarget()) {
      return this.scrollTarget === this._doc ? window.innerWidth : this.scrollTarget.offsetWidth;
    }
    return 0;
  },

  /**
   * Gets the height of the scroll target.
   *
   * @type {number}
   */
  get _scrollTargetHeight() {
    if (this._isValidScrollTarget()) {
      return this.scrollTarget === this._doc ? window.innerHeight : this.scrollTarget.offsetHeight;
    }
    return 0;
  },

  /**
   * Returns true if the scroll target is a valid HTMLElement.
   *
   * @return {boolean}
   */
  _isValidScrollTarget: function _isValidScrollTarget() {
    return this.scrollTarget instanceof HTMLElement;
  },

  _toggleScrollListener: function _toggleScrollListener(yes, scrollTarget) {
    if (!this._boundScrollHandler) {
      return;
    }
    var eventTarget = scrollTarget === this._doc ? window : scrollTarget;

    if (yes) {
      eventTarget.addEventListener('scroll', this._boundScrollHandler);
    } else {
      eventTarget.removeEventListener('scroll', this._boundScrollHandler);
    }
  },

  /**
   * Enables or disables the scroll event listener.
   *
   * @param {boolean} yes True to add the event, False to remove it.
   */
  toggleScrollListener: function toggleScrollListener(yes) {
    this._shouldHaveListener = yes;
    this._toggleScrollListener(yes, this.scrollTarget);
  }

};</script><script>var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
function MakePromise(asap) {
	function Promise(fn) {
		if (_typeof(this) !== 'object' || typeof fn !== 'function') throw new TypeError();
		this._state = null;
		this._value = null;
		this._deferreds = [];

		doResolve(fn, resolve.bind(this), reject.bind(this));
	}

	function handle(deferred) {
		var me = this;
		if (this._state === null) {
			this._deferreds.push(deferred);
			return;
		}
		asap(function () {
			var cb = me._state ? deferred.onFulfilled : deferred.onRejected;
			if (typeof cb !== 'function') {
				(me._state ? deferred.resolve : deferred.reject)(me._value);
				return;
			}
			var ret;
			try {
				ret = cb(me._value);
			} catch (e) {
				deferred.reject(e);
				return;
			}
			deferred.resolve(ret);
		});
	}

	function resolve(newValue) {
		try {
			//Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
			if (newValue === this) throw new TypeError();
			if (newValue && ((typeof newValue === 'undefined' ? 'undefined' : _typeof(newValue)) === 'object' || typeof newValue === 'function')) {
				var then = newValue.then;
				if (typeof then === 'function') {
					doResolve(then.bind(newValue), resolve.bind(this), reject.bind(this));
					return;
				}
			}
			this._state = true;
			this._value = newValue;
			finale.call(this);
		} catch (e) {
			reject.call(this, e);
		}
	}

	function reject(newValue) {
		this._state = false;
		this._value = newValue;
		finale.call(this);
	}

	function finale() {
		for (var i = 0, len = this._deferreds.length; i < len; i++) {
			handle.call(this, this._deferreds[i]);
		}
		this._deferreds = null;
	}

	/**
  * Take a potentially misbehaving resolver function and make sure
  * onFulfilled and onRejected are only called once.
  *
  * Makes no guarantees about asynchrony.
  */
	function doResolve(fn, onFulfilled, onRejected) {
		var done = false;
		try {
			fn(function (value) {
				if (done) return;
				done = true;
				onFulfilled(value);
			}, function (reason) {
				if (done) return;
				done = true;
				onRejected(reason);
			});
		} catch (ex) {
			if (done) return;
			done = true;
			onRejected(ex);
		}
	}

	Promise.prototype['catch'] = function (onRejected) {
		return this.then(null, onRejected);
	};

	Promise.prototype.then = function (onFulfilled, onRejected) {
		var me = this;
		return new Promise(function (resolve, reject) {
			handle.call(me, {
				onFulfilled: onFulfilled,
				onRejected: onRejected,
				resolve: resolve,
				reject: reject
			});
		});
	};

	Promise.resolve = function (value) {
		if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.constructor === Promise) {
			return value;
		}

		return new Promise(function (resolve) {
			resolve(value);
		});
	};

	Promise.reject = function (value) {
		return new Promise(function (resolve, reject) {
			reject(value);
		});
	};

	return Promise;
}

if (typeof module !== 'undefined') {
	module.exports = MakePromise;
}</script><script>
if (!window.Promise) {
  window.Promise = MakePromise(Polymer.Base.async);
}</script><script>
'use strict';

Polymer({
  is: 'iron-request',

  hostAttributes: {
    hidden: true
  },

  properties: {

    /**
     * A reference to the XMLHttpRequest instance used to generate the
     * network request.
     *
     * @type {XMLHttpRequest}
     */
    xhr: {
      type: Object,
      notify: true,
      readOnly: true,
      value: function value() {
        return new XMLHttpRequest();
      }
    },

    /**
     * A reference to the parsed response body, if the `xhr` has completely
     * resolved.
     *
     * @type {*}
     * @default null
     */
    response: {
      type: Object,
      notify: true,
      readOnly: true,
      value: function value() {
        return null;
      }
    },

    /**
     * A reference to the status code, if the `xhr` has completely resolved.
     */
    status: {
      type: Number,
      notify: true,
      readOnly: true,
      value: 0
    },

    /**
     * A reference to the status text, if the `xhr` has completely resolved.
     */
    statusText: {
      type: String,
      notify: true,
      readOnly: true,
      value: ''
    },

    /**
     * A promise that resolves when the `xhr` response comes back, or rejects
     * if there is an error before the `xhr` completes.
     *
     * @type {Promise}
     */
    completes: {
      type: Object,
      readOnly: true,
      notify: true,
      value: function value() {
        return new Promise(function (resolve, reject) {
          this.resolveCompletes = resolve;
          this.rejectCompletes = reject;
        }.bind(this));
      }
    },

    /**
     * An object that contains progress information emitted by the XHR if
     * available.
     *
     * @default {}
     */
    progress: {
      type: Object,
      notify: true,
      readOnly: true,
      value: function value() {
        return {};
      }
    },

    /**
     * Aborted will be true if an abort of the request is attempted.
     */
    aborted: {
      type: Boolean,
      notify: true,
      readOnly: true,
      value: false
    },

    /**
     * Errored will be true if the browser fired an error event from the
     * XHR object (mainly network errors).
     */
    errored: {
      type: Boolean,
      notify: true,
      readOnly: true,
      value: false
    },

    /**
     * TimedOut will be true if the XHR threw a timeout event.
     */
    timedOut: {
      type: Boolean,
      notify: true,
      readOnly: true,
      value: false
    }
  },

  /**
   * Succeeded is true if the request succeeded. The request succeeded if it
   * loaded without error, wasn't aborted, and the status code is  200, and
   * < 300, or if the status code is 0.
   *
   * The status code 0 is accepted as a success because some schemes - e.g.
   * file:// - don't provide status codes.
   *
   * @return {boolean}
   */
  get succeeded() {
    if (this.errored || this.aborted || this.timedOut) {
      return false;
    }
    var status = this.xhr.status || 0;

    // Note: if we are using the file:// protocol, the status code will be 0
    // for all outcomes (successful or otherwise).
    return status === 0 || status >= 200 && status < 300;
  },

  /**
   * Sends an HTTP request to the server and returns the XHR object.
   *
   * The handling of the `body` parameter will vary based on the Content-Type
   * header. See the docs for iron-ajax's `body` param for details.
   *
   * @param {{
   *   url: string,
   *   method: (string|undefined),
   *   async: (boolean|undefined),
   *   body: (ArrayBuffer|ArrayBufferView|Blob|Document|FormData|null|string|undefined|Object),
   *   headers: (Object|undefined),
   *   handleAs: (string|undefined),
   *   jsonPrefix: (string|undefined),
   *   withCredentials: (boolean|undefined)}} options -
   *     url The url to which the request is sent.
   *     method The HTTP method to use, default is GET.
   *     async By default, all requests are sent asynchronously. To send synchronous requests,
   *         set to false.
   *     body The content for the request body for POST method.
   *     headers HTTP request headers.
   *     handleAs The response type. Default is 'text'.
   *     withCredentials Whether or not to send credentials on the request. Default is false.
   *   timeout: (Number|undefined)
   * @return {Promise}
   */
  send: function send(options) {
    var xhr = this.xhr;

    if (xhr.readyState > 0) {
      return null;
    }

    xhr.addEventListener('progress', function (progress) {
      this._setProgress({
        lengthComputable: progress.lengthComputable,
        loaded: progress.loaded,
        total: progress.total
      });
    }.bind(this));

    xhr.addEventListener('error', function (error) {
      this._setErrored(true);
      this._updateStatus();
      this.rejectCompletes(error);
    }.bind(this));

    xhr.addEventListener('timeout', function (error) {
      this._setTimedOut(true);
      this._updateStatus();
      this.rejectCompletes(error);
    }.bind(this));

    xhr.addEventListener('abort', function () {
      this._updateStatus();
      this.rejectCompletes(new Error('Request aborted.'));
    }.bind(this));

    // Called after all of the above.
    xhr.addEventListener('loadend', function () {
      this._updateStatus();
      this._setResponse(this.parseResponse());

      if (!this.succeeded) {
        this.rejectCompletes(new Error('The request failed with status code: ' + this.xhr.status));
        return;
      }

      this.resolveCompletes(this);
    }.bind(this));

    this.url = options.url;
    xhr.open(options.method || 'GET', options.url, options.async !== false);

    var acceptType = {
      'json': 'application/json',
      'text': 'text/plain',
      'html': 'text/html',
      'xml': 'application/xml',
      'arraybuffer': 'application/octet-stream'
    }[options.handleAs];
    var headers = options.headers || Object.create(null);
    var newHeaders = Object.create(null);
    for (var key in headers) {
      newHeaders[key.toLowerCase()] = headers[key];
    }
    headers = newHeaders;

    if (acceptType && !headers['accept']) {
      headers['accept'] = acceptType;
    }
    Object.keys(headers).forEach(function (requestHeader) {
      if (/[A-Z]/.test(requestHeader)) {
        Polymer.Base._error('Headers must be lower case, got', requestHeader);
      }
      xhr.setRequestHeader(requestHeader, headers[requestHeader]);
    }, this);

    if (options.async !== false) {
      if (options.async) {
        xhr.timeout = options.timeout;
      }

      var handleAs = options.handleAs;

      // If a JSON prefix is present, the responseType must be 'text' or the
      // browser wont be able to parse the response.
      if (!!options.jsonPrefix || !handleAs) {
        handleAs = 'text';
      }

      // In IE, `xhr.responseType` is an empty string when the response
      // returns. Hence, caching it as `xhr._responseType`.
      xhr.responseType = xhr._responseType = handleAs;

      // Cache the JSON prefix, if it exists.
      if (!!options.jsonPrefix) {
        xhr._jsonPrefix = options.jsonPrefix;
      }
    }

    xhr.withCredentials = !!options.withCredentials;

    var body = this._encodeBodyObject(options.body, headers['content-type']);

    xhr.send(
    /** @type {ArrayBuffer|ArrayBufferView|Blob|Document|FormData|
               null|string|undefined} */
    body);

    return this.completes;
  },

  /**
   * Attempts to parse the response body of the XHR. If parsing succeeds,
   * the value returned will be deserialized based on the `responseType`
   * set on the XHR.
   *
   * @return {*} The parsed response,
   * or undefined if there was an empty response or parsing failed.
   */
  parseResponse: function parseResponse() {
    var xhr = this.xhr;
    var responseType = xhr.responseType || xhr._responseType;
    var preferResponseText = !this.xhr.responseType;
    var prefixLen = xhr._jsonPrefix && xhr._jsonPrefix.length || 0;

    try {
      switch (responseType) {
        case 'json':
          // If the xhr object doesn't have a natural `xhr.responseType`,
          // we can assume that the browser hasn't parsed the response for us,
          // and so parsing is our responsibility. Likewise if response is
          // undefined, as there's no way to encode undefined in JSON.
          if (preferResponseText || xhr.response === undefined) {
            // Try to emulate the JSON section of the response body section of
            // the spec: https://xhr.spec.whatwg.org/#response-body
            // That is to say, we try to parse as JSON, but if anything goes
            // wrong return null.
            try {
              return JSON.parse(xhr.responseText);
            } catch (_) {
              return null;
            }
          }

          return xhr.response;
        case 'xml':
          return xhr.responseXML;
        case 'blob':
        case 'document':
        case 'arraybuffer':
          return xhr.response;
        case 'text':
        default:
          {
            // If `prefixLen` is set, it implies the response should be parsed
            // as JSON once the prefix of length `prefixLen` is stripped from
            // it. Emulate the behavior above where null is returned on failure
            // to parse.
            if (prefixLen) {
              try {
                return JSON.parse(xhr.responseText.substring(prefixLen));
              } catch (_) {
                return null;
              }
            }
            return xhr.responseText;
          }
      }
    } catch (e) {
      this.rejectCompletes(new Error('Could not parse response. ' + e.message));
    }
  },

  /**
   * Aborts the request.
   */
  abort: function abort() {
    this._setAborted(true);
    this.xhr.abort();
  },

  /**
   * @param {*} body The given body of the request to try and encode.
   * @param {?string} contentType The given content type, to infer an encoding
   *     from.
   * @return {*} Either the encoded body as a string, if successful,
   *     or the unaltered body object if no encoding could be inferred.
   */
  _encodeBodyObject: function _encodeBodyObject(body, contentType) {
    if (typeof body == 'string') {
      return body; // Already encoded.
    }
    var bodyObj = /** @type {Object} */body;
    switch (contentType) {
      case 'application/json':
        return JSON.stringify(bodyObj);
      case 'application/x-www-form-urlencoded':
        return this._wwwFormUrlEncode(bodyObj);
    }
    return body;
  },

  /**
   * @param {Object} object The object to encode as x-www-form-urlencoded.
   * @return {string} .
   */
  _wwwFormUrlEncode: function _wwwFormUrlEncode(object) {
    if (!object) {
      return '';
    }
    var pieces = [];
    Object.keys(object).forEach(function (key) {
      // TODO(rictic): handle array values here, in a consistent way with
      //   iron-ajax params.
      pieces.push(this._wwwFormUrlEncodePiece(key) + '=' + this._wwwFormUrlEncodePiece(object[key]));
    }, this);
    return pieces.join('&');
  },

  /**
   * @param {*} str A key or value to encode as x-www-form-urlencoded.
   * @return {string} .
   */
  _wwwFormUrlEncodePiece: function _wwwFormUrlEncodePiece(str) {
    // Spec says to normalize newlines to \r\n and replace %20 spaces with +.
    // jQuery does this as well, so this is likely to be widely compatible.
    if (str === null) {
      return '';
    }
    return encodeURIComponent(str.toString().replace(/\r?\n/g, '\r\n')).replace(/%20/g, '+');
  },

  /**
   * Updates the status code and status text.
   */
  _updateStatus: function _updateStatus() {
    this._setStatus(this.xhr.status);
    this._setStatusText(this.xhr.statusText === undefined ? '' : this.xhr.statusText);
  }
});</script><script>
'use strict';

Polymer({

  is: 'iron-ajax',

  /**
   * Fired when a request is sent.
   *
   * @event request
   * @event iron-ajax-request
   */

  /**
   * Fired when a response is received.
   *
   * @event response
   * @event iron-ajax-response
   */

  /**
   * Fired when an error is received.
   *
   * @event error
   * @event iron-ajax-error
   */

  hostAttributes: {
    hidden: true
  },

  properties: {
    /**
     * The URL target of the request.
     */
    url: {
      type: String
    },

    /**
     * An object that contains query parameters to be appended to the
     * specified `url` when generating a request. If you wish to set the body
     * content when making a POST request, you should use the `body` property
     * instead.
     */
    params: {
      type: Object,
      value: function value() {
        return {};
      }
    },

    /**
     * The HTTP method to use such as 'GET', 'POST', 'PUT', or 'DELETE'.
     * Default is 'GET'.
     */
    method: {
      type: String,
      value: 'GET'
    },

    /**
     * HTTP request headers to send.
     *
     * Example:
     *
     *     <iron-ajax
     *         auto
     *         url="http://somesite.com"
     *         headers='{"X-Requested-With": "XMLHttpRequest"}'
     *         handle-as="json"></iron-ajax>
     *
     * Note: setting a `Content-Type` header here will override the value
     * specified by the `contentType` property of this element.
     */
    headers: {
      type: Object,
      value: function value() {
        return {};
      }
    },

    /**
     * Content type to use when sending data. If the `contentType` property
     * is set and a `Content-Type` header is specified in the `headers`
     * property, the `headers` property value will take precedence.
     *
     * Varies the handling of the `body` param.
     */
    contentType: {
      type: String,
      value: null
    },

    /**
     * Body content to send with the request, typically used with "POST"
     * requests.
     *
     * If body is a string it will be sent unmodified.
     *
     * If Content-Type is set to a value listed below, then
     * the body will be encoded accordingly.
     *
     *    * `content-type="application/json"`
     *      * body is encoded like `{"foo":"bar baz","x":1}`
     *    * `content-type="application/x-www-form-urlencoded"`
     *      * body is encoded like `foo=bar+baz&x=1`
     *
     * Otherwise the body will be passed to the browser unmodified, and it
     * will handle any encoding (e.g. for FormData, Blob, ArrayBuffer).
     *
     * @type (ArrayBuffer|ArrayBufferView|Blob|Document|FormData|null|string|undefined|Object)
     */
    body: {
      type: Object,
      value: null
    },

    /**
     * Toggle whether XHR is synchronous or asynchronous. Don't change this
     * to true unless You Know What You Are Doing.
     */
    sync: {
      type: Boolean,
      value: false
    },

    /**
     * Specifies what data to store in the `response` property, and
     * to deliver as `event.detail.response` in `response` events.
     *
     * One of:
     *
     *    `text`: uses `XHR.responseText`.
     *
     *    `xml`: uses `XHR.responseXML`.
     *
     *    `json`: uses `XHR.responseText` parsed as JSON.
     *
     *    `arraybuffer`: uses `XHR.response`.
     *
     *    `blob`: uses `XHR.response`.
     *
     *    `document`: uses `XHR.response`.
     */
    handleAs: {
      type: String,
      value: 'json'
    },

    /**
     * Set the withCredentials flag on the request.
     */
    withCredentials: {
      type: Boolean,
      value: false
    },

    /**
     * Set the timeout flag on the request.
     */
    timeout: {
      type: Number,
      value: 0
    },

    /**
     * If true, automatically performs an Ajax request when either `url` or
     * `params` changes.
     */
    auto: {
      type: Boolean,
      value: false
    },

    /**
     * If true, error messages will automatically be logged to the console.
     */
    verbose: {
      type: Boolean,
      value: false
    },

    /**
     * The most recent request made by this iron-ajax element.
     */
    lastRequest: {
      type: Object,
      notify: true,
      readOnly: true
    },

    /**
     * True while lastRequest is in flight.
     */
    loading: {
      type: Boolean,
      notify: true,
      readOnly: true
    },

    /**
     * lastRequest's response.
     *
     * Note that lastResponse and lastError are set when lastRequest finishes,
     * so if loading is true, then lastResponse and lastError will correspond
     * to the result of the previous request.
     *
     * The type of the response is determined by the value of `handleAs` at
     * the time that the request was generated.
     *
     * @type {Object}
     */
    lastResponse: {
      type: Object,
      notify: true,
      readOnly: true
    },

    /**
     * lastRequest's error, if any.
     *
     * @type {Object}
     */
    lastError: {
      type: Object,
      notify: true,
      readOnly: true
    },

    /**
     * An Array of all in-flight requests originating from this iron-ajax
     * element.
     */
    activeRequests: {
      type: Array,
      notify: true,
      readOnly: true,
      value: function value() {
        return [];
      }
    },

    /**
     * Length of time in milliseconds to debounce multiple automatically generated requests.
     */
    debounceDuration: {
      type: Number,
      value: 0,
      notify: true
    },

    /**
     * Prefix to be stripped from a JSON response before parsing it.
     *
     * In order to prevent an attack using CSRF with Array responses
     * (http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx/)
     * many backends will mitigate this by prefixing all JSON response bodies
     * with a string that would be nonsensical to a JavaScript parser.
     *
     */
    jsonPrefix: {
      type: String,
      value: ''
    },

    /**
     * By default, iron-ajax's events do not bubble. Setting this attribute will cause its
     * request and response events as well as its iron-ajax-request, -response,  and -error
     * events to bubble to the window object. The vanilla error event never bubbles when
     * using shadow dom even if this.bubbles is true because a scoped flag is not passed with
     * it (first link) and because the shadow dom spec did not used to allow certain events,
     * including events named error, to leak outside of shadow trees (second link).
     * https://www.w3.org/TR/shadow-dom/#scoped-flag
     * https://www.w3.org/TR/2015/WD-shadow-dom-20151215/#events-that-are-not-leaked-into-ancestor-trees
     */
    bubbles: {
      type: Boolean,
      value: false
    },

    _boundHandleResponse: {
      type: Function,
      value: function value() {
        return this._handleResponse.bind(this);
      }
    }
  },

  observers: ['_requestOptionsChanged(url, method, params.*, headers, contentType, ' + 'body, sync, handleAs, jsonPrefix, withCredentials, timeout, auto)'],

  /**
   * The query string that should be appended to the `url`, serialized from
   * the current value of `params`.
   *
   * @return {string}
   */
  get queryString() {
    var queryParts = [];
    var param;
    var value;

    for (param in this.params) {
      value = this.params[param];
      param = window.encodeURIComponent(param);

      if (Array.isArray(value)) {
        for (var i = 0; i < value.length; i++) {
          queryParts.push(param + '=' + window.encodeURIComponent(value[i]));
        }
      } else if (value !== null) {
        queryParts.push(param + '=' + window.encodeURIComponent(value));
      } else {
        queryParts.push(param);
      }
    }

    return queryParts.join('&');
  },

  /**
   * The `url` with query string (if `params` are specified), suitable for
   * providing to an `iron-request` instance.
   *
   * @return {string}
   */
  get requestUrl() {
    var queryString = this.queryString;
    var url = this.url || '';

    if (queryString) {
      var bindingChar = url.indexOf('?') >= 0 ? '&' : '?';
      return url + bindingChar + queryString;
    }

    return url;
  },

  /**
   * An object that maps header names to header values, first applying the
   * the value of `Content-Type` and then overlaying the headers specified
   * in the `headers` property.
   *
   * @return {Object}
   */
  get requestHeaders() {
    var headers = {};
    var contentType = this.contentType;
    if (contentType == null && typeof this.body === 'string') {
      contentType = 'application/x-www-form-urlencoded';
    }
    if (contentType) {
      headers['content-type'] = contentType;
    }
    var header;

    if (this.headers instanceof Object) {
      for (header in this.headers) {
        headers[header] = this.headers[header].toString();
      }
    }

    return headers;
  },

  /**
   * Request options suitable for generating an `iron-request` instance based
   * on the current state of the `iron-ajax` instance's properties.
   *
   * @return {{
   *   url: string,
   *   method: (string|undefined),
   *   async: (boolean|undefined),
   *   body: (ArrayBuffer|ArrayBufferView|Blob|Document|FormData|null|string|undefined|Object),
   *   headers: (Object|undefined),
   *   handleAs: (string|undefined),
   *   jsonPrefix: (string|undefined),
   *   withCredentials: (boolean|undefined)}}
   */
  toRequestOptions: function toRequestOptions() {
    return {
      url: this.requestUrl || '',
      method: this.method,
      headers: this.requestHeaders,
      body: this.body,
      async: !this.sync,
      handleAs: this.handleAs,
      jsonPrefix: this.jsonPrefix,
      withCredentials: this.withCredentials,
      timeout: this.timeout
    };
  },

  /**
   * Performs an AJAX request to the specified URL.
   *
   * @return {!IronRequestElement}
   */
  generateRequest: function generateRequest() {
    var request = /** @type {!IronRequestElement} */document.createElement('iron-request');
    var requestOptions = this.toRequestOptions();

    this.push('activeRequests', request);

    request.completes.then(this._boundHandleResponse).catch(this._handleError.bind(this, request)).then(this._discardRequest.bind(this, request));

    request.send(requestOptions);

    this._setLastRequest(request);
    this._setLoading(true);

    this.fire('request', {
      request: request,
      options: requestOptions
    }, { bubbles: this.bubbles });

    this.fire('iron-ajax-request', {
      request: request,
      options: requestOptions
    }, { bubbles: this.bubbles });

    return request;
  },

  _handleResponse: function _handleResponse(request) {
    if (request === this.lastRequest) {
      this._setLastResponse(request.response);
      this._setLastError(null);
      this._setLoading(false);
    }
    this.fire('response', request, { bubbles: this.bubbles });
    this.fire('iron-ajax-response', request, { bubbles: this.bubbles });
  },

  _handleError: function _handleError(request, error) {
    if (this.verbose) {
      Polymer.Base._error(error);
    }

    if (request === this.lastRequest) {
      this._setLastError({
        request: request,
        error: error,
        status: request.xhr.status,
        statusText: request.xhr.statusText,
        response: request.xhr.response
      });
      this._setLastResponse(null);
      this._setLoading(false);
    }

    // Tests fail if this goes after the normal this.fire('error', ...)
    this.fire('iron-ajax-error', {
      request: request,
      error: error
    }, { bubbles: this.bubbles });

    this.fire('error', {
      request: request,
      error: error
    }, { bubbles: this.bubbles });
  },

  _discardRequest: function _discardRequest(request) {
    var requestIndex = this.activeRequests.indexOf(request);

    if (requestIndex > -1) {
      this.splice('activeRequests', requestIndex, 1);
    }
  },

  _requestOptionsChanged: function _requestOptionsChanged() {
    this.debounce('generate-request', function () {
      if (this.url == null) {
        return;
      }

      if (this.auto) {
        this.generateRequest();
      }
    }, this.debounceDuration);
  }

});</script></div></body></html>